/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "inner_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace bbts { namespace tracker {


StoredPeerInfo::~StoredPeerInfo() throw() {
}


void StoredPeerInfo::__set_info_hash(const std::string& val) {
  this->info_hash = val;
__isset.info_hash = true;
}

void StoredPeerInfo::__set_peer_id(const std::string& val) {
  this->peer_id = val;
__isset.peer_id = true;
}

void StoredPeerInfo::__set_ip(const std::string& val) {
  this->ip = val;
__isset.ip = true;
}

void StoredPeerInfo::__set_port(const int32_t val) {
  this->port = val;
__isset.port = true;
}

void StoredPeerInfo::__set_uploaded(const int64_t val) {
  this->uploaded = val;
__isset.uploaded = true;
}

void StoredPeerInfo::__set_downloaded(const int64_t val) {
  this->downloaded = val;
__isset.downloaded = true;
}

void StoredPeerInfo::__set_left(const int64_t val) {
  this->left = val;
__isset.left = true;
}

void StoredPeerInfo::__set_status(const  ::bbts::tracker::Status::type val) {
  this->status = val;
__isset.status = true;
}

void StoredPeerInfo::__set_want_number(const int32_t val) {
  this->want_number = val;
__isset.want_number = true;
}

void StoredPeerInfo::__set_expire_time(const int64_t val) {
  this->expire_time = val;
__isset.expire_time = true;
}

void StoredPeerInfo::__set_timestamp_start(const int64_t val) {
  this->timestamp_start = val;
__isset.timestamp_start = true;
}

void StoredPeerInfo::__set_is_seed(const bool val) {
  this->is_seed = val;
__isset.is_seed = true;
}

void StoredPeerInfo::__set_tracker_id(const std::string& val) {
  this->tracker_id = val;
__isset.tracker_id = true;
}

void StoredPeerInfo::__set_idc(const std::string& val) {
  this->idc = val;
__isset.idc = true;
}

uint32_t StoredPeerInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->info_hash);
          this->__isset.info_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->peer_id);
          this->__isset.peer_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uploaded);
          this->__isset.uploaded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->downloaded);
          this->__isset.downloaded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->left);
          this->__isset.left = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->status = ( ::bbts::tracker::Status::type)ecast0;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->want_number);
          this->__isset.want_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->expire_time);
          this->__isset.expire_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp_start);
          this->__isset.timestamp_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_seed);
          this->__isset.is_seed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tracker_id);
          this->__isset.tracker_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->idc);
          this->__isset.idc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StoredPeerInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StoredPeerInfo");

  if (this->__isset.info_hash) {
    xfer += oprot->writeFieldBegin("info_hash", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->info_hash);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.peer_id) {
    xfer += oprot->writeFieldBegin("peer_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->peer_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip) {
    xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->ip);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.port) {
    xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.uploaded) {
    xfer += oprot->writeFieldBegin("uploaded", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->uploaded);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.downloaded) {
    xfer += oprot->writeFieldBegin("downloaded", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->downloaded);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.left) {
    xfer += oprot->writeFieldBegin("left", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->left);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.want_number) {
    xfer += oprot->writeFieldBegin("want_number", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->want_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.expire_time) {
    xfer += oprot->writeFieldBegin("expire_time", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->expire_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp_start) {
    xfer += oprot->writeFieldBegin("timestamp_start", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->timestamp_start);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_seed) {
    xfer += oprot->writeFieldBegin("is_seed", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->is_seed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tracker_id) {
    xfer += oprot->writeFieldBegin("tracker_id", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->tracker_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.idc) {
    xfer += oprot->writeFieldBegin("idc", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->idc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StoredPeerInfo &a, StoredPeerInfo &b) {
  using ::std::swap;
  swap(a.info_hash, b.info_hash);
  swap(a.peer_id, b.peer_id);
  swap(a.ip, b.ip);
  swap(a.port, b.port);
  swap(a.uploaded, b.uploaded);
  swap(a.downloaded, b.downloaded);
  swap(a.left, b.left);
  swap(a.status, b.status);
  swap(a.want_number, b.want_number);
  swap(a.expire_time, b.expire_time);
  swap(a.timestamp_start, b.timestamp_start);
  swap(a.is_seed, b.is_seed);
  swap(a.tracker_id, b.tracker_id);
  swap(a.idc, b.idc);
  swap(a.__isset, b.__isset);
}

StoredPeerInfo::StoredPeerInfo(const StoredPeerInfo& other1) {
  info_hash = other1.info_hash;
  peer_id = other1.peer_id;
  ip = other1.ip;
  port = other1.port;
  uploaded = other1.uploaded;
  downloaded = other1.downloaded;
  left = other1.left;
  status = other1.status;
  want_number = other1.want_number;
  expire_time = other1.expire_time;
  timestamp_start = other1.timestamp_start;
  is_seed = other1.is_seed;
  tracker_id = other1.tracker_id;
  idc = other1.idc;
  __isset = other1.__isset;
}
StoredPeerInfo& StoredPeerInfo::operator=(const StoredPeerInfo& other2) {
  info_hash = other2.info_hash;
  peer_id = other2.peer_id;
  ip = other2.ip;
  port = other2.port;
  uploaded = other2.uploaded;
  downloaded = other2.downloaded;
  left = other2.left;
  status = other2.status;
  want_number = other2.want_number;
  expire_time = other2.expire_time;
  timestamp_start = other2.timestamp_start;
  is_seed = other2.is_seed;
  tracker_id = other2.tracker_id;
  idc = other2.idc;
  __isset = other2.__isset;
  return *this;
}
void StoredPeerInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StoredPeerInfo(";
  out << "info_hash="; (__isset.info_hash ? (out << to_string(info_hash)) : (out << "<null>"));
  out << ", " << "peer_id="; (__isset.peer_id ? (out << to_string(peer_id)) : (out << "<null>"));
  out << ", " << "ip="; (__isset.ip ? (out << to_string(ip)) : (out << "<null>"));
  out << ", " << "port="; (__isset.port ? (out << to_string(port)) : (out << "<null>"));
  out << ", " << "uploaded="; (__isset.uploaded ? (out << to_string(uploaded)) : (out << "<null>"));
  out << ", " << "downloaded="; (__isset.downloaded ? (out << to_string(downloaded)) : (out << "<null>"));
  out << ", " << "left="; (__isset.left ? (out << to_string(left)) : (out << "<null>"));
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ", " << "want_number="; (__isset.want_number ? (out << to_string(want_number)) : (out << "<null>"));
  out << ", " << "expire_time="; (__isset.expire_time ? (out << to_string(expire_time)) : (out << "<null>"));
  out << ", " << "timestamp_start="; (__isset.timestamp_start ? (out << to_string(timestamp_start)) : (out << "<null>"));
  out << ", " << "is_seed="; (__isset.is_seed ? (out << to_string(is_seed)) : (out << "<null>"));
  out << ", " << "tracker_id="; (__isset.tracker_id ? (out << to_string(tracker_id)) : (out << "<null>"));
  out << ", " << "idc="; (__isset.idc ? (out << to_string(idc)) : (out << "<null>"));
  out << ")";
}

}} // namespace
