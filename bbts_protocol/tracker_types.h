/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef tracker_TYPES_H
#define tracker_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>



namespace bbts { namespace tracker {

struct Status {
  enum type {
    METADATA = 0,
    DOWNLOAD = 1,
    SEEDING = 2,
    STOPPED = 3,
    PAUSED = 4
  };
};

extern const std::map<int, const char*> _Status_VALUES_TO_NAMES;

typedef struct _Peer__isset {
  _Peer__isset() : peerid(false), ip(false), port(false), idc(false) {}
  bool peerid;
  bool ip;
  bool port;
  bool idc;
} _Peer__isset;

class Peer {
 public:

  static const char* ascii_fingerprint; // = "0EDE17B70FBE0133B4243A5167158E5C";
  static const uint8_t binary_fingerprint[16]; // = {0x0E,0xDE,0x17,0xB7,0x0F,0xBE,0x01,0x33,0xB4,0x24,0x3A,0x51,0x67,0x15,0x8E,0x5C};

  Peer() : peerid(), ip(), port(0), idc() {
  }

  virtual ~Peer() throw() {}

  std::string peerid;
  std::string ip;
  int32_t port;
  std::string idc;

  _Peer__isset __isset;

  void __set_peerid(const std::string& val) {
    peerid = val;
    __isset.peerid = true;
  }

  void __set_ip(const std::string& val) {
    ip = val;
    __isset.ip = true;
  }

  void __set_port(const int32_t val) {
    port = val;
    __isset.port = true;
  }

  void __set_idc(const std::string& val) {
    idc = val;
    __isset.idc = true;
  }

  bool operator == (const Peer & rhs) const
  {
    if (__isset.peerid != rhs.__isset.peerid)
      return false;
    else if (__isset.peerid && !(peerid == rhs.peerid))
      return false;
    if (__isset.ip != rhs.__isset.ip)
      return false;
    else if (__isset.ip && !(ip == rhs.ip))
      return false;
    if (__isset.port != rhs.__isset.port)
      return false;
    else if (__isset.port && !(port == rhs.port))
      return false;
    if (__isset.idc != rhs.__isset.idc)
      return false;
    else if (__isset.idc && !(idc == rhs.idc))
      return false;
    return true;
  }
  bool operator != (const Peer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Peer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Peer &a, Peer &b);

typedef struct _Stat__isset {
  _Stat__isset() : uploaded(false), downloaded(false), left(false), status(false) {}
  bool uploaded;
  bool downloaded;
  bool left;
  bool status;
} _Stat__isset;

class Stat {
 public:

  static const char* ascii_fingerprint; // = "C07B1CFB37E0EB98E47839B335DDE446";
  static const uint8_t binary_fingerprint[16]; // = {0xC0,0x7B,0x1C,0xFB,0x37,0xE0,0xEB,0x98,0xE4,0x78,0x39,0xB3,0x35,0xDD,0xE4,0x46};

  Stat() : uploaded(0), downloaded(0), left(0), status((Status::type)0) {
  }

  virtual ~Stat() throw() {}

  int64_t uploaded;
  int64_t downloaded;
  int64_t left;
  Status::type status;

  _Stat__isset __isset;

  void __set_uploaded(const int64_t val) {
    uploaded = val;
    __isset.uploaded = true;
  }

  void __set_downloaded(const int64_t val) {
    downloaded = val;
    __isset.downloaded = true;
  }

  void __set_left(const int64_t val) {
    left = val;
    __isset.left = true;
  }

  void __set_status(const Status::type val) {
    status = val;
    __isset.status = true;
  }

  bool operator == (const Stat & rhs) const
  {
    if (__isset.uploaded != rhs.__isset.uploaded)
      return false;
    else if (__isset.uploaded && !(uploaded == rhs.uploaded))
      return false;
    if (__isset.downloaded != rhs.__isset.downloaded)
      return false;
    else if (__isset.downloaded && !(downloaded == rhs.downloaded))
      return false;
    if (__isset.left != rhs.__isset.left)
      return false;
    else if (__isset.left && !(left == rhs.left))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const Stat &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Stat & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Stat &a, Stat &b);

typedef struct _AnnounceRequest__isset {
  _AnnounceRequest__isset() : infohash(false), peer(false), stat(false), is_seed(false), num_want(false) {}
  bool infohash;
  bool peer;
  bool stat;
  bool is_seed;
  bool num_want;
} _AnnounceRequest__isset;

class AnnounceRequest {
 public:

  static const char* ascii_fingerprint; // = "33C7D3582689A7ABD68A3908E9DD9D24";
  static const uint8_t binary_fingerprint[16]; // = {0x33,0xC7,0xD3,0x58,0x26,0x89,0xA7,0xAB,0xD6,0x8A,0x39,0x08,0xE9,0xDD,0x9D,0x24};

  AnnounceRequest() : infohash(), is_seed(0), num_want(0) {
  }

  virtual ~AnnounceRequest() throw() {}

  std::string infohash;
  Peer peer;
  Stat stat;
  bool is_seed;
  int32_t num_want;

  _AnnounceRequest__isset __isset;

  void __set_infohash(const std::string& val) {
    infohash = val;
    __isset.infohash = true;
  }

  void __set_peer(const Peer& val) {
    peer = val;
    __isset.peer = true;
  }

  void __set_stat(const Stat& val) {
    stat = val;
    __isset.stat = true;
  }

  void __set_is_seed(const bool val) {
    is_seed = val;
    __isset.is_seed = true;
  }

  void __set_num_want(const int32_t val) {
    num_want = val;
    __isset.num_want = true;
  }

  bool operator == (const AnnounceRequest & rhs) const
  {
    if (__isset.infohash != rhs.__isset.infohash)
      return false;
    else if (__isset.infohash && !(infohash == rhs.infohash))
      return false;
    if (__isset.peer != rhs.__isset.peer)
      return false;
    else if (__isset.peer && !(peer == rhs.peer))
      return false;
    if (__isset.stat != rhs.__isset.stat)
      return false;
    else if (__isset.stat && !(stat == rhs.stat))
      return false;
    if (__isset.is_seed != rhs.__isset.is_seed)
      return false;
    else if (__isset.is_seed && !(is_seed == rhs.is_seed))
      return false;
    if (__isset.num_want != rhs.__isset.num_want)
      return false;
    else if (__isset.num_want && !(num_want == rhs.num_want))
      return false;
    return true;
  }
  bool operator != (const AnnounceRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AnnounceRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(AnnounceRequest &a, AnnounceRequest &b);

typedef struct _AnnounceResponse__isset {
  _AnnounceResponse__isset() : ret(false), failure_reason(false), min_interval(false), have_seed(false), peers(false) {}
  bool ret;
  bool failure_reason;
  bool min_interval;
  bool have_seed;
  bool peers;
} _AnnounceResponse__isset;

class AnnounceResponse {
 public:

  static const char* ascii_fingerprint; // = "C8C6BD77E5B072384E9C8CCFC7EE1699";
  static const uint8_t binary_fingerprint[16]; // = {0xC8,0xC6,0xBD,0x77,0xE5,0xB0,0x72,0x38,0x4E,0x9C,0x8C,0xCF,0xC7,0xEE,0x16,0x99};

  AnnounceResponse() : ret(0), failure_reason(), min_interval(0), have_seed(0) {
  }

  virtual ~AnnounceResponse() throw() {}

  int16_t ret;
  std::string failure_reason;
  int32_t min_interval;
  bool have_seed;
  std::vector<Peer>  peers;

  _AnnounceResponse__isset __isset;

  void __set_ret(const int16_t val) {
    ret = val;
    __isset.ret = true;
  }

  void __set_failure_reason(const std::string& val) {
    failure_reason = val;
    __isset.failure_reason = true;
  }

  void __set_min_interval(const int32_t val) {
    min_interval = val;
    __isset.min_interval = true;
  }

  void __set_have_seed(const bool val) {
    have_seed = val;
    __isset.have_seed = true;
  }

  void __set_peers(const std::vector<Peer> & val) {
    peers = val;
  }

  bool operator == (const AnnounceResponse & rhs) const
  {
    if (__isset.ret != rhs.__isset.ret)
      return false;
    else if (__isset.ret && !(ret == rhs.ret))
      return false;
    if (__isset.failure_reason != rhs.__isset.failure_reason)
      return false;
    else if (__isset.failure_reason && !(failure_reason == rhs.failure_reason))
      return false;
    if (__isset.min_interval != rhs.__isset.min_interval)
      return false;
    else if (__isset.min_interval && !(min_interval == rhs.min_interval))
      return false;
    if (__isset.have_seed != rhs.__isset.have_seed)
      return false;
    else if (__isset.have_seed && !(have_seed == rhs.have_seed))
      return false;
    if (!(peers == rhs.peers))
      return false;
    return true;
  }
  bool operator != (const AnnounceResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AnnounceResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(AnnounceResponse &a, AnnounceResponse &b);

typedef struct _ControlByInfohashRequest__isset {
  _ControlByInfohashRequest__isset() : ip(false), token(false), infohash(false) {}
  bool ip;
  bool token;
  bool infohash;
} _ControlByInfohashRequest__isset;

class ControlByInfohashRequest {
 public:

  static const char* ascii_fingerprint; // = "B2C950B9C25B62CA02C2A8C700FEE26F";
  static const uint8_t binary_fingerprint[16]; // = {0xB2,0xC9,0x50,0xB9,0xC2,0x5B,0x62,0xCA,0x02,0xC2,0xA8,0xC7,0x00,0xFE,0xE2,0x6F};

  ControlByInfohashRequest() : ip(), token(), infohash() {
  }

  virtual ~ControlByInfohashRequest() throw() {}

  std::string ip;
  std::string token;
  std::string infohash;

  _ControlByInfohashRequest__isset __isset;

  void __set_ip(const std::string& val) {
    ip = val;
    __isset.ip = true;
  }

  void __set_token(const std::string& val) {
    token = val;
    __isset.token = true;
  }

  void __set_infohash(const std::string& val) {
    infohash = val;
    __isset.infohash = true;
  }

  bool operator == (const ControlByInfohashRequest & rhs) const
  {
    if (__isset.ip != rhs.__isset.ip)
      return false;
    else if (__isset.ip && !(ip == rhs.ip))
      return false;
    if (__isset.token != rhs.__isset.token)
      return false;
    else if (__isset.token && !(token == rhs.token))
      return false;
    if (__isset.infohash != rhs.__isset.infohash)
      return false;
    else if (__isset.infohash && !(infohash == rhs.infohash))
      return false;
    return true;
  }
  bool operator != (const ControlByInfohashRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ControlByInfohashRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ControlByInfohashRequest &a, ControlByInfohashRequest &b);

typedef struct _BaseResponse__isset {
  _BaseResponse__isset() : retval(false), message(false) {}
  bool retval;
  bool message;
} _BaseResponse__isset;

class BaseResponse {
 public:

  static const char* ascii_fingerprint; // = "1EAD953E0144F130F7D9B78D8B0DC19F";
  static const uint8_t binary_fingerprint[16]; // = {0x1E,0xAD,0x95,0x3E,0x01,0x44,0xF1,0x30,0xF7,0xD9,0xB7,0x8D,0x8B,0x0D,0xC1,0x9F};

  BaseResponse() : retval(0), message() {
  }

  virtual ~BaseResponse() throw() {}

  int16_t retval;
  std::string message;

  _BaseResponse__isset __isset;

  void __set_retval(const int16_t val) {
    retval = val;
    __isset.retval = true;
  }

  void __set_message(const std::string& val) {
    message = val;
    __isset.message = true;
  }

  bool operator == (const BaseResponse & rhs) const
  {
    if (__isset.retval != rhs.__isset.retval)
      return false;
    else if (__isset.retval && !(retval == rhs.retval))
      return false;
    if (__isset.message != rhs.__isset.message)
      return false;
    else if (__isset.message && !(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const BaseResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BaseResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(BaseResponse &a, BaseResponse &b);

}} // namespace

#endif
