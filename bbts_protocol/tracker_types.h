/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef tracker_TYPES_H
#define tracker_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace bbts { namespace tracker {

struct Status {
  enum type {
    METADATA = 0,
    DOWNLOAD = 1,
    SEEDING = 2,
    STOPPED = 3,
    PAUSED = 4
  };
};

extern const std::map<int, const char*> _Status_VALUES_TO_NAMES;

class Peer;

class Stat;

class AnnounceRequest;

class AnnounceResponse;

class ControlByInfohashRequest;

class BaseResponse;

typedef struct _Peer__isset {
  _Peer__isset() : peerid(false), ip(false), port(false), idc(false) {}
  bool peerid :1;
  bool ip :1;
  bool port :1;
  bool idc :1;
} _Peer__isset;

class Peer : public virtual ::apache::thrift::TBase {
 public:

  Peer(const Peer&);
  Peer& operator=(const Peer&);
  Peer() : peerid(), ip(), port(0), idc() {
  }

  virtual ~Peer() throw();
  std::string peerid;
  std::string ip;
  int32_t port;
  std::string idc;

  _Peer__isset __isset;

  void __set_peerid(const std::string& val);

  void __set_ip(const std::string& val);

  void __set_port(const int32_t val);

  void __set_idc(const std::string& val);

  bool operator == (const Peer & rhs) const
  {
    if (__isset.peerid != rhs.__isset.peerid)
      return false;
    else if (__isset.peerid && !(peerid == rhs.peerid))
      return false;
    if (__isset.ip != rhs.__isset.ip)
      return false;
    else if (__isset.ip && !(ip == rhs.ip))
      return false;
    if (__isset.port != rhs.__isset.port)
      return false;
    else if (__isset.port && !(port == rhs.port))
      return false;
    if (__isset.idc != rhs.__isset.idc)
      return false;
    else if (__isset.idc && !(idc == rhs.idc))
      return false;
    return true;
  }
  bool operator != (const Peer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Peer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Peer &a, Peer &b);

inline std::ostream& operator<<(std::ostream& out, const Peer& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Stat__isset {
  _Stat__isset() : uploaded(false), downloaded(false), left(false), status(false) {}
  bool uploaded :1;
  bool downloaded :1;
  bool left :1;
  bool status :1;
} _Stat__isset;

class Stat : public virtual ::apache::thrift::TBase {
 public:

  Stat(const Stat&);
  Stat& operator=(const Stat&);
  Stat() : uploaded(0), downloaded(0), left(0), status((Status::type)0) {
  }

  virtual ~Stat() throw();
  int64_t uploaded;
  int64_t downloaded;
  int64_t left;
  Status::type status;

  _Stat__isset __isset;

  void __set_uploaded(const int64_t val);

  void __set_downloaded(const int64_t val);

  void __set_left(const int64_t val);

  void __set_status(const Status::type val);

  bool operator == (const Stat & rhs) const
  {
    if (__isset.uploaded != rhs.__isset.uploaded)
      return false;
    else if (__isset.uploaded && !(uploaded == rhs.uploaded))
      return false;
    if (__isset.downloaded != rhs.__isset.downloaded)
      return false;
    else if (__isset.downloaded && !(downloaded == rhs.downloaded))
      return false;
    if (__isset.left != rhs.__isset.left)
      return false;
    else if (__isset.left && !(left == rhs.left))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const Stat &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Stat & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Stat &a, Stat &b);

inline std::ostream& operator<<(std::ostream& out, const Stat& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _AnnounceRequest__isset {
  _AnnounceRequest__isset() : infohash(false), peer(false), stat(false), is_seed(false), num_want(false) {}
  bool infohash :1;
  bool peer :1;
  bool stat :1;
  bool is_seed :1;
  bool num_want :1;
} _AnnounceRequest__isset;

class AnnounceRequest : public virtual ::apache::thrift::TBase {
 public:

  AnnounceRequest(const AnnounceRequest&);
  AnnounceRequest& operator=(const AnnounceRequest&);
  AnnounceRequest() : infohash(), is_seed(0), num_want(0) {
  }

  virtual ~AnnounceRequest() throw();
  std::string infohash;
  Peer peer;
  Stat stat;
  bool is_seed;
  int32_t num_want;

  _AnnounceRequest__isset __isset;

  void __set_infohash(const std::string& val);

  void __set_peer(const Peer& val);

  void __set_stat(const Stat& val);

  void __set_is_seed(const bool val);

  void __set_num_want(const int32_t val);

  bool operator == (const AnnounceRequest & rhs) const
  {
    if (__isset.infohash != rhs.__isset.infohash)
      return false;
    else if (__isset.infohash && !(infohash == rhs.infohash))
      return false;
    if (__isset.peer != rhs.__isset.peer)
      return false;
    else if (__isset.peer && !(peer == rhs.peer))
      return false;
    if (__isset.stat != rhs.__isset.stat)
      return false;
    else if (__isset.stat && !(stat == rhs.stat))
      return false;
    if (__isset.is_seed != rhs.__isset.is_seed)
      return false;
    else if (__isset.is_seed && !(is_seed == rhs.is_seed))
      return false;
    if (__isset.num_want != rhs.__isset.num_want)
      return false;
    else if (__isset.num_want && !(num_want == rhs.num_want))
      return false;
    return true;
  }
  bool operator != (const AnnounceRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AnnounceRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AnnounceRequest &a, AnnounceRequest &b);

inline std::ostream& operator<<(std::ostream& out, const AnnounceRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _AnnounceResponse__isset {
  _AnnounceResponse__isset() : ret(false), failure_reason(false), min_interval(false), have_seed(false), peers(false) {}
  bool ret :1;
  bool failure_reason :1;
  bool min_interval :1;
  bool have_seed :1;
  bool peers :1;
} _AnnounceResponse__isset;

class AnnounceResponse : public virtual ::apache::thrift::TBase {
 public:

  AnnounceResponse(const AnnounceResponse&);
  AnnounceResponse& operator=(const AnnounceResponse&);
  AnnounceResponse() : ret(0), failure_reason(), min_interval(0), have_seed(0) {
  }

  virtual ~AnnounceResponse() throw();
  int16_t ret;
  std::string failure_reason;
  int32_t min_interval;
  bool have_seed;
  std::vector<Peer>  peers;

  _AnnounceResponse__isset __isset;

  void __set_ret(const int16_t val);

  void __set_failure_reason(const std::string& val);

  void __set_min_interval(const int32_t val);

  void __set_have_seed(const bool val);

  void __set_peers(const std::vector<Peer> & val);

  bool operator == (const AnnounceResponse & rhs) const
  {
    if (__isset.ret != rhs.__isset.ret)
      return false;
    else if (__isset.ret && !(ret == rhs.ret))
      return false;
    if (__isset.failure_reason != rhs.__isset.failure_reason)
      return false;
    else if (__isset.failure_reason && !(failure_reason == rhs.failure_reason))
      return false;
    if (__isset.min_interval != rhs.__isset.min_interval)
      return false;
    else if (__isset.min_interval && !(min_interval == rhs.min_interval))
      return false;
    if (__isset.have_seed != rhs.__isset.have_seed)
      return false;
    else if (__isset.have_seed && !(have_seed == rhs.have_seed))
      return false;
    if (!(peers == rhs.peers))
      return false;
    return true;
  }
  bool operator != (const AnnounceResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AnnounceResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AnnounceResponse &a, AnnounceResponse &b);

inline std::ostream& operator<<(std::ostream& out, const AnnounceResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ControlByInfohashRequest__isset {
  _ControlByInfohashRequest__isset() : ip(false), token(false), infohash(false) {}
  bool ip :1;
  bool token :1;
  bool infohash :1;
} _ControlByInfohashRequest__isset;

class ControlByInfohashRequest : public virtual ::apache::thrift::TBase {
 public:

  ControlByInfohashRequest(const ControlByInfohashRequest&);
  ControlByInfohashRequest& operator=(const ControlByInfohashRequest&);
  ControlByInfohashRequest() : ip(), token(), infohash() {
  }

  virtual ~ControlByInfohashRequest() throw();
  std::string ip;
  std::string token;
  std::string infohash;

  _ControlByInfohashRequest__isset __isset;

  void __set_ip(const std::string& val);

  void __set_token(const std::string& val);

  void __set_infohash(const std::string& val);

  bool operator == (const ControlByInfohashRequest & rhs) const
  {
    if (__isset.ip != rhs.__isset.ip)
      return false;
    else if (__isset.ip && !(ip == rhs.ip))
      return false;
    if (__isset.token != rhs.__isset.token)
      return false;
    else if (__isset.token && !(token == rhs.token))
      return false;
    if (__isset.infohash != rhs.__isset.infohash)
      return false;
    else if (__isset.infohash && !(infohash == rhs.infohash))
      return false;
    return true;
  }
  bool operator != (const ControlByInfohashRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ControlByInfohashRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ControlByInfohashRequest &a, ControlByInfohashRequest &b);

inline std::ostream& operator<<(std::ostream& out, const ControlByInfohashRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _BaseResponse__isset {
  _BaseResponse__isset() : retval(false), message(false) {}
  bool retval :1;
  bool message :1;
} _BaseResponse__isset;

class BaseResponse : public virtual ::apache::thrift::TBase {
 public:

  BaseResponse(const BaseResponse&);
  BaseResponse& operator=(const BaseResponse&);
  BaseResponse() : retval(0), message() {
  }

  virtual ~BaseResponse() throw();
  int16_t retval;
  std::string message;

  _BaseResponse__isset __isset;

  void __set_retval(const int16_t val);

  void __set_message(const std::string& val);

  bool operator == (const BaseResponse & rhs) const
  {
    if (__isset.retval != rhs.__isset.retval)
      return false;
    else if (__isset.retval && !(retval == rhs.retval))
      return false;
    if (__isset.message != rhs.__isset.message)
      return false;
    else if (__isset.message && !(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const BaseResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BaseResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BaseResponse &a, BaseResponse &b);

inline std::ostream& operator<<(std::ostream& out, const BaseResponse& obj)
{
  obj.printTo(out);
  return out;
}

}} // namespace

#endif
