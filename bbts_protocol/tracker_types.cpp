/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "tracker_types.h"

#include <algorithm>

namespace bbts { namespace tracker {

int _kStatusValues[] = {
  Status::METADATA,
  Status::DOWNLOAD,
  Status::SEEDING,
  Status::STOPPED,
  Status::PAUSED
};
const char* _kStatusNames[] = {
  "METADATA",
  "DOWNLOAD",
  "SEEDING",
  "STOPPED",
  "PAUSED"
};
const std::map<int, const char*> _Status_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kStatusValues, _kStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* Peer::ascii_fingerprint = "0EDE17B70FBE0133B4243A5167158E5C";
const uint8_t Peer::binary_fingerprint[16] = {0x0E,0xDE,0x17,0xB7,0x0F,0xBE,0x01,0x33,0xB4,0x24,0x3A,0x51,0x67,0x15,0x8E,0x5C};

uint32_t Peer::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->peerid);
          this->__isset.peerid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->idc);
          this->__isset.idc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Peer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Peer");

  if (this->__isset.peerid) {
    xfer += oprot->writeFieldBegin("peerid", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->peerid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip) {
    xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->ip);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.port) {
    xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.idc) {
    xfer += oprot->writeFieldBegin("idc", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->idc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Peer &a, Peer &b) {
  using ::std::swap;
  swap(a.peerid, b.peerid);
  swap(a.ip, b.ip);
  swap(a.port, b.port);
  swap(a.idc, b.idc);
  swap(a.__isset, b.__isset);
}

const char* Stat::ascii_fingerprint = "C07B1CFB37E0EB98E47839B335DDE446";
const uint8_t Stat::binary_fingerprint[16] = {0xC0,0x7B,0x1C,0xFB,0x37,0xE0,0xEB,0x98,0xE4,0x78,0x39,0xB3,0x35,0xDD,0xE4,0x46};

uint32_t Stat::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uploaded);
          this->__isset.uploaded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->downloaded);
          this->__isset.downloaded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->left);
          this->__isset.left = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->status = (Status::type)ecast0;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Stat::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Stat");

  if (this->__isset.uploaded) {
    xfer += oprot->writeFieldBegin("uploaded", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->uploaded);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.downloaded) {
    xfer += oprot->writeFieldBegin("downloaded", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->downloaded);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.left) {
    xfer += oprot->writeFieldBegin("left", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->left);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Stat &a, Stat &b) {
  using ::std::swap;
  swap(a.uploaded, b.uploaded);
  swap(a.downloaded, b.downloaded);
  swap(a.left, b.left);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

const char* AnnounceRequest::ascii_fingerprint = "33C7D3582689A7ABD68A3908E9DD9D24";
const uint8_t AnnounceRequest::binary_fingerprint[16] = {0x33,0xC7,0xD3,0x58,0x26,0x89,0xA7,0xAB,0xD6,0x8A,0x39,0x08,0xE9,0xDD,0x9D,0x24};

uint32_t AnnounceRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->infohash);
          this->__isset.infohash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->peer.read(iprot);
          this->__isset.peer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stat.read(iprot);
          this->__isset.stat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_seed);
          this->__isset.is_seed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_want);
          this->__isset.num_want = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AnnounceRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AnnounceRequest");

  if (this->__isset.infohash) {
    xfer += oprot->writeFieldBegin("infohash", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->infohash);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.peer) {
    xfer += oprot->writeFieldBegin("peer", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->peer.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stat) {
    xfer += oprot->writeFieldBegin("stat", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->stat.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_seed) {
    xfer += oprot->writeFieldBegin("is_seed", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->is_seed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_want) {
    xfer += oprot->writeFieldBegin("num_want", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->num_want);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AnnounceRequest &a, AnnounceRequest &b) {
  using ::std::swap;
  swap(a.infohash, b.infohash);
  swap(a.peer, b.peer);
  swap(a.stat, b.stat);
  swap(a.is_seed, b.is_seed);
  swap(a.num_want, b.num_want);
  swap(a.__isset, b.__isset);
}

const char* AnnounceResponse::ascii_fingerprint = "C8C6BD77E5B072384E9C8CCFC7EE1699";
const uint8_t AnnounceResponse::binary_fingerprint[16] = {0xC8,0xC6,0xBD,0x77,0xE5,0xB0,0x72,0x38,0x4E,0x9C,0x8C,0xCF,0xC7,0xEE,0x16,0x99};

uint32_t AnnounceResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->ret);
          this->__isset.ret = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->failure_reason);
          this->__isset.failure_reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->min_interval);
          this->__isset.min_interval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->have_seed);
          this->__isset.have_seed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->peers.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _etype4;
            xfer += iprot->readListBegin(_etype4, _size1);
            this->peers.resize(_size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              xfer += this->peers[_i5].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.peers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AnnounceResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AnnounceResponse");

  if (this->__isset.ret) {
    xfer += oprot->writeFieldBegin("ret", ::apache::thrift::protocol::T_I16, 1);
    xfer += oprot->writeI16(this->ret);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.failure_reason) {
    xfer += oprot->writeFieldBegin("failure_reason", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->failure_reason);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.min_interval) {
    xfer += oprot->writeFieldBegin("min_interval", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->min_interval);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.have_seed) {
    xfer += oprot->writeFieldBegin("have_seed", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->have_seed);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("peers", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->peers.size()));
    std::vector<Peer> ::const_iterator _iter6;
    for (_iter6 = this->peers.begin(); _iter6 != this->peers.end(); ++_iter6)
    {
      xfer += (*_iter6).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AnnounceResponse &a, AnnounceResponse &b) {
  using ::std::swap;
  swap(a.ret, b.ret);
  swap(a.failure_reason, b.failure_reason);
  swap(a.min_interval, b.min_interval);
  swap(a.have_seed, b.have_seed);
  swap(a.peers, b.peers);
  swap(a.__isset, b.__isset);
}

const char* ControlByInfohashRequest::ascii_fingerprint = "B2C950B9C25B62CA02C2A8C700FEE26F";
const uint8_t ControlByInfohashRequest::binary_fingerprint[16] = {0xB2,0xC9,0x50,0xB9,0xC2,0x5B,0x62,0xCA,0x02,0xC2,0xA8,0xC7,0x00,0xFE,0xE2,0x6F};

uint32_t ControlByInfohashRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->infohash);
          this->__isset.infohash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ControlByInfohashRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ControlByInfohashRequest");

  if (this->__isset.ip) {
    xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->ip);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.token) {
    xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->token);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.infohash) {
    xfer += oprot->writeFieldBegin("infohash", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->infohash);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ControlByInfohashRequest &a, ControlByInfohashRequest &b) {
  using ::std::swap;
  swap(a.ip, b.ip);
  swap(a.token, b.token);
  swap(a.infohash, b.infohash);
  swap(a.__isset, b.__isset);
}

const char* BaseResponse::ascii_fingerprint = "1EAD953E0144F130F7D9B78D8B0DC19F";
const uint8_t BaseResponse::binary_fingerprint[16] = {0x1E,0xAD,0x95,0x3E,0x01,0x44,0xF1,0x30,0xF7,0xD9,0xB7,0x8D,0x8B,0x0D,0xC1,0x9F};

uint32_t BaseResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->retval);
          this->__isset.retval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BaseResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BaseResponse");

  if (this->__isset.retval) {
    xfer += oprot->writeFieldBegin("retval", ::apache::thrift::protocol::T_I16, 1);
    xfer += oprot->writeI16(this->retval);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BaseResponse &a, BaseResponse &b) {
  using ::std::swap;
  swap(a.retval, b.retval);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

}} // namespace
