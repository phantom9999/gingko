/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "GroupService_types.h"

#include <algorithm>

namespace bbts { namespace group {

int _kControlTaskTypeValues[] = {
  ControlTaskType::UNKNOWN,
  ControlTaskType::CANCEL,
  ControlTaskType::PAUSE,
  ControlTaskType::RESUME
};
const char* _kControlTaskTypeNames[] = {
  "UNKNOWN",
  "CANCEL",
  "PAUSE",
  "RESUME"
};
const std::map<int, const char*> _ControlTaskType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kControlTaskTypeValues, _kControlTaskTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* GeneralResponse::ascii_fingerprint = "3F5FC93B338687BC7235B1AB103F47B3";
const uint8_t GeneralResponse::binary_fingerprint[16] = {0x3F,0x5F,0xC9,0x3B,0x33,0x86,0x87,0xBC,0x72,0x35,0xB1,0xAB,0x10,0x3F,0x47,0xB3};

uint32_t GeneralResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ret_code);
          this->__isset.ret_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GeneralResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GeneralResponse");

  xfer += oprot->writeFieldBegin("ret_code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ret_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GeneralResponse &a, GeneralResponse &b) {
  using ::std::swap;
  swap(a.ret_code, b.ret_code);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

const char* UserCred::ascii_fingerprint = "6435B39C87AB0E30F30BEDEFD7328C0D";
const uint8_t UserCred::binary_fingerprint[16] = {0x64,0x35,0xB3,0x9C,0x87,0xAB,0x0E,0x30,0xF3,0x0B,0xED,0xEF,0xD7,0x32,0x8C,0x0D};

uint32_t UserCred::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pid);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->gid);
          this->__isset.gid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UserCred::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UserCred");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->pid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->gid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UserCred &a, UserCred &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.gid, b.gid);
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* GroupManagerOptions::ascii_fingerprint = "DCB0FBFF134B30A4BE62C227B4B0932F";
const uint8_t GroupManagerOptions::binary_fingerprint[16] = {0xDC,0xB0,0xFB,0xFF,0x13,0x4B,0x30,0xA4,0xBE,0x62,0xC2,0x27,0xB4,0xB0,0x93,0x2F};

uint32_t GroupManagerOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bind_port);
          this->__isset.bind_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->upload_limit);
          this->__isset.upload_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->download_limit);
          this->__isset.download_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_connections);
          this->__isset.max_connections = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GroupManagerOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GroupManagerOptions");

  if (this->__isset.bind_port) {
    xfer += oprot->writeFieldBegin("bind_port", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->bind_port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upload_limit) {
    xfer += oprot->writeFieldBegin("upload_limit", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->upload_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.download_limit) {
    xfer += oprot->writeFieldBegin("download_limit", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->download_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_connections) {
    xfer += oprot->writeFieldBegin("max_connections", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->max_connections);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GroupManagerOptions &a, GroupManagerOptions &b) {
  using ::std::swap;
  swap(a.bind_port, b.bind_port);
  swap(a.upload_limit, b.upload_limit);
  swap(a.download_limit, b.download_limit);
  swap(a.max_connections, b.max_connections);
  swap(a.timeout, b.timeout);
  swap(a.__isset, b.__isset);
}

const char* ListenPortRange::ascii_fingerprint = "989D1F1AE8D148D5E2119FFEC4BBBEE3";
const uint8_t ListenPortRange::binary_fingerprint[16] = {0x98,0x9D,0x1F,0x1A,0xE8,0xD1,0x48,0xD5,0xE2,0x11,0x9F,0xFE,0xC4,0xBB,0xBE,0xE3};

uint32_t ListenPortRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->start_port);
          this->__isset.start_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->end_port);
          this->__isset.end_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListenPortRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ListenPortRange");

  xfer += oprot->writeFieldBegin("start_port", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->start_port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->end_port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListenPortRange &a, ListenPortRange &b) {
  using ::std::swap;
  swap(a.start_port, b.start_port);
  swap(a.end_port, b.end_port);
  swap(a.__isset, b.__isset);
}

const char* TrackersPair::ascii_fingerprint = "EEBC915CE44901401D881E6091423036";
const uint8_t TrackersPair::binary_fingerprint[16] = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

uint32_t TrackersPair::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TrackersPair::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TrackersPair");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TrackersPair &a, TrackersPair &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

const char* ClusterParam::ascii_fingerprint = "C54745CF5E2800BFF941910D5280EE48";
const uint8_t ClusterParam::binary_fingerprint[16] = {0xC5,0x47,0x45,0xCF,0x5E,0x28,0x00,0xBF,0xF9,0x41,0x91,0x0D,0x52,0x80,0xEE,0x48};

uint32_t ClusterParam::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->passwd);
          this->__isset.passwd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->prefix_path);
          this->__isset.prefix_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClusterParam::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ClusterParam");

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("passwd", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->passwd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prefix_path", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->prefix_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ClusterParam &a, ClusterParam &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.port, b.port);
  swap(a.user, b.user);
  swap(a.passwd, b.passwd);
  swap(a.prefix_path, b.prefix_path);
  swap(a.__isset, b.__isset);
}

const char* DownloadParam::ascii_fingerprint = "873D98E8288CBB061BD4CCFC64A9AFC5";
const uint8_t DownloadParam::binary_fingerprint[16] = {0x87,0x3D,0x98,0xE8,0x28,0x8C,0xBB,0x06,0x1B,0xD4,0xCC,0xFC,0x64,0xA9,0xAF,0xC5};

uint32_t DownloadParam::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->download_limit);
          this->__isset.download_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->upload_limit);
          this->__isset.upload_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connections_limit);
          this->__isset.connections_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->seeding_time);
          this->__isset.seeding_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hang_timeout);
          this->__isset.hang_timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mem_limit);
          this->__isset.mem_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->debug);
          this->__isset.debug = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->print_progress);
          this->__isset.print_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->patition_download);
          this->__isset.patition_download = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->need_save_resume);
          this->__isset.need_save_resume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->need_down_to_tmp_first);
          this->__isset.need_down_to_tmp_first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->quit_by_tracker_failed);
          this->__isset.quit_by_tracker_failed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->storage_pre_allocate);
          this->__isset.storage_pre_allocate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dynamic_allocate);
          this->__isset.dynamic_allocate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->use_dio_read);
          this->__isset.use_dio_read = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->use_dio_write);
          this->__isset.use_dio_write = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ignore_hdfs_error);
          this->__isset.ignore_hdfs_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->torrent_path);
          this->__isset.torrent_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->infohash);
          this->__isset.infohash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->torrent_url);
          this->__isset.torrent_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->new_name);
          this->__isset.new_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->save_path);
          this->__isset.save_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cluster_config.read(iprot);
          this->__isset.cluster_config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->web_seeds.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->web_seeds.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readString(this->web_seeds[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.web_seeds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->listen_port_range.read(iprot);
          this->__isset.listen_port_range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->include_regex.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->include_regex.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += iprot->readString(this->include_regex[_i9]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.include_regex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->exclude_regex.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->exclude_regex.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += iprot->readString(this->exclude_regex[_i14]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.exclude_regex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->control_path);
          this->__isset.control_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->save_torrent_path);
          this->__isset.save_torrent_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cmd);
          this->__isset.cmd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->filter);
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->trackers.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _etype18;
            xfer += iprot->readListBegin(_etype18, _size15);
            this->trackers.resize(_size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              xfer += this->trackers[_i19].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.trackers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cluster_thread_num);
          this->__isset.cluster_thread_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DownloadParam::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DownloadParam");

  xfer += oprot->writeFieldBegin("download_limit", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->download_limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("upload_limit", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->upload_limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connections_limit", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->connections_limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("seeding_time", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->seeding_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->timeout);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hang_timeout", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->hang_timeout);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mem_limit", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->mem_limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("debug", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->debug);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("print_progress", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool(this->print_progress);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("patition_download", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->patition_download);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("need_save_resume", ::apache::thrift::protocol::T_BOOL, 11);
  xfer += oprot->writeBool(this->need_save_resume);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("need_down_to_tmp_first", ::apache::thrift::protocol::T_BOOL, 12);
  xfer += oprot->writeBool(this->need_down_to_tmp_first);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quit_by_tracker_failed", ::apache::thrift::protocol::T_BOOL, 13);
  xfer += oprot->writeBool(this->quit_by_tracker_failed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("storage_pre_allocate", ::apache::thrift::protocol::T_BOOL, 14);
  xfer += oprot->writeBool(this->storage_pre_allocate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dynamic_allocate", ::apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32(this->dynamic_allocate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("use_dio_read", ::apache::thrift::protocol::T_BOOL, 16);
  xfer += oprot->writeBool(this->use_dio_read);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("use_dio_write", ::apache::thrift::protocol::T_BOOL, 17);
  xfer += oprot->writeBool(this->use_dio_write);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ignore_hdfs_error", ::apache::thrift::protocol::T_BOOL, 18);
  xfer += oprot->writeBool(this->ignore_hdfs_error);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("torrent_path", ::apache::thrift::protocol::T_STRING, 19);
  xfer += oprot->writeString(this->torrent_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infohash", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->infohash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("torrent_url", ::apache::thrift::protocol::T_STRING, 21);
  xfer += oprot->writeString(this->torrent_url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("new_name", ::apache::thrift::protocol::T_STRING, 22);
  xfer += oprot->writeString(this->new_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("save_path", ::apache::thrift::protocol::T_STRING, 23);
  xfer += oprot->writeString(this->save_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cluster_config", ::apache::thrift::protocol::T_STRUCT, 24);
  xfer += this->cluster_config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("web_seeds", ::apache::thrift::protocol::T_LIST, 25);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->web_seeds.size()));
    std::vector<std::string> ::const_iterator _iter20;
    for (_iter20 = this->web_seeds.begin(); _iter20 != this->web_seeds.end(); ++_iter20)
    {
      xfer += oprot->writeString((*_iter20));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("listen_port_range", ::apache::thrift::protocol::T_STRUCT, 26);
  xfer += this->listen_port_range.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("include_regex", ::apache::thrift::protocol::T_LIST, 27);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->include_regex.size()));
    std::vector<std::string> ::const_iterator _iter21;
    for (_iter21 = this->include_regex.begin(); _iter21 != this->include_regex.end(); ++_iter21)
    {
      xfer += oprot->writeString((*_iter21));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exclude_regex", ::apache::thrift::protocol::T_LIST, 28);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->exclude_regex.size()));
    std::vector<std::string> ::const_iterator _iter22;
    for (_iter22 = this->exclude_regex.begin(); _iter22 != this->exclude_regex.end(); ++_iter22)
    {
      xfer += oprot->writeString((*_iter22));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("control_path", ::apache::thrift::protocol::T_STRING, 29);
  xfer += oprot->writeString(this->control_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("save_torrent_path", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeString(this->save_torrent_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmd", ::apache::thrift::protocol::T_STRING, 31);
  xfer += oprot->writeString(this->cmd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_STRING, 32);
  xfer += oprot->writeString(this->filter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("trackers", ::apache::thrift::protocol::T_LIST, 33);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->trackers.size()));
    std::vector<TrackersPair> ::const_iterator _iter23;
    for (_iter23 = this->trackers.begin(); _iter23 != this->trackers.end(); ++_iter23)
    {
      xfer += (*_iter23).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cluster_thread_num", ::apache::thrift::protocol::T_I32, 34);
  xfer += oprot->writeI32(this->cluster_thread_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DownloadParam &a, DownloadParam &b) {
  using ::std::swap;
  swap(a.download_limit, b.download_limit);
  swap(a.upload_limit, b.upload_limit);
  swap(a.connections_limit, b.connections_limit);
  swap(a.seeding_time, b.seeding_time);
  swap(a.timeout, b.timeout);
  swap(a.hang_timeout, b.hang_timeout);
  swap(a.mem_limit, b.mem_limit);
  swap(a.debug, b.debug);
  swap(a.print_progress, b.print_progress);
  swap(a.patition_download, b.patition_download);
  swap(a.need_save_resume, b.need_save_resume);
  swap(a.need_down_to_tmp_first, b.need_down_to_tmp_first);
  swap(a.quit_by_tracker_failed, b.quit_by_tracker_failed);
  swap(a.storage_pre_allocate, b.storage_pre_allocate);
  swap(a.dynamic_allocate, b.dynamic_allocate);
  swap(a.use_dio_read, b.use_dio_read);
  swap(a.use_dio_write, b.use_dio_write);
  swap(a.ignore_hdfs_error, b.ignore_hdfs_error);
  swap(a.torrent_path, b.torrent_path);
  swap(a.infohash, b.infohash);
  swap(a.torrent_url, b.torrent_url);
  swap(a.new_name, b.new_name);
  swap(a.save_path, b.save_path);
  swap(a.cluster_config, b.cluster_config);
  swap(a.web_seeds, b.web_seeds);
  swap(a.listen_port_range, b.listen_port_range);
  swap(a.include_regex, b.include_regex);
  swap(a.exclude_regex, b.exclude_regex);
  swap(a.control_path, b.control_path);
  swap(a.save_torrent_path, b.save_torrent_path);
  swap(a.cmd, b.cmd);
  swap(a.filter, b.filter);
  swap(a.trackers, b.trackers);
  swap(a.cluster_thread_num, b.cluster_thread_num);
  swap(a.__isset, b.__isset);
}

const char* TaskStatus::ascii_fingerprint = "236471D565649D0F3060A2C62C1DF3BE";
const uint8_t TaskStatus::binary_fingerprint[16] = {0x23,0x64,0x71,0xD5,0x65,0x64,0x9D,0x0F,0x30,0x60,0xA2,0xC6,0x2C,0x1D,0xF3,0xBE};

uint32_t TaskStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          this->__isset.hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->infohash);
          this->__isset.infohash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->payload_downloaded);
          this->__isset.payload_downloaded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->payload_uploaded);
          this->__isset.payload_uploaded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->progress_ppm);
          this->__isset.progress_ppm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_time);
          this->__isset.start_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->end_time);
          this->__isset.end_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->time_for_download_metadata);
          this->__isset.time_for_download_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->time_for_download);
          this->__isset.time_for_download = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->time_for_check_files);
          this->__isset.time_for_check_files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->time_for_seeding);
          this->__isset.time_for_seeding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->download_limit);
          this->__isset.download_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->upload_limit);
          this->__isset.upload_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_files);
          this->__isset.num_files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_paths);
          this->__isset.num_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_symlinks);
          this->__isset.num_symlinks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->piece_length);
          this->__isset.piece_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_pieces);
          this->__isset.num_pieces = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_hdfs_download);
          this->__isset.is_hdfs_download = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hdfs_address);
          this->__isset.hdfs_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->downloaded_from_hdfs);
          this->__isset.downloaded_from_hdfs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->progress);
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->download_rate);
          this->__isset.download_rate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->upload_rate);
          this->__isset.upload_rate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_task_finished);
          this->__isset.is_task_finished = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->retval);
          this->__isset.retval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state_string);
          this->__isset.state_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->save_path);
          this->__isset.save_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TaskStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TaskStatus");

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infohash", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->infohash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("payload_downloaded", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->payload_downloaded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("payload_uploaded", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->payload_uploaded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("progress_ppm", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->progress_ppm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_time", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->start_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_time", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->end_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_for_download_metadata", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->time_for_download_metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_for_download", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->time_for_download);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_for_check_files", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->time_for_check_files);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_for_seeding", ::apache::thrift::protocol::T_I32, 13);
  xfer += oprot->writeI32(this->time_for_seeding);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("download_limit", ::apache::thrift::protocol::T_I32, 14);
  xfer += oprot->writeI32(this->download_limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("upload_limit", ::apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32(this->upload_limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_files", ::apache::thrift::protocol::T_I32, 16);
  xfer += oprot->writeI32(this->num_files);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_paths", ::apache::thrift::protocol::T_I32, 17);
  xfer += oprot->writeI32(this->num_paths);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_symlinks", ::apache::thrift::protocol::T_I32, 18);
  xfer += oprot->writeI32(this->num_symlinks);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("piece_length", ::apache::thrift::protocol::T_I32, 19);
  xfer += oprot->writeI32(this->piece_length);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_pieces", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->num_pieces);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_hdfs_download", ::apache::thrift::protocol::T_BOOL, 21);
  xfer += oprot->writeBool(this->is_hdfs_download);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hdfs_address", ::apache::thrift::protocol::T_STRING, 22);
  xfer += oprot->writeString(this->hdfs_address);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("downloaded_from_hdfs", ::apache::thrift::protocol::T_I64, 23);
  xfer += oprot->writeI64(this->downloaded_from_hdfs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 24);
  xfer += oprot->writeI32(this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_DOUBLE, 25);
  xfer += oprot->writeDouble(this->progress);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("download_rate", ::apache::thrift::protocol::T_I32, 26);
  xfer += oprot->writeI32(this->download_rate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("upload_rate", ::apache::thrift::protocol::T_I32, 27);
  xfer += oprot->writeI32(this->upload_rate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_task_finished", ::apache::thrift::protocol::T_BOOL, 28);
  xfer += oprot->writeBool(this->is_task_finished);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("retval", ::apache::thrift::protocol::T_I32, 29);
  xfer += oprot->writeI32(this->retval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state_string", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeString(this->state_string);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I32, 31);
  xfer += oprot->writeI32(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("save_path", ::apache::thrift::protocol::T_STRING, 32);
  xfer += oprot->writeString(this->save_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TaskStatus &a, TaskStatus &b) {
  using ::std::swap;
  swap(a.hostname, b.hostname);
  swap(a.ip, b.ip);
  swap(a.port, b.port);
  swap(a.infohash, b.infohash);
  swap(a.payload_downloaded, b.payload_downloaded);
  swap(a.payload_uploaded, b.payload_uploaded);
  swap(a.progress_ppm, b.progress_ppm);
  swap(a.start_time, b.start_time);
  swap(a.end_time, b.end_time);
  swap(a.time_for_download_metadata, b.time_for_download_metadata);
  swap(a.time_for_download, b.time_for_download);
  swap(a.time_for_check_files, b.time_for_check_files);
  swap(a.time_for_seeding, b.time_for_seeding);
  swap(a.download_limit, b.download_limit);
  swap(a.upload_limit, b.upload_limit);
  swap(a.num_files, b.num_files);
  swap(a.num_paths, b.num_paths);
  swap(a.num_symlinks, b.num_symlinks);
  swap(a.piece_length, b.piece_length);
  swap(a.num_pieces, b.num_pieces);
  swap(a.is_hdfs_download, b.is_hdfs_download);
  swap(a.hdfs_address, b.hdfs_address);
  swap(a.downloaded_from_hdfs, b.downloaded_from_hdfs);
  swap(a.state, b.state);
  swap(a.progress, b.progress);
  swap(a.download_rate, b.download_rate);
  swap(a.upload_rate, b.upload_rate);
  swap(a.is_task_finished, b.is_task_finished);
  swap(a.retval, b.retval);
  swap(a.state_string, b.state_string);
  swap(a.uid, b.uid);
  swap(a.save_path, b.save_path);
  swap(a.__isset, b.__isset);
}

const char* TaskOptions::ascii_fingerprint = "BB70D800D5D24F230B9C68B79C518FD4";
const uint8_t TaskOptions::binary_fingerprint[16] = {0xBB,0x70,0xD8,0x00,0xD5,0xD2,0x4F,0x23,0x0B,0x9C,0x68,0xB7,0x9C,0x51,0x8F,0xD4};

uint32_t TaskOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->infohash);
          this->__isset.infohash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->download_limit);
          this->__isset.download_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->upload_limit);
          this->__isset.upload_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connections_limit);
          this->__isset.connections_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TaskOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TaskOptions");

  if (this->__isset.infohash) {
    xfer += oprot->writeFieldBegin("infohash", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->infohash);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.download_limit) {
    xfer += oprot->writeFieldBegin("download_limit", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->download_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upload_limit) {
    xfer += oprot->writeFieldBegin("upload_limit", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->upload_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connections_limit) {
    xfer += oprot->writeFieldBegin("connections_limit", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->connections_limit);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TaskOptions &a, TaskOptions &b) {
  using ::std::swap;
  swap(a.infohash, b.infohash);
  swap(a.download_limit, b.download_limit);
  swap(a.upload_limit, b.upload_limit);
  swap(a.connections_limit, b.connections_limit);
  swap(a.__isset, b.__isset);
}

}} // namespace
