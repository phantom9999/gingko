/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef GroupService_TYPES_H
#define GroupService_TYPES_H

#include <stdint.h>
#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>



namespace bbts { namespace group {

struct ControlTaskType {
  enum type {
    UNKNOWN = 0,
    CANCEL = 1,
    PAUSE = 2,
    RESUME = 3
  };
};

extern const std::map<int, const char*> _ControlTaskType_VALUES_TO_NAMES;

typedef struct _GeneralResponse__isset {
  _GeneralResponse__isset() : ret_code(false), message(false) {}
  bool ret_code;
  bool message;
} _GeneralResponse__isset;

class GeneralResponse {
 public:

  static const char* ascii_fingerprint; // = "3F5FC93B338687BC7235B1AB103F47B3";
  static const uint8_t binary_fingerprint[16]; // = {0x3F,0x5F,0xC9,0x3B,0x33,0x86,0x87,0xBC,0x72,0x35,0xB1,0xAB,0x10,0x3F,0x47,0xB3};

  GeneralResponse() : ret_code(0), message() {
  }

  virtual ~GeneralResponse() throw() {}

  int32_t ret_code;
  std::string message;

  _GeneralResponse__isset __isset;

  void __set_ret_code(const int32_t val) {
    ret_code = val;
  }

  void __set_message(const std::string& val) {
    message = val;
  }

  bool operator == (const GeneralResponse & rhs) const
  {
    if (!(ret_code == rhs.ret_code))
      return false;
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const GeneralResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GeneralResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(GeneralResponse &a, GeneralResponse &b);

typedef struct _UserCred__isset {
  _UserCred__isset() : pid(false), gid(false), uid(false) {}
  bool pid;
  bool gid;
  bool uid;
} _UserCred__isset;

class UserCred {
 public:

  static const char* ascii_fingerprint; // = "6435B39C87AB0E30F30BEDEFD7328C0D";
  static const uint8_t binary_fingerprint[16]; // = {0x64,0x35,0xB3,0x9C,0x87,0xAB,0x0E,0x30,0xF3,0x0B,0xED,0xEF,0xD7,0x32,0x8C,0x0D};

  UserCred() : pid(0), gid(0), uid(0) {
  }

  virtual ~UserCred() throw() {}

  int32_t pid;
  int32_t gid;
  int32_t uid;

  _UserCred__isset __isset;

  void __set_pid(const int32_t val) {
    pid = val;
  }

  void __set_gid(const int32_t val) {
    gid = val;
  }

  void __set_uid(const int32_t val) {
    uid = val;
  }

  bool operator == (const UserCred & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(gid == rhs.gid))
      return false;
    if (!(uid == rhs.uid))
      return false;
    return true;
  }
  bool operator != (const UserCred &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserCred & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(UserCred &a, UserCred &b);

typedef struct _GroupManagerOptions__isset {
  _GroupManagerOptions__isset() : bind_port(false), upload_limit(false), download_limit(false), max_connections(false), timeout(false) {}
  bool bind_port;
  bool upload_limit;
  bool download_limit;
  bool max_connections;
  bool timeout;
} _GroupManagerOptions__isset;

class GroupManagerOptions {
 public:

  static const char* ascii_fingerprint; // = "DCB0FBFF134B30A4BE62C227B4B0932F";
  static const uint8_t binary_fingerprint[16]; // = {0xDC,0xB0,0xFB,0xFF,0x13,0x4B,0x30,0xA4,0xBE,0x62,0xC2,0x27,0xB4,0xB0,0x93,0x2F};

  GroupManagerOptions() : bind_port(0), upload_limit(0), download_limit(0), max_connections(0), timeout(0) {
  }

  virtual ~GroupManagerOptions() throw() {}

  int32_t bind_port;
  int32_t upload_limit;
  int32_t download_limit;
  int32_t max_connections;
  int64_t timeout;

  _GroupManagerOptions__isset __isset;

  void __set_bind_port(const int32_t val) {
    bind_port = val;
    __isset.bind_port = true;
  }

  void __set_upload_limit(const int32_t val) {
    upload_limit = val;
    __isset.upload_limit = true;
  }

  void __set_download_limit(const int32_t val) {
    download_limit = val;
    __isset.download_limit = true;
  }

  void __set_max_connections(const int32_t val) {
    max_connections = val;
    __isset.max_connections = true;
  }

  void __set_timeout(const int64_t val) {
    timeout = val;
    __isset.timeout = true;
  }

  bool operator == (const GroupManagerOptions & rhs) const
  {
    if (__isset.bind_port != rhs.__isset.bind_port)
      return false;
    else if (__isset.bind_port && !(bind_port == rhs.bind_port))
      return false;
    if (__isset.upload_limit != rhs.__isset.upload_limit)
      return false;
    else if (__isset.upload_limit && !(upload_limit == rhs.upload_limit))
      return false;
    if (__isset.download_limit != rhs.__isset.download_limit)
      return false;
    else if (__isset.download_limit && !(download_limit == rhs.download_limit))
      return false;
    if (__isset.max_connections != rhs.__isset.max_connections)
      return false;
    else if (__isset.max_connections && !(max_connections == rhs.max_connections))
      return false;
    if (__isset.timeout != rhs.__isset.timeout)
      return false;
    else if (__isset.timeout && !(timeout == rhs.timeout))
      return false;
    return true;
  }
  bool operator != (const GroupManagerOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GroupManagerOptions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(GroupManagerOptions &a, GroupManagerOptions &b);

typedef struct _ListenPortRange__isset {
  _ListenPortRange__isset() : start_port(true), end_port(true) {}
  bool start_port;
  bool end_port;
} _ListenPortRange__isset;

class ListenPortRange {
 public:

  static const char* ascii_fingerprint; // = "989D1F1AE8D148D5E2119FFEC4BBBEE3";
  static const uint8_t binary_fingerprint[16]; // = {0x98,0x9D,0x1F,0x1A,0xE8,0xD1,0x48,0xD5,0xE2,0x11,0x9F,0xFE,0xC4,0xBB,0xBE,0xE3};

  ListenPortRange() : start_port(18000), end_port(65534) {
  }

  virtual ~ListenPortRange() throw() {}

  int32_t start_port;
  int32_t end_port;

  _ListenPortRange__isset __isset;

  void __set_start_port(const int32_t val) {
    start_port = val;
  }

  void __set_end_port(const int32_t val) {
    end_port = val;
  }

  bool operator == (const ListenPortRange & rhs) const
  {
    if (!(start_port == rhs.start_port))
      return false;
    if (!(end_port == rhs.end_port))
      return false;
    return true;
  }
  bool operator != (const ListenPortRange &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ListenPortRange & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ListenPortRange &a, ListenPortRange &b);

typedef struct _TrackersPair__isset {
  _TrackersPair__isset() : name(false), id(false) {}
  bool name;
  bool id;
} _TrackersPair__isset;

class TrackersPair {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

  TrackersPair() : name(), id(0) {
  }

  virtual ~TrackersPair() throw() {}

  std::string name;
  int32_t id;

  _TrackersPair__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_id(const int32_t val) {
    id = val;
  }

  bool operator == (const TrackersPair & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const TrackersPair &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TrackersPair & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TrackersPair &a, TrackersPair &b);

typedef struct _ClusterParam__isset {
  _ClusterParam__isset() : host(false), port(false), user(false), passwd(false), prefix_path(false) {}
  bool host;
  bool port;
  bool user;
  bool passwd;
  bool prefix_path;
} _ClusterParam__isset;

class ClusterParam {
 public:

  static const char* ascii_fingerprint; // = "C54745CF5E2800BFF941910D5280EE48";
  static const uint8_t binary_fingerprint[16]; // = {0xC5,0x47,0x45,0xCF,0x5E,0x28,0x00,0xBF,0xF9,0x41,0x91,0x0D,0x52,0x80,0xEE,0x48};

  ClusterParam() : host(), port(0), user(), passwd(), prefix_path() {
  }

  virtual ~ClusterParam() throw() {}

  std::string host;
  int32_t port;
  std::string user;
  std::string passwd;
  std::string prefix_path;

  _ClusterParam__isset __isset;

  void __set_host(const std::string& val) {
    host = val;
  }

  void __set_port(const int32_t val) {
    port = val;
  }

  void __set_user(const std::string& val) {
    user = val;
  }

  void __set_passwd(const std::string& val) {
    passwd = val;
  }

  void __set_prefix_path(const std::string& val) {
    prefix_path = val;
  }

  bool operator == (const ClusterParam & rhs) const
  {
    if (!(host == rhs.host))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(passwd == rhs.passwd))
      return false;
    if (!(prefix_path == rhs.prefix_path))
      return false;
    return true;
  }
  bool operator != (const ClusterParam &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClusterParam & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ClusterParam &a, ClusterParam &b);

typedef struct _DownloadParam__isset {
  _DownloadParam__isset() : download_limit(true), upload_limit(true), connections_limit(true), seeding_time(true), timeout(true), hang_timeout(true), mem_limit(true), debug(true), print_progress(true), patition_download(true), need_save_resume(true), need_down_to_tmp_first(true), quit_by_tracker_failed(true), storage_pre_allocate(true), dynamic_allocate(true), use_dio_read(true), use_dio_write(true), ignore_hdfs_error(true), torrent_path(false), infohash(false), torrent_url(false), new_name(false), save_path(false), cluster_config(false), web_seeds(false), listen_port_range(false), include_regex(false), exclude_regex(false), control_path(false), save_torrent_path(false), cmd(false), filter(false), trackers(false), cluster_thread_num(true) {}
  bool download_limit;
  bool upload_limit;
  bool connections_limit;
  bool seeding_time;
  bool timeout;
  bool hang_timeout;
  bool mem_limit;
  bool debug;
  bool print_progress;
  bool patition_download;
  bool need_save_resume;
  bool need_down_to_tmp_first;
  bool quit_by_tracker_failed;
  bool storage_pre_allocate;
  bool dynamic_allocate;
  bool use_dio_read;
  bool use_dio_write;
  bool ignore_hdfs_error;
  bool torrent_path;
  bool infohash;
  bool torrent_url;
  bool new_name;
  bool save_path;
  bool cluster_config;
  bool web_seeds;
  bool listen_port_range;
  bool include_regex;
  bool exclude_regex;
  bool control_path;
  bool save_torrent_path;
  bool cmd;
  bool filter;
  bool trackers;
  bool cluster_thread_num;
} _DownloadParam__isset;

class DownloadParam {
 public:

  static const char* ascii_fingerprint; // = "873D98E8288CBB061BD4CCFC64A9AFC5";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0x3D,0x98,0xE8,0x28,0x8C,0xBB,0x06,0x1B,0xD4,0xCC,0xFC,0x64,0xA9,0xAF,0xC5};

  DownloadParam() : download_limit(10485760), upload_limit(10485760), connections_limit(8000), seeding_time(-2), timeout(0), hang_timeout(0), mem_limit(0), debug(false), print_progress(false), patition_download(false), need_save_resume(false), need_down_to_tmp_first(false), quit_by_tracker_failed(false), storage_pre_allocate(false), dynamic_allocate(-1), use_dio_read(false), use_dio_write(false), ignore_hdfs_error(false), torrent_path(), infohash(), torrent_url(), new_name(), save_path(), control_path(), save_torrent_path(), cmd(), filter(), cluster_thread_num(3) {
  }

  virtual ~DownloadParam() throw() {}

  int32_t download_limit;
  int32_t upload_limit;
  int32_t connections_limit;
  int32_t seeding_time;
  int32_t timeout;
  int32_t hang_timeout;
  int32_t mem_limit;
  bool debug;
  bool print_progress;
  bool patition_download;
  bool need_save_resume;
  bool need_down_to_tmp_first;
  bool quit_by_tracker_failed;
  bool storage_pre_allocate;
  int32_t dynamic_allocate;
  bool use_dio_read;
  bool use_dio_write;
  bool ignore_hdfs_error;
  std::string torrent_path;
  std::string infohash;
  std::string torrent_url;
  std::string new_name;
  std::string save_path;
  ClusterParam cluster_config;
  std::vector<std::string>  web_seeds;
  ListenPortRange listen_port_range;
  std::vector<std::string>  include_regex;
  std::vector<std::string>  exclude_regex;
  std::string control_path;
  std::string save_torrent_path;
  std::string cmd;
  std::string filter;
  std::vector<TrackersPair>  trackers;
  int32_t cluster_thread_num;

  _DownloadParam__isset __isset;

  void __set_download_limit(const int32_t val) {
    download_limit = val;
  }

  void __set_upload_limit(const int32_t val) {
    upload_limit = val;
  }

  void __set_connections_limit(const int32_t val) {
    connections_limit = val;
  }

  void __set_seeding_time(const int32_t val) {
    seeding_time = val;
  }

  void __set_timeout(const int32_t val) {
    timeout = val;
  }

  void __set_hang_timeout(const int32_t val) {
    hang_timeout = val;
  }

  void __set_mem_limit(const int32_t val) {
    mem_limit = val;
  }

  void __set_debug(const bool val) {
    debug = val;
  }

  void __set_print_progress(const bool val) {
    print_progress = val;
  }

  void __set_patition_download(const bool val) {
    patition_download = val;
  }

  void __set_need_save_resume(const bool val) {
    need_save_resume = val;
  }

  void __set_need_down_to_tmp_first(const bool val) {
    need_down_to_tmp_first = val;
  }

  void __set_quit_by_tracker_failed(const bool val) {
    quit_by_tracker_failed = val;
  }

  void __set_storage_pre_allocate(const bool val) {
    storage_pre_allocate = val;
  }

  void __set_dynamic_allocate(const int32_t val) {
    dynamic_allocate = val;
  }

  void __set_use_dio_read(const bool val) {
    use_dio_read = val;
  }

  void __set_use_dio_write(const bool val) {
    use_dio_write = val;
  }

  void __set_ignore_hdfs_error(const bool val) {
    ignore_hdfs_error = val;
  }

  void __set_torrent_path(const std::string& val) {
    torrent_path = val;
  }

  void __set_infohash(const std::string& val) {
    infohash = val;
  }

  void __set_torrent_url(const std::string& val) {
    torrent_url = val;
  }

  void __set_new_name(const std::string& val) {
    new_name = val;
  }

  void __set_save_path(const std::string& val) {
    save_path = val;
  }

  void __set_cluster_config(const ClusterParam& val) {
    cluster_config = val;
  }

  void __set_web_seeds(const std::vector<std::string> & val) {
    web_seeds = val;
  }

  void __set_listen_port_range(const ListenPortRange& val) {
    listen_port_range = val;
  }

  void __set_include_regex(const std::vector<std::string> & val) {
    include_regex = val;
  }

  void __set_exclude_regex(const std::vector<std::string> & val) {
    exclude_regex = val;
  }

  void __set_control_path(const std::string& val) {
    control_path = val;
  }

  void __set_save_torrent_path(const std::string& val) {
    save_torrent_path = val;
  }

  void __set_cmd(const std::string& val) {
    cmd = val;
  }

  void __set_filter(const std::string& val) {
    filter = val;
  }

  void __set_trackers(const std::vector<TrackersPair> & val) {
    trackers = val;
  }

  void __set_cluster_thread_num(const int32_t val) {
    cluster_thread_num = val;
  }

  bool operator == (const DownloadParam & rhs) const
  {
    if (!(download_limit == rhs.download_limit))
      return false;
    if (!(upload_limit == rhs.upload_limit))
      return false;
    if (!(connections_limit == rhs.connections_limit))
      return false;
    if (!(seeding_time == rhs.seeding_time))
      return false;
    if (!(timeout == rhs.timeout))
      return false;
    if (!(hang_timeout == rhs.hang_timeout))
      return false;
    if (!(mem_limit == rhs.mem_limit))
      return false;
    if (!(debug == rhs.debug))
      return false;
    if (!(print_progress == rhs.print_progress))
      return false;
    if (!(patition_download == rhs.patition_download))
      return false;
    if (!(need_save_resume == rhs.need_save_resume))
      return false;
    if (!(need_down_to_tmp_first == rhs.need_down_to_tmp_first))
      return false;
    if (!(quit_by_tracker_failed == rhs.quit_by_tracker_failed))
      return false;
    if (!(storage_pre_allocate == rhs.storage_pre_allocate))
      return false;
    if (!(dynamic_allocate == rhs.dynamic_allocate))
      return false;
    if (!(use_dio_read == rhs.use_dio_read))
      return false;
    if (!(use_dio_write == rhs.use_dio_write))
      return false;
    if (!(ignore_hdfs_error == rhs.ignore_hdfs_error))
      return false;
    if (!(torrent_path == rhs.torrent_path))
      return false;
    if (!(infohash == rhs.infohash))
      return false;
    if (!(torrent_url == rhs.torrent_url))
      return false;
    if (!(new_name == rhs.new_name))
      return false;
    if (!(save_path == rhs.save_path))
      return false;
    if (!(cluster_config == rhs.cluster_config))
      return false;
    if (!(web_seeds == rhs.web_seeds))
      return false;
    if (!(listen_port_range == rhs.listen_port_range))
      return false;
    if (!(include_regex == rhs.include_regex))
      return false;
    if (!(exclude_regex == rhs.exclude_regex))
      return false;
    if (!(control_path == rhs.control_path))
      return false;
    if (!(save_torrent_path == rhs.save_torrent_path))
      return false;
    if (!(cmd == rhs.cmd))
      return false;
    if (!(filter == rhs.filter))
      return false;
    if (!(trackers == rhs.trackers))
      return false;
    if (!(cluster_thread_num == rhs.cluster_thread_num))
      return false;
    return true;
  }
  bool operator != (const DownloadParam &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DownloadParam & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DownloadParam &a, DownloadParam &b);

typedef struct _TaskStatus__isset {
  _TaskStatus__isset() : hostname(false), ip(false), port(true), infohash(false), payload_downloaded(true), payload_uploaded(true), progress_ppm(true), start_time(true), end_time(true), time_for_download_metadata(true), time_for_download(true), time_for_check_files(true), time_for_seeding(true), download_limit(true), upload_limit(true), num_files(true), num_paths(true), num_symlinks(true), piece_length(true), num_pieces(true), is_hdfs_download(true), hdfs_address(false), downloaded_from_hdfs(true), state(true), progress(true), download_rate(true), upload_rate(true), is_task_finished(true), retval(true), state_string(false), uid(true), save_path(false) {}
  bool hostname;
  bool ip;
  bool port;
  bool infohash;
  bool payload_downloaded;
  bool payload_uploaded;
  bool progress_ppm;
  bool start_time;
  bool end_time;
  bool time_for_download_metadata;
  bool time_for_download;
  bool time_for_check_files;
  bool time_for_seeding;
  bool download_limit;
  bool upload_limit;
  bool num_files;
  bool num_paths;
  bool num_symlinks;
  bool piece_length;
  bool num_pieces;
  bool is_hdfs_download;
  bool hdfs_address;
  bool downloaded_from_hdfs;
  bool state;
  bool progress;
  bool download_rate;
  bool upload_rate;
  bool is_task_finished;
  bool retval;
  bool state_string;
  bool uid;
  bool save_path;
} _TaskStatus__isset;

class TaskStatus {
 public:

  static const char* ascii_fingerprint; // = "236471D565649D0F3060A2C62C1DF3BE";
  static const uint8_t binary_fingerprint[16]; // = {0x23,0x64,0x71,0xD5,0x65,0x64,0x9D,0x0F,0x30,0x60,0xA2,0xC6,0x2C,0x1D,0xF3,0xBE};

  TaskStatus() : hostname(), ip(), port(0), infohash(), payload_downloaded(0LL), payload_uploaded(0LL), progress_ppm(0), start_time(0LL), end_time(0LL), time_for_download_metadata(0), time_for_download(0), time_for_check_files(0), time_for_seeding(0), download_limit(0), upload_limit(0), num_files(0), num_paths(0), num_symlinks(0), piece_length(0), num_pieces(0), is_hdfs_download(false), hdfs_address(), downloaded_from_hdfs(0LL), state(-1), progress(0), download_rate(0), upload_rate(0), is_task_finished(false), retval(0), state_string(), uid(-1), save_path() {
  }

  virtual ~TaskStatus() throw() {}

  std::string hostname;
  std::string ip;
  int32_t port;
  std::string infohash;
  int64_t payload_downloaded;
  int64_t payload_uploaded;
  int32_t progress_ppm;
  int64_t start_time;
  int64_t end_time;
  int32_t time_for_download_metadata;
  int32_t time_for_download;
  int32_t time_for_check_files;
  int32_t time_for_seeding;
  int32_t download_limit;
  int32_t upload_limit;
  int32_t num_files;
  int32_t num_paths;
  int32_t num_symlinks;
  int32_t piece_length;
  int32_t num_pieces;
  bool is_hdfs_download;
  std::string hdfs_address;
  int64_t downloaded_from_hdfs;
  int32_t state;
  double progress;
  int32_t download_rate;
  int32_t upload_rate;
  bool is_task_finished;
  int32_t retval;
  std::string state_string;
  int32_t uid;
  std::string save_path;

  _TaskStatus__isset __isset;

  void __set_hostname(const std::string& val) {
    hostname = val;
  }

  void __set_ip(const std::string& val) {
    ip = val;
  }

  void __set_port(const int32_t val) {
    port = val;
  }

  void __set_infohash(const std::string& val) {
    infohash = val;
  }

  void __set_payload_downloaded(const int64_t val) {
    payload_downloaded = val;
  }

  void __set_payload_uploaded(const int64_t val) {
    payload_uploaded = val;
  }

  void __set_progress_ppm(const int32_t val) {
    progress_ppm = val;
  }

  void __set_start_time(const int64_t val) {
    start_time = val;
  }

  void __set_end_time(const int64_t val) {
    end_time = val;
  }

  void __set_time_for_download_metadata(const int32_t val) {
    time_for_download_metadata = val;
  }

  void __set_time_for_download(const int32_t val) {
    time_for_download = val;
  }

  void __set_time_for_check_files(const int32_t val) {
    time_for_check_files = val;
  }

  void __set_time_for_seeding(const int32_t val) {
    time_for_seeding = val;
  }

  void __set_download_limit(const int32_t val) {
    download_limit = val;
  }

  void __set_upload_limit(const int32_t val) {
    upload_limit = val;
  }

  void __set_num_files(const int32_t val) {
    num_files = val;
  }

  void __set_num_paths(const int32_t val) {
    num_paths = val;
  }

  void __set_num_symlinks(const int32_t val) {
    num_symlinks = val;
  }

  void __set_piece_length(const int32_t val) {
    piece_length = val;
  }

  void __set_num_pieces(const int32_t val) {
    num_pieces = val;
  }

  void __set_is_hdfs_download(const bool val) {
    is_hdfs_download = val;
  }

  void __set_hdfs_address(const std::string& val) {
    hdfs_address = val;
  }

  void __set_downloaded_from_hdfs(const int64_t val) {
    downloaded_from_hdfs = val;
  }

  void __set_state(const int32_t val) {
    state = val;
  }

  void __set_progress(const double val) {
    progress = val;
  }

  void __set_download_rate(const int32_t val) {
    download_rate = val;
  }

  void __set_upload_rate(const int32_t val) {
    upload_rate = val;
  }

  void __set_is_task_finished(const bool val) {
    is_task_finished = val;
  }

  void __set_retval(const int32_t val) {
    retval = val;
  }

  void __set_state_string(const std::string& val) {
    state_string = val;
  }

  void __set_uid(const int32_t val) {
    uid = val;
  }

  void __set_save_path(const std::string& val) {
    save_path = val;
  }

  bool operator == (const TaskStatus & rhs) const
  {
    if (!(hostname == rhs.hostname))
      return false;
    if (!(ip == rhs.ip))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(infohash == rhs.infohash))
      return false;
    if (!(payload_downloaded == rhs.payload_downloaded))
      return false;
    if (!(payload_uploaded == rhs.payload_uploaded))
      return false;
    if (!(progress_ppm == rhs.progress_ppm))
      return false;
    if (!(start_time == rhs.start_time))
      return false;
    if (!(end_time == rhs.end_time))
      return false;
    if (!(time_for_download_metadata == rhs.time_for_download_metadata))
      return false;
    if (!(time_for_download == rhs.time_for_download))
      return false;
    if (!(time_for_check_files == rhs.time_for_check_files))
      return false;
    if (!(time_for_seeding == rhs.time_for_seeding))
      return false;
    if (!(download_limit == rhs.download_limit))
      return false;
    if (!(upload_limit == rhs.upload_limit))
      return false;
    if (!(num_files == rhs.num_files))
      return false;
    if (!(num_paths == rhs.num_paths))
      return false;
    if (!(num_symlinks == rhs.num_symlinks))
      return false;
    if (!(piece_length == rhs.piece_length))
      return false;
    if (!(num_pieces == rhs.num_pieces))
      return false;
    if (!(is_hdfs_download == rhs.is_hdfs_download))
      return false;
    if (!(hdfs_address == rhs.hdfs_address))
      return false;
    if (!(downloaded_from_hdfs == rhs.downloaded_from_hdfs))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(progress == rhs.progress))
      return false;
    if (!(download_rate == rhs.download_rate))
      return false;
    if (!(upload_rate == rhs.upload_rate))
      return false;
    if (!(is_task_finished == rhs.is_task_finished))
      return false;
    if (!(retval == rhs.retval))
      return false;
    if (!(state_string == rhs.state_string))
      return false;
    if (!(uid == rhs.uid))
      return false;
    if (!(save_path == rhs.save_path))
      return false;
    return true;
  }
  bool operator != (const TaskStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TaskStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TaskStatus &a, TaskStatus &b);

typedef struct _TaskOptions__isset {
  _TaskOptions__isset() : infohash(false), download_limit(true), upload_limit(true), connections_limit(true) {}
  bool infohash;
  bool download_limit;
  bool upload_limit;
  bool connections_limit;
} _TaskOptions__isset;

class TaskOptions {
 public:

  static const char* ascii_fingerprint; // = "BB70D800D5D24F230B9C68B79C518FD4";
  static const uint8_t binary_fingerprint[16]; // = {0xBB,0x70,0xD8,0x00,0xD5,0xD2,0x4F,0x23,0x0B,0x9C,0x68,0xB7,0x9C,0x51,0x8F,0xD4};

  TaskOptions() : infohash(), download_limit(-1), upload_limit(-1), connections_limit(-1) {
  }

  virtual ~TaskOptions() throw() {}

  std::string infohash;
  int32_t download_limit;
  int32_t upload_limit;
  int32_t connections_limit;

  _TaskOptions__isset __isset;

  void __set_infohash(const std::string& val) {
    infohash = val;
    __isset.infohash = true;
  }

  void __set_download_limit(const int32_t val) {
    download_limit = val;
    __isset.download_limit = true;
  }

  void __set_upload_limit(const int32_t val) {
    upload_limit = val;
    __isset.upload_limit = true;
  }

  void __set_connections_limit(const int32_t val) {
    connections_limit = val;
    __isset.connections_limit = true;
  }

  bool operator == (const TaskOptions & rhs) const
  {
    if (__isset.infohash != rhs.__isset.infohash)
      return false;
    else if (__isset.infohash && !(infohash == rhs.infohash))
      return false;
    if (__isset.download_limit != rhs.__isset.download_limit)
      return false;
    else if (__isset.download_limit && !(download_limit == rhs.download_limit))
      return false;
    if (__isset.upload_limit != rhs.__isset.upload_limit)
      return false;
    else if (__isset.upload_limit && !(upload_limit == rhs.upload_limit))
      return false;
    if (__isset.connections_limit != rhs.__isset.connections_limit)
      return false;
    else if (__isset.connections_limit && !(connections_limit == rhs.connections_limit))
      return false;
    return true;
  }
  bool operator != (const TaskOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TaskOptions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TaskOptions &a, TaskOptions &b);

}} // namespace

#endif
