/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef GroupService_TYPES_H
#define GroupService_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace bbts { namespace group {

struct ControlTaskType {
  enum type {
    UNKNOWN = 0,
    CANCEL = 1,
    PAUSE = 2,
    RESUME = 3
  };
};

extern const std::map<int, const char*> _ControlTaskType_VALUES_TO_NAMES;

class GeneralResponse;

class UserCred;

class GroupManagerOptions;

class ListenPortRange;

class TrackersPair;

class ClusterParam;

class DownloadParam;

class TaskStatus;

class TaskOptions;

typedef struct _GeneralResponse__isset {
  _GeneralResponse__isset() : ret_code(false), message(false) {}
  bool ret_code :1;
  bool message :1;
} _GeneralResponse__isset;

class GeneralResponse : public virtual ::apache::thrift::TBase {
 public:

  GeneralResponse(const GeneralResponse&);
  GeneralResponse& operator=(const GeneralResponse&);
  GeneralResponse() : ret_code(0), message() {
  }

  virtual ~GeneralResponse() throw();
  int32_t ret_code;
  std::string message;

  _GeneralResponse__isset __isset;

  void __set_ret_code(const int32_t val);

  void __set_message(const std::string& val);

  bool operator == (const GeneralResponse & rhs) const
  {
    if (!(ret_code == rhs.ret_code))
      return false;
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const GeneralResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GeneralResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GeneralResponse &a, GeneralResponse &b);

inline std::ostream& operator<<(std::ostream& out, const GeneralResponse& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _UserCred__isset {
  _UserCred__isset() : pid(false), gid(false), uid(false) {}
  bool pid :1;
  bool gid :1;
  bool uid :1;
} _UserCred__isset;

class UserCred : public virtual ::apache::thrift::TBase {
 public:

  UserCred(const UserCred&);
  UserCred& operator=(const UserCred&);
  UserCred() : pid(0), gid(0), uid(0) {
  }

  virtual ~UserCred() throw();
  int32_t pid;
  int32_t gid;
  int32_t uid;

  _UserCred__isset __isset;

  void __set_pid(const int32_t val);

  void __set_gid(const int32_t val);

  void __set_uid(const int32_t val);

  bool operator == (const UserCred & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(gid == rhs.gid))
      return false;
    if (!(uid == rhs.uid))
      return false;
    return true;
  }
  bool operator != (const UserCred &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserCred & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(UserCred &a, UserCred &b);

inline std::ostream& operator<<(std::ostream& out, const UserCred& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GroupManagerOptions__isset {
  _GroupManagerOptions__isset() : bind_port(false), upload_limit(false), download_limit(false), max_connections(false), timeout(false) {}
  bool bind_port :1;
  bool upload_limit :1;
  bool download_limit :1;
  bool max_connections :1;
  bool timeout :1;
} _GroupManagerOptions__isset;

class GroupManagerOptions : public virtual ::apache::thrift::TBase {
 public:

  GroupManagerOptions(const GroupManagerOptions&);
  GroupManagerOptions& operator=(const GroupManagerOptions&);
  GroupManagerOptions() : bind_port(0), upload_limit(0), download_limit(0), max_connections(0), timeout(0) {
  }

  virtual ~GroupManagerOptions() throw();
  int32_t bind_port;
  int32_t upload_limit;
  int32_t download_limit;
  int32_t max_connections;
  int64_t timeout;

  _GroupManagerOptions__isset __isset;

  void __set_bind_port(const int32_t val);

  void __set_upload_limit(const int32_t val);

  void __set_download_limit(const int32_t val);

  void __set_max_connections(const int32_t val);

  void __set_timeout(const int64_t val);

  bool operator == (const GroupManagerOptions & rhs) const
  {
    if (__isset.bind_port != rhs.__isset.bind_port)
      return false;
    else if (__isset.bind_port && !(bind_port == rhs.bind_port))
      return false;
    if (__isset.upload_limit != rhs.__isset.upload_limit)
      return false;
    else if (__isset.upload_limit && !(upload_limit == rhs.upload_limit))
      return false;
    if (__isset.download_limit != rhs.__isset.download_limit)
      return false;
    else if (__isset.download_limit && !(download_limit == rhs.download_limit))
      return false;
    if (__isset.max_connections != rhs.__isset.max_connections)
      return false;
    else if (__isset.max_connections && !(max_connections == rhs.max_connections))
      return false;
    if (__isset.timeout != rhs.__isset.timeout)
      return false;
    else if (__isset.timeout && !(timeout == rhs.timeout))
      return false;
    return true;
  }
  bool operator != (const GroupManagerOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GroupManagerOptions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GroupManagerOptions &a, GroupManagerOptions &b);

inline std::ostream& operator<<(std::ostream& out, const GroupManagerOptions& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ListenPortRange__isset {
  _ListenPortRange__isset() : start_port(true), end_port(true) {}
  bool start_port :1;
  bool end_port :1;
} _ListenPortRange__isset;

class ListenPortRange : public virtual ::apache::thrift::TBase {
 public:

  ListenPortRange(const ListenPortRange&);
  ListenPortRange& operator=(const ListenPortRange&);
  ListenPortRange() : start_port(18000), end_port(65534) {
  }

  virtual ~ListenPortRange() throw();
  int32_t start_port;
  int32_t end_port;

  _ListenPortRange__isset __isset;

  void __set_start_port(const int32_t val);

  void __set_end_port(const int32_t val);

  bool operator == (const ListenPortRange & rhs) const
  {
    if (!(start_port == rhs.start_port))
      return false;
    if (!(end_port == rhs.end_port))
      return false;
    return true;
  }
  bool operator != (const ListenPortRange &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ListenPortRange & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ListenPortRange &a, ListenPortRange &b);

inline std::ostream& operator<<(std::ostream& out, const ListenPortRange& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TrackersPair__isset {
  _TrackersPair__isset() : name(false), id(false) {}
  bool name :1;
  bool id :1;
} _TrackersPair__isset;

class TrackersPair : public virtual ::apache::thrift::TBase {
 public:

  TrackersPair(const TrackersPair&);
  TrackersPair& operator=(const TrackersPair&);
  TrackersPair() : name(), id(0) {
  }

  virtual ~TrackersPair() throw();
  std::string name;
  int32_t id;

  _TrackersPair__isset __isset;

  void __set_name(const std::string& val);

  void __set_id(const int32_t val);

  bool operator == (const TrackersPair & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const TrackersPair &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TrackersPair & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TrackersPair &a, TrackersPair &b);

inline std::ostream& operator<<(std::ostream& out, const TrackersPair& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ClusterParam__isset {
  _ClusterParam__isset() : host(false), port(false), user(false), passwd(false), prefix_path(false) {}
  bool host :1;
  bool port :1;
  bool user :1;
  bool passwd :1;
  bool prefix_path :1;
} _ClusterParam__isset;

class ClusterParam : public virtual ::apache::thrift::TBase {
 public:

  ClusterParam(const ClusterParam&);
  ClusterParam& operator=(const ClusterParam&);
  ClusterParam() : host(), port(0), user(), passwd(), prefix_path() {
  }

  virtual ~ClusterParam() throw();
  std::string host;
  int32_t port;
  std::string user;
  std::string passwd;
  std::string prefix_path;

  _ClusterParam__isset __isset;

  void __set_host(const std::string& val);

  void __set_port(const int32_t val);

  void __set_user(const std::string& val);

  void __set_passwd(const std::string& val);

  void __set_prefix_path(const std::string& val);

  bool operator == (const ClusterParam & rhs) const
  {
    if (!(host == rhs.host))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(passwd == rhs.passwd))
      return false;
    if (!(prefix_path == rhs.prefix_path))
      return false;
    return true;
  }
  bool operator != (const ClusterParam &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClusterParam & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ClusterParam &a, ClusterParam &b);

inline std::ostream& operator<<(std::ostream& out, const ClusterParam& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DownloadParam__isset {
  _DownloadParam__isset() : download_limit(true), upload_limit(true), connections_limit(true), seeding_time(true), timeout(true), hang_timeout(true), mem_limit(true), debug(true), print_progress(true), patition_download(true), need_save_resume(true), need_down_to_tmp_first(true), quit_by_tracker_failed(true), storage_pre_allocate(true), dynamic_allocate(true), use_dio_read(true), use_dio_write(true), ignore_hdfs_error(true), torrent_path(false), infohash(false), torrent_url(false), new_name(false), save_path(false), cluster_config(false), web_seeds(false), listen_port_range(false), include_regex(false), exclude_regex(false), control_path(false), save_torrent_path(false), cmd(false), filter(false), trackers(false), cluster_thread_num(true) {}
  bool download_limit :1;
  bool upload_limit :1;
  bool connections_limit :1;
  bool seeding_time :1;
  bool timeout :1;
  bool hang_timeout :1;
  bool mem_limit :1;
  bool debug :1;
  bool print_progress :1;
  bool patition_download :1;
  bool need_save_resume :1;
  bool need_down_to_tmp_first :1;
  bool quit_by_tracker_failed :1;
  bool storage_pre_allocate :1;
  bool dynamic_allocate :1;
  bool use_dio_read :1;
  bool use_dio_write :1;
  bool ignore_hdfs_error :1;
  bool torrent_path :1;
  bool infohash :1;
  bool torrent_url :1;
  bool new_name :1;
  bool save_path :1;
  bool cluster_config :1;
  bool web_seeds :1;
  bool listen_port_range :1;
  bool include_regex :1;
  bool exclude_regex :1;
  bool control_path :1;
  bool save_torrent_path :1;
  bool cmd :1;
  bool filter :1;
  bool trackers :1;
  bool cluster_thread_num :1;
} _DownloadParam__isset;

class DownloadParam : public virtual ::apache::thrift::TBase {
 public:

  DownloadParam(const DownloadParam&);
  DownloadParam& operator=(const DownloadParam&);
  DownloadParam() : download_limit(10485760), upload_limit(10485760), connections_limit(8000), seeding_time(-2), timeout(0), hang_timeout(0), mem_limit(0), debug(false), print_progress(false), patition_download(false), need_save_resume(false), need_down_to_tmp_first(false), quit_by_tracker_failed(false), storage_pre_allocate(false), dynamic_allocate(-1), use_dio_read(false), use_dio_write(false), ignore_hdfs_error(false), torrent_path(), infohash(), torrent_url(), new_name(), save_path(), control_path(), save_torrent_path(), cmd(), filter(), cluster_thread_num(3) {
  }

  virtual ~DownloadParam() throw();
  int32_t download_limit;
  int32_t upload_limit;
  int32_t connections_limit;
  int32_t seeding_time;
  int32_t timeout;
  int32_t hang_timeout;
  int32_t mem_limit;
  bool debug;
  bool print_progress;
  bool patition_download;
  bool need_save_resume;
  bool need_down_to_tmp_first;
  bool quit_by_tracker_failed;
  bool storage_pre_allocate;
  int32_t dynamic_allocate;
  bool use_dio_read;
  bool use_dio_write;
  bool ignore_hdfs_error;
  std::string torrent_path;
  std::string infohash;
  std::string torrent_url;
  std::string new_name;
  std::string save_path;
  ClusterParam cluster_config;
  std::vector<std::string>  web_seeds;
  ListenPortRange listen_port_range;
  std::vector<std::string>  include_regex;
  std::vector<std::string>  exclude_regex;
  std::string control_path;
  std::string save_torrent_path;
  std::string cmd;
  std::string filter;
  std::vector<TrackersPair>  trackers;
  int32_t cluster_thread_num;

  _DownloadParam__isset __isset;

  void __set_download_limit(const int32_t val);

  void __set_upload_limit(const int32_t val);

  void __set_connections_limit(const int32_t val);

  void __set_seeding_time(const int32_t val);

  void __set_timeout(const int32_t val);

  void __set_hang_timeout(const int32_t val);

  void __set_mem_limit(const int32_t val);

  void __set_debug(const bool val);

  void __set_print_progress(const bool val);

  void __set_patition_download(const bool val);

  void __set_need_save_resume(const bool val);

  void __set_need_down_to_tmp_first(const bool val);

  void __set_quit_by_tracker_failed(const bool val);

  void __set_storage_pre_allocate(const bool val);

  void __set_dynamic_allocate(const int32_t val);

  void __set_use_dio_read(const bool val);

  void __set_use_dio_write(const bool val);

  void __set_ignore_hdfs_error(const bool val);

  void __set_torrent_path(const std::string& val);

  void __set_infohash(const std::string& val);

  void __set_torrent_url(const std::string& val);

  void __set_new_name(const std::string& val);

  void __set_save_path(const std::string& val);

  void __set_cluster_config(const ClusterParam& val);

  void __set_web_seeds(const std::vector<std::string> & val);

  void __set_listen_port_range(const ListenPortRange& val);

  void __set_include_regex(const std::vector<std::string> & val);

  void __set_exclude_regex(const std::vector<std::string> & val);

  void __set_control_path(const std::string& val);

  void __set_save_torrent_path(const std::string& val);

  void __set_cmd(const std::string& val);

  void __set_filter(const std::string& val);

  void __set_trackers(const std::vector<TrackersPair> & val);

  void __set_cluster_thread_num(const int32_t val);

  bool operator == (const DownloadParam & rhs) const
  {
    if (!(download_limit == rhs.download_limit))
      return false;
    if (!(upload_limit == rhs.upload_limit))
      return false;
    if (!(connections_limit == rhs.connections_limit))
      return false;
    if (!(seeding_time == rhs.seeding_time))
      return false;
    if (!(timeout == rhs.timeout))
      return false;
    if (!(hang_timeout == rhs.hang_timeout))
      return false;
    if (!(mem_limit == rhs.mem_limit))
      return false;
    if (!(debug == rhs.debug))
      return false;
    if (!(print_progress == rhs.print_progress))
      return false;
    if (!(patition_download == rhs.patition_download))
      return false;
    if (!(need_save_resume == rhs.need_save_resume))
      return false;
    if (!(need_down_to_tmp_first == rhs.need_down_to_tmp_first))
      return false;
    if (!(quit_by_tracker_failed == rhs.quit_by_tracker_failed))
      return false;
    if (!(storage_pre_allocate == rhs.storage_pre_allocate))
      return false;
    if (!(dynamic_allocate == rhs.dynamic_allocate))
      return false;
    if (!(use_dio_read == rhs.use_dio_read))
      return false;
    if (!(use_dio_write == rhs.use_dio_write))
      return false;
    if (!(ignore_hdfs_error == rhs.ignore_hdfs_error))
      return false;
    if (!(torrent_path == rhs.torrent_path))
      return false;
    if (!(infohash == rhs.infohash))
      return false;
    if (!(torrent_url == rhs.torrent_url))
      return false;
    if (!(new_name == rhs.new_name))
      return false;
    if (!(save_path == rhs.save_path))
      return false;
    if (!(cluster_config == rhs.cluster_config))
      return false;
    if (!(web_seeds == rhs.web_seeds))
      return false;
    if (!(listen_port_range == rhs.listen_port_range))
      return false;
    if (!(include_regex == rhs.include_regex))
      return false;
    if (!(exclude_regex == rhs.exclude_regex))
      return false;
    if (!(control_path == rhs.control_path))
      return false;
    if (!(save_torrent_path == rhs.save_torrent_path))
      return false;
    if (!(cmd == rhs.cmd))
      return false;
    if (!(filter == rhs.filter))
      return false;
    if (!(trackers == rhs.trackers))
      return false;
    if (!(cluster_thread_num == rhs.cluster_thread_num))
      return false;
    return true;
  }
  bool operator != (const DownloadParam &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DownloadParam & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DownloadParam &a, DownloadParam &b);

inline std::ostream& operator<<(std::ostream& out, const DownloadParam& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TaskStatus__isset {
  _TaskStatus__isset() : hostname(false), ip(false), port(true), infohash(false), payload_downloaded(true), payload_uploaded(true), progress_ppm(true), start_time(true), end_time(true), time_for_download_metadata(true), time_for_download(true), time_for_check_files(true), time_for_seeding(true), download_limit(true), upload_limit(true), num_files(true), num_paths(true), num_symlinks(true), piece_length(true), num_pieces(true), is_hdfs_download(true), hdfs_address(false), downloaded_from_hdfs(true), state(true), progress(true), download_rate(true), upload_rate(true), is_task_finished(true), retval(true), state_string(false), uid(true), save_path(false) {}
  bool hostname :1;
  bool ip :1;
  bool port :1;
  bool infohash :1;
  bool payload_downloaded :1;
  bool payload_uploaded :1;
  bool progress_ppm :1;
  bool start_time :1;
  bool end_time :1;
  bool time_for_download_metadata :1;
  bool time_for_download :1;
  bool time_for_check_files :1;
  bool time_for_seeding :1;
  bool download_limit :1;
  bool upload_limit :1;
  bool num_files :1;
  bool num_paths :1;
  bool num_symlinks :1;
  bool piece_length :1;
  bool num_pieces :1;
  bool is_hdfs_download :1;
  bool hdfs_address :1;
  bool downloaded_from_hdfs :1;
  bool state :1;
  bool progress :1;
  bool download_rate :1;
  bool upload_rate :1;
  bool is_task_finished :1;
  bool retval :1;
  bool state_string :1;
  bool uid :1;
  bool save_path :1;
} _TaskStatus__isset;

class TaskStatus : public virtual ::apache::thrift::TBase {
 public:

  TaskStatus(const TaskStatus&);
  TaskStatus& operator=(const TaskStatus&);
  TaskStatus() : hostname(), ip(), port(0), infohash(), payload_downloaded(0LL), payload_uploaded(0LL), progress_ppm(0), start_time(0LL), end_time(0LL), time_for_download_metadata(0), time_for_download(0), time_for_check_files(0), time_for_seeding(0), download_limit(0), upload_limit(0), num_files(0), num_paths(0), num_symlinks(0), piece_length(0), num_pieces(0), is_hdfs_download(false), hdfs_address(), downloaded_from_hdfs(0LL), state(-1), progress(0), download_rate(0), upload_rate(0), is_task_finished(false), retval(0), state_string(), uid(-1), save_path() {
  }

  virtual ~TaskStatus() throw();
  std::string hostname;
  std::string ip;
  int32_t port;
  std::string infohash;
  int64_t payload_downloaded;
  int64_t payload_uploaded;
  int32_t progress_ppm;
  int64_t start_time;
  int64_t end_time;
  int32_t time_for_download_metadata;
  int32_t time_for_download;
  int32_t time_for_check_files;
  int32_t time_for_seeding;
  int32_t download_limit;
  int32_t upload_limit;
  int32_t num_files;
  int32_t num_paths;
  int32_t num_symlinks;
  int32_t piece_length;
  int32_t num_pieces;
  bool is_hdfs_download;
  std::string hdfs_address;
  int64_t downloaded_from_hdfs;
  int32_t state;
  double progress;
  int32_t download_rate;
  int32_t upload_rate;
  bool is_task_finished;
  int32_t retval;
  std::string state_string;
  int32_t uid;
  std::string save_path;

  _TaskStatus__isset __isset;

  void __set_hostname(const std::string& val);

  void __set_ip(const std::string& val);

  void __set_port(const int32_t val);

  void __set_infohash(const std::string& val);

  void __set_payload_downloaded(const int64_t val);

  void __set_payload_uploaded(const int64_t val);

  void __set_progress_ppm(const int32_t val);

  void __set_start_time(const int64_t val);

  void __set_end_time(const int64_t val);

  void __set_time_for_download_metadata(const int32_t val);

  void __set_time_for_download(const int32_t val);

  void __set_time_for_check_files(const int32_t val);

  void __set_time_for_seeding(const int32_t val);

  void __set_download_limit(const int32_t val);

  void __set_upload_limit(const int32_t val);

  void __set_num_files(const int32_t val);

  void __set_num_paths(const int32_t val);

  void __set_num_symlinks(const int32_t val);

  void __set_piece_length(const int32_t val);

  void __set_num_pieces(const int32_t val);

  void __set_is_hdfs_download(const bool val);

  void __set_hdfs_address(const std::string& val);

  void __set_downloaded_from_hdfs(const int64_t val);

  void __set_state(const int32_t val);

  void __set_progress(const double val);

  void __set_download_rate(const int32_t val);

  void __set_upload_rate(const int32_t val);

  void __set_is_task_finished(const bool val);

  void __set_retval(const int32_t val);

  void __set_state_string(const std::string& val);

  void __set_uid(const int32_t val);

  void __set_save_path(const std::string& val);

  bool operator == (const TaskStatus & rhs) const
  {
    if (!(hostname == rhs.hostname))
      return false;
    if (!(ip == rhs.ip))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(infohash == rhs.infohash))
      return false;
    if (!(payload_downloaded == rhs.payload_downloaded))
      return false;
    if (!(payload_uploaded == rhs.payload_uploaded))
      return false;
    if (!(progress_ppm == rhs.progress_ppm))
      return false;
    if (!(start_time == rhs.start_time))
      return false;
    if (!(end_time == rhs.end_time))
      return false;
    if (!(time_for_download_metadata == rhs.time_for_download_metadata))
      return false;
    if (!(time_for_download == rhs.time_for_download))
      return false;
    if (!(time_for_check_files == rhs.time_for_check_files))
      return false;
    if (!(time_for_seeding == rhs.time_for_seeding))
      return false;
    if (!(download_limit == rhs.download_limit))
      return false;
    if (!(upload_limit == rhs.upload_limit))
      return false;
    if (!(num_files == rhs.num_files))
      return false;
    if (!(num_paths == rhs.num_paths))
      return false;
    if (!(num_symlinks == rhs.num_symlinks))
      return false;
    if (!(piece_length == rhs.piece_length))
      return false;
    if (!(num_pieces == rhs.num_pieces))
      return false;
    if (!(is_hdfs_download == rhs.is_hdfs_download))
      return false;
    if (!(hdfs_address == rhs.hdfs_address))
      return false;
    if (!(downloaded_from_hdfs == rhs.downloaded_from_hdfs))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(progress == rhs.progress))
      return false;
    if (!(download_rate == rhs.download_rate))
      return false;
    if (!(upload_rate == rhs.upload_rate))
      return false;
    if (!(is_task_finished == rhs.is_task_finished))
      return false;
    if (!(retval == rhs.retval))
      return false;
    if (!(state_string == rhs.state_string))
      return false;
    if (!(uid == rhs.uid))
      return false;
    if (!(save_path == rhs.save_path))
      return false;
    return true;
  }
  bool operator != (const TaskStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TaskStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TaskStatus &a, TaskStatus &b);

inline std::ostream& operator<<(std::ostream& out, const TaskStatus& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TaskOptions__isset {
  _TaskOptions__isset() : infohash(false), download_limit(true), upload_limit(true), connections_limit(true) {}
  bool infohash :1;
  bool download_limit :1;
  bool upload_limit :1;
  bool connections_limit :1;
} _TaskOptions__isset;

class TaskOptions : public virtual ::apache::thrift::TBase {
 public:

  TaskOptions(const TaskOptions&);
  TaskOptions& operator=(const TaskOptions&);
  TaskOptions() : infohash(), download_limit(-1), upload_limit(-1), connections_limit(-1) {
  }

  virtual ~TaskOptions() throw();
  std::string infohash;
  int32_t download_limit;
  int32_t upload_limit;
  int32_t connections_limit;

  _TaskOptions__isset __isset;

  void __set_infohash(const std::string& val);

  void __set_download_limit(const int32_t val);

  void __set_upload_limit(const int32_t val);

  void __set_connections_limit(const int32_t val);

  bool operator == (const TaskOptions & rhs) const
  {
    if (__isset.infohash != rhs.__isset.infohash)
      return false;
    else if (__isset.infohash && !(infohash == rhs.infohash))
      return false;
    if (__isset.download_limit != rhs.__isset.download_limit)
      return false;
    else if (__isset.download_limit && !(download_limit == rhs.download_limit))
      return false;
    if (__isset.upload_limit != rhs.__isset.upload_limit)
      return false;
    else if (__isset.upload_limit && !(upload_limit == rhs.upload_limit))
      return false;
    if (__isset.connections_limit != rhs.__isset.connections_limit)
      return false;
    else if (__isset.connections_limit && !(connections_limit == rhs.connections_limit))
      return false;
    return true;
  }
  bool operator != (const TaskOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TaskOptions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TaskOptions &a, TaskOptions &b);

inline std::ostream& operator<<(std::ostream& out, const TaskOptions& obj)
{
  obj.printTo(out);
  return out;
}

}} // namespace

#endif
