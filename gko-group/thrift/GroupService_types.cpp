/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "GroupService_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace bbts { namespace group {

int _kControlTaskTypeValues[] = {
  ControlTaskType::UNKNOWN,
  ControlTaskType::CANCEL,
  ControlTaskType::PAUSE,
  ControlTaskType::RESUME
};
const char* _kControlTaskTypeNames[] = {
  "UNKNOWN",
  "CANCEL",
  "PAUSE",
  "RESUME"
};
const std::map<int, const char*> _ControlTaskType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kControlTaskTypeValues, _kControlTaskTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


GeneralResponse::~GeneralResponse() throw() {
}


void GeneralResponse::__set_ret_code(const int32_t val) {
  this->ret_code = val;
}

void GeneralResponse::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t GeneralResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ret_code);
          this->__isset.ret_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GeneralResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GeneralResponse");

  xfer += oprot->writeFieldBegin("ret_code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ret_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GeneralResponse &a, GeneralResponse &b) {
  using ::std::swap;
  swap(a.ret_code, b.ret_code);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

GeneralResponse::GeneralResponse(const GeneralResponse& other0) {
  ret_code = other0.ret_code;
  message = other0.message;
  __isset = other0.__isset;
}
GeneralResponse& GeneralResponse::operator=(const GeneralResponse& other1) {
  ret_code = other1.ret_code;
  message = other1.message;
  __isset = other1.__isset;
  return *this;
}
void GeneralResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GeneralResponse(";
  out << "ret_code=" << to_string(ret_code);
  out << ", " << "message=" << to_string(message);
  out << ")";
}


UserCred::~UserCred() throw() {
}


void UserCred::__set_pid(const int32_t val) {
  this->pid = val;
}

void UserCred::__set_gid(const int32_t val) {
  this->gid = val;
}

void UserCred::__set_uid(const int32_t val) {
  this->uid = val;
}

uint32_t UserCred::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pid);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->gid);
          this->__isset.gid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UserCred::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UserCred");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->pid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->gid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UserCred &a, UserCred &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.gid, b.gid);
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

UserCred::UserCred(const UserCred& other2) {
  pid = other2.pid;
  gid = other2.gid;
  uid = other2.uid;
  __isset = other2.__isset;
}
UserCred& UserCred::operator=(const UserCred& other3) {
  pid = other3.pid;
  gid = other3.gid;
  uid = other3.uid;
  __isset = other3.__isset;
  return *this;
}
void UserCred::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UserCred(";
  out << "pid=" << to_string(pid);
  out << ", " << "gid=" << to_string(gid);
  out << ", " << "uid=" << to_string(uid);
  out << ")";
}


GroupManagerOptions::~GroupManagerOptions() throw() {
}


void GroupManagerOptions::__set_bind_port(const int32_t val) {
  this->bind_port = val;
__isset.bind_port = true;
}

void GroupManagerOptions::__set_upload_limit(const int32_t val) {
  this->upload_limit = val;
__isset.upload_limit = true;
}

void GroupManagerOptions::__set_download_limit(const int32_t val) {
  this->download_limit = val;
__isset.download_limit = true;
}

void GroupManagerOptions::__set_max_connections(const int32_t val) {
  this->max_connections = val;
__isset.max_connections = true;
}

void GroupManagerOptions::__set_timeout(const int64_t val) {
  this->timeout = val;
__isset.timeout = true;
}

uint32_t GroupManagerOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bind_port);
          this->__isset.bind_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->upload_limit);
          this->__isset.upload_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->download_limit);
          this->__isset.download_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_connections);
          this->__isset.max_connections = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GroupManagerOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GroupManagerOptions");

  if (this->__isset.bind_port) {
    xfer += oprot->writeFieldBegin("bind_port", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->bind_port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upload_limit) {
    xfer += oprot->writeFieldBegin("upload_limit", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->upload_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.download_limit) {
    xfer += oprot->writeFieldBegin("download_limit", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->download_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_connections) {
    xfer += oprot->writeFieldBegin("max_connections", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->max_connections);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GroupManagerOptions &a, GroupManagerOptions &b) {
  using ::std::swap;
  swap(a.bind_port, b.bind_port);
  swap(a.upload_limit, b.upload_limit);
  swap(a.download_limit, b.download_limit);
  swap(a.max_connections, b.max_connections);
  swap(a.timeout, b.timeout);
  swap(a.__isset, b.__isset);
}

GroupManagerOptions::GroupManagerOptions(const GroupManagerOptions& other4) {
  bind_port = other4.bind_port;
  upload_limit = other4.upload_limit;
  download_limit = other4.download_limit;
  max_connections = other4.max_connections;
  timeout = other4.timeout;
  __isset = other4.__isset;
}
GroupManagerOptions& GroupManagerOptions::operator=(const GroupManagerOptions& other5) {
  bind_port = other5.bind_port;
  upload_limit = other5.upload_limit;
  download_limit = other5.download_limit;
  max_connections = other5.max_connections;
  timeout = other5.timeout;
  __isset = other5.__isset;
  return *this;
}
void GroupManagerOptions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GroupManagerOptions(";
  out << "bind_port="; (__isset.bind_port ? (out << to_string(bind_port)) : (out << "<null>"));
  out << ", " << "upload_limit="; (__isset.upload_limit ? (out << to_string(upload_limit)) : (out << "<null>"));
  out << ", " << "download_limit="; (__isset.download_limit ? (out << to_string(download_limit)) : (out << "<null>"));
  out << ", " << "max_connections="; (__isset.max_connections ? (out << to_string(max_connections)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ")";
}


ListenPortRange::~ListenPortRange() throw() {
}


void ListenPortRange::__set_start_port(const int32_t val) {
  this->start_port = val;
}

void ListenPortRange::__set_end_port(const int32_t val) {
  this->end_port = val;
}

uint32_t ListenPortRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->start_port);
          this->__isset.start_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->end_port);
          this->__isset.end_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListenPortRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListenPortRange");

  xfer += oprot->writeFieldBegin("start_port", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->start_port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->end_port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListenPortRange &a, ListenPortRange &b) {
  using ::std::swap;
  swap(a.start_port, b.start_port);
  swap(a.end_port, b.end_port);
  swap(a.__isset, b.__isset);
}

ListenPortRange::ListenPortRange(const ListenPortRange& other6) {
  start_port = other6.start_port;
  end_port = other6.end_port;
  __isset = other6.__isset;
}
ListenPortRange& ListenPortRange::operator=(const ListenPortRange& other7) {
  start_port = other7.start_port;
  end_port = other7.end_port;
  __isset = other7.__isset;
  return *this;
}
void ListenPortRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListenPortRange(";
  out << "start_port=" << to_string(start_port);
  out << ", " << "end_port=" << to_string(end_port);
  out << ")";
}


TrackersPair::~TrackersPair() throw() {
}


void TrackersPair::__set_name(const std::string& val) {
  this->name = val;
}

void TrackersPair::__set_id(const int32_t val) {
  this->id = val;
}

uint32_t TrackersPair::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TrackersPair::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TrackersPair");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TrackersPair &a, TrackersPair &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

TrackersPair::TrackersPair(const TrackersPair& other8) {
  name = other8.name;
  id = other8.id;
  __isset = other8.__isset;
}
TrackersPair& TrackersPair::operator=(const TrackersPair& other9) {
  name = other9.name;
  id = other9.id;
  __isset = other9.__isset;
  return *this;
}
void TrackersPair::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TrackersPair(";
  out << "name=" << to_string(name);
  out << ", " << "id=" << to_string(id);
  out << ")";
}


ClusterParam::~ClusterParam() throw() {
}


void ClusterParam::__set_host(const std::string& val) {
  this->host = val;
}

void ClusterParam::__set_port(const int32_t val) {
  this->port = val;
}

void ClusterParam::__set_user(const std::string& val) {
  this->user = val;
}

void ClusterParam::__set_passwd(const std::string& val) {
  this->passwd = val;
}

void ClusterParam::__set_prefix_path(const std::string& val) {
  this->prefix_path = val;
}

uint32_t ClusterParam::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->passwd);
          this->__isset.passwd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->prefix_path);
          this->__isset.prefix_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClusterParam::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ClusterParam");

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("passwd", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->passwd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prefix_path", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->prefix_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ClusterParam &a, ClusterParam &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.port, b.port);
  swap(a.user, b.user);
  swap(a.passwd, b.passwd);
  swap(a.prefix_path, b.prefix_path);
  swap(a.__isset, b.__isset);
}

ClusterParam::ClusterParam(const ClusterParam& other10) {
  host = other10.host;
  port = other10.port;
  user = other10.user;
  passwd = other10.passwd;
  prefix_path = other10.prefix_path;
  __isset = other10.__isset;
}
ClusterParam& ClusterParam::operator=(const ClusterParam& other11) {
  host = other11.host;
  port = other11.port;
  user = other11.user;
  passwd = other11.passwd;
  prefix_path = other11.prefix_path;
  __isset = other11.__isset;
  return *this;
}
void ClusterParam::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ClusterParam(";
  out << "host=" << to_string(host);
  out << ", " << "port=" << to_string(port);
  out << ", " << "user=" << to_string(user);
  out << ", " << "passwd=" << to_string(passwd);
  out << ", " << "prefix_path=" << to_string(prefix_path);
  out << ")";
}


DownloadParam::~DownloadParam() throw() {
}


void DownloadParam::__set_download_limit(const int32_t val) {
  this->download_limit = val;
}

void DownloadParam::__set_upload_limit(const int32_t val) {
  this->upload_limit = val;
}

void DownloadParam::__set_connections_limit(const int32_t val) {
  this->connections_limit = val;
}

void DownloadParam::__set_seeding_time(const int32_t val) {
  this->seeding_time = val;
}

void DownloadParam::__set_timeout(const int32_t val) {
  this->timeout = val;
}

void DownloadParam::__set_hang_timeout(const int32_t val) {
  this->hang_timeout = val;
}

void DownloadParam::__set_mem_limit(const int32_t val) {
  this->mem_limit = val;
}

void DownloadParam::__set_debug(const bool val) {
  this->debug = val;
}

void DownloadParam::__set_print_progress(const bool val) {
  this->print_progress = val;
}

void DownloadParam::__set_patition_download(const bool val) {
  this->patition_download = val;
}

void DownloadParam::__set_need_save_resume(const bool val) {
  this->need_save_resume = val;
}

void DownloadParam::__set_need_down_to_tmp_first(const bool val) {
  this->need_down_to_tmp_first = val;
}

void DownloadParam::__set_quit_by_tracker_failed(const bool val) {
  this->quit_by_tracker_failed = val;
}

void DownloadParam::__set_storage_pre_allocate(const bool val) {
  this->storage_pre_allocate = val;
}

void DownloadParam::__set_dynamic_allocate(const int32_t val) {
  this->dynamic_allocate = val;
}

void DownloadParam::__set_use_dio_read(const bool val) {
  this->use_dio_read = val;
}

void DownloadParam::__set_use_dio_write(const bool val) {
  this->use_dio_write = val;
}

void DownloadParam::__set_ignore_hdfs_error(const bool val) {
  this->ignore_hdfs_error = val;
}

void DownloadParam::__set_torrent_path(const std::string& val) {
  this->torrent_path = val;
}

void DownloadParam::__set_infohash(const std::string& val) {
  this->infohash = val;
}

void DownloadParam::__set_torrent_url(const std::string& val) {
  this->torrent_url = val;
}

void DownloadParam::__set_new_name(const std::string& val) {
  this->new_name = val;
}

void DownloadParam::__set_save_path(const std::string& val) {
  this->save_path = val;
}

void DownloadParam::__set_cluster_config(const ClusterParam& val) {
  this->cluster_config = val;
}

void DownloadParam::__set_web_seeds(const std::vector<std::string> & val) {
  this->web_seeds = val;
}

void DownloadParam::__set_listen_port_range(const ListenPortRange& val) {
  this->listen_port_range = val;
}

void DownloadParam::__set_include_regex(const std::vector<std::string> & val) {
  this->include_regex = val;
}

void DownloadParam::__set_exclude_regex(const std::vector<std::string> & val) {
  this->exclude_regex = val;
}

void DownloadParam::__set_control_path(const std::string& val) {
  this->control_path = val;
}

void DownloadParam::__set_save_torrent_path(const std::string& val) {
  this->save_torrent_path = val;
}

void DownloadParam::__set_cmd(const std::string& val) {
  this->cmd = val;
}

void DownloadParam::__set_filter(const std::string& val) {
  this->filter = val;
}

void DownloadParam::__set_trackers(const std::vector<TrackersPair> & val) {
  this->trackers = val;
}

void DownloadParam::__set_cluster_thread_num(const int32_t val) {
  this->cluster_thread_num = val;
}

uint32_t DownloadParam::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->download_limit);
          this->__isset.download_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->upload_limit);
          this->__isset.upload_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connections_limit);
          this->__isset.connections_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->seeding_time);
          this->__isset.seeding_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hang_timeout);
          this->__isset.hang_timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mem_limit);
          this->__isset.mem_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->debug);
          this->__isset.debug = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->print_progress);
          this->__isset.print_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->patition_download);
          this->__isset.patition_download = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->need_save_resume);
          this->__isset.need_save_resume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->need_down_to_tmp_first);
          this->__isset.need_down_to_tmp_first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->quit_by_tracker_failed);
          this->__isset.quit_by_tracker_failed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->storage_pre_allocate);
          this->__isset.storage_pre_allocate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dynamic_allocate);
          this->__isset.dynamic_allocate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->use_dio_read);
          this->__isset.use_dio_read = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->use_dio_write);
          this->__isset.use_dio_write = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ignore_hdfs_error);
          this->__isset.ignore_hdfs_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->torrent_path);
          this->__isset.torrent_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->infohash);
          this->__isset.infohash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->torrent_url);
          this->__isset.torrent_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->new_name);
          this->__isset.new_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->save_path);
          this->__isset.save_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cluster_config.read(iprot);
          this->__isset.cluster_config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->web_seeds.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->web_seeds.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += iprot->readString(this->web_seeds[_i16]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.web_seeds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->listen_port_range.read(iprot);
          this->__isset.listen_port_range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->include_regex.clear();
            uint32_t _size17;
            ::apache::thrift::protocol::TType _etype20;
            xfer += iprot->readListBegin(_etype20, _size17);
            this->include_regex.resize(_size17);
            uint32_t _i21;
            for (_i21 = 0; _i21 < _size17; ++_i21)
            {
              xfer += iprot->readString(this->include_regex[_i21]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.include_regex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->exclude_regex.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->exclude_regex.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += iprot->readString(this->exclude_regex[_i26]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.exclude_regex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->control_path);
          this->__isset.control_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->save_torrent_path);
          this->__isset.save_torrent_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cmd);
          this->__isset.cmd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->filter);
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->trackers.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->trackers.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += this->trackers[_i31].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.trackers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cluster_thread_num);
          this->__isset.cluster_thread_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DownloadParam::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DownloadParam");

  xfer += oprot->writeFieldBegin("download_limit", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->download_limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("upload_limit", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->upload_limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connections_limit", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->connections_limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("seeding_time", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->seeding_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->timeout);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hang_timeout", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->hang_timeout);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mem_limit", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->mem_limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("debug", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->debug);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("print_progress", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool(this->print_progress);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("patition_download", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->patition_download);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("need_save_resume", ::apache::thrift::protocol::T_BOOL, 11);
  xfer += oprot->writeBool(this->need_save_resume);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("need_down_to_tmp_first", ::apache::thrift::protocol::T_BOOL, 12);
  xfer += oprot->writeBool(this->need_down_to_tmp_first);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quit_by_tracker_failed", ::apache::thrift::protocol::T_BOOL, 13);
  xfer += oprot->writeBool(this->quit_by_tracker_failed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("storage_pre_allocate", ::apache::thrift::protocol::T_BOOL, 14);
  xfer += oprot->writeBool(this->storage_pre_allocate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dynamic_allocate", ::apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32(this->dynamic_allocate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("use_dio_read", ::apache::thrift::protocol::T_BOOL, 16);
  xfer += oprot->writeBool(this->use_dio_read);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("use_dio_write", ::apache::thrift::protocol::T_BOOL, 17);
  xfer += oprot->writeBool(this->use_dio_write);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ignore_hdfs_error", ::apache::thrift::protocol::T_BOOL, 18);
  xfer += oprot->writeBool(this->ignore_hdfs_error);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("torrent_path", ::apache::thrift::protocol::T_STRING, 19);
  xfer += oprot->writeString(this->torrent_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infohash", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->infohash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("torrent_url", ::apache::thrift::protocol::T_STRING, 21);
  xfer += oprot->writeString(this->torrent_url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("new_name", ::apache::thrift::protocol::T_STRING, 22);
  xfer += oprot->writeString(this->new_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("save_path", ::apache::thrift::protocol::T_STRING, 23);
  xfer += oprot->writeString(this->save_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cluster_config", ::apache::thrift::protocol::T_STRUCT, 24);
  xfer += this->cluster_config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("web_seeds", ::apache::thrift::protocol::T_LIST, 25);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->web_seeds.size()));
    std::vector<std::string> ::const_iterator _iter32;
    for (_iter32 = this->web_seeds.begin(); _iter32 != this->web_seeds.end(); ++_iter32)
    {
      xfer += oprot->writeString((*_iter32));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("listen_port_range", ::apache::thrift::protocol::T_STRUCT, 26);
  xfer += this->listen_port_range.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("include_regex", ::apache::thrift::protocol::T_LIST, 27);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->include_regex.size()));
    std::vector<std::string> ::const_iterator _iter33;
    for (_iter33 = this->include_regex.begin(); _iter33 != this->include_regex.end(); ++_iter33)
    {
      xfer += oprot->writeString((*_iter33));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exclude_regex", ::apache::thrift::protocol::T_LIST, 28);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->exclude_regex.size()));
    std::vector<std::string> ::const_iterator _iter34;
    for (_iter34 = this->exclude_regex.begin(); _iter34 != this->exclude_regex.end(); ++_iter34)
    {
      xfer += oprot->writeString((*_iter34));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("control_path", ::apache::thrift::protocol::T_STRING, 29);
  xfer += oprot->writeString(this->control_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("save_torrent_path", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeString(this->save_torrent_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmd", ::apache::thrift::protocol::T_STRING, 31);
  xfer += oprot->writeString(this->cmd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_STRING, 32);
  xfer += oprot->writeString(this->filter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("trackers", ::apache::thrift::protocol::T_LIST, 33);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->trackers.size()));
    std::vector<TrackersPair> ::const_iterator _iter35;
    for (_iter35 = this->trackers.begin(); _iter35 != this->trackers.end(); ++_iter35)
    {
      xfer += (*_iter35).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cluster_thread_num", ::apache::thrift::protocol::T_I32, 34);
  xfer += oprot->writeI32(this->cluster_thread_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DownloadParam &a, DownloadParam &b) {
  using ::std::swap;
  swap(a.download_limit, b.download_limit);
  swap(a.upload_limit, b.upload_limit);
  swap(a.connections_limit, b.connections_limit);
  swap(a.seeding_time, b.seeding_time);
  swap(a.timeout, b.timeout);
  swap(a.hang_timeout, b.hang_timeout);
  swap(a.mem_limit, b.mem_limit);
  swap(a.debug, b.debug);
  swap(a.print_progress, b.print_progress);
  swap(a.patition_download, b.patition_download);
  swap(a.need_save_resume, b.need_save_resume);
  swap(a.need_down_to_tmp_first, b.need_down_to_tmp_first);
  swap(a.quit_by_tracker_failed, b.quit_by_tracker_failed);
  swap(a.storage_pre_allocate, b.storage_pre_allocate);
  swap(a.dynamic_allocate, b.dynamic_allocate);
  swap(a.use_dio_read, b.use_dio_read);
  swap(a.use_dio_write, b.use_dio_write);
  swap(a.ignore_hdfs_error, b.ignore_hdfs_error);
  swap(a.torrent_path, b.torrent_path);
  swap(a.infohash, b.infohash);
  swap(a.torrent_url, b.torrent_url);
  swap(a.new_name, b.new_name);
  swap(a.save_path, b.save_path);
  swap(a.cluster_config, b.cluster_config);
  swap(a.web_seeds, b.web_seeds);
  swap(a.listen_port_range, b.listen_port_range);
  swap(a.include_regex, b.include_regex);
  swap(a.exclude_regex, b.exclude_regex);
  swap(a.control_path, b.control_path);
  swap(a.save_torrent_path, b.save_torrent_path);
  swap(a.cmd, b.cmd);
  swap(a.filter, b.filter);
  swap(a.trackers, b.trackers);
  swap(a.cluster_thread_num, b.cluster_thread_num);
  swap(a.__isset, b.__isset);
}

DownloadParam::DownloadParam(const DownloadParam& other36) {
  download_limit = other36.download_limit;
  upload_limit = other36.upload_limit;
  connections_limit = other36.connections_limit;
  seeding_time = other36.seeding_time;
  timeout = other36.timeout;
  hang_timeout = other36.hang_timeout;
  mem_limit = other36.mem_limit;
  debug = other36.debug;
  print_progress = other36.print_progress;
  patition_download = other36.patition_download;
  need_save_resume = other36.need_save_resume;
  need_down_to_tmp_first = other36.need_down_to_tmp_first;
  quit_by_tracker_failed = other36.quit_by_tracker_failed;
  storage_pre_allocate = other36.storage_pre_allocate;
  dynamic_allocate = other36.dynamic_allocate;
  use_dio_read = other36.use_dio_read;
  use_dio_write = other36.use_dio_write;
  ignore_hdfs_error = other36.ignore_hdfs_error;
  torrent_path = other36.torrent_path;
  infohash = other36.infohash;
  torrent_url = other36.torrent_url;
  new_name = other36.new_name;
  save_path = other36.save_path;
  cluster_config = other36.cluster_config;
  web_seeds = other36.web_seeds;
  listen_port_range = other36.listen_port_range;
  include_regex = other36.include_regex;
  exclude_regex = other36.exclude_regex;
  control_path = other36.control_path;
  save_torrent_path = other36.save_torrent_path;
  cmd = other36.cmd;
  filter = other36.filter;
  trackers = other36.trackers;
  cluster_thread_num = other36.cluster_thread_num;
  __isset = other36.__isset;
}
DownloadParam& DownloadParam::operator=(const DownloadParam& other37) {
  download_limit = other37.download_limit;
  upload_limit = other37.upload_limit;
  connections_limit = other37.connections_limit;
  seeding_time = other37.seeding_time;
  timeout = other37.timeout;
  hang_timeout = other37.hang_timeout;
  mem_limit = other37.mem_limit;
  debug = other37.debug;
  print_progress = other37.print_progress;
  patition_download = other37.patition_download;
  need_save_resume = other37.need_save_resume;
  need_down_to_tmp_first = other37.need_down_to_tmp_first;
  quit_by_tracker_failed = other37.quit_by_tracker_failed;
  storage_pre_allocate = other37.storage_pre_allocate;
  dynamic_allocate = other37.dynamic_allocate;
  use_dio_read = other37.use_dio_read;
  use_dio_write = other37.use_dio_write;
  ignore_hdfs_error = other37.ignore_hdfs_error;
  torrent_path = other37.torrent_path;
  infohash = other37.infohash;
  torrent_url = other37.torrent_url;
  new_name = other37.new_name;
  save_path = other37.save_path;
  cluster_config = other37.cluster_config;
  web_seeds = other37.web_seeds;
  listen_port_range = other37.listen_port_range;
  include_regex = other37.include_regex;
  exclude_regex = other37.exclude_regex;
  control_path = other37.control_path;
  save_torrent_path = other37.save_torrent_path;
  cmd = other37.cmd;
  filter = other37.filter;
  trackers = other37.trackers;
  cluster_thread_num = other37.cluster_thread_num;
  __isset = other37.__isset;
  return *this;
}
void DownloadParam::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DownloadParam(";
  out << "download_limit=" << to_string(download_limit);
  out << ", " << "upload_limit=" << to_string(upload_limit);
  out << ", " << "connections_limit=" << to_string(connections_limit);
  out << ", " << "seeding_time=" << to_string(seeding_time);
  out << ", " << "timeout=" << to_string(timeout);
  out << ", " << "hang_timeout=" << to_string(hang_timeout);
  out << ", " << "mem_limit=" << to_string(mem_limit);
  out << ", " << "debug=" << to_string(debug);
  out << ", " << "print_progress=" << to_string(print_progress);
  out << ", " << "patition_download=" << to_string(patition_download);
  out << ", " << "need_save_resume=" << to_string(need_save_resume);
  out << ", " << "need_down_to_tmp_first=" << to_string(need_down_to_tmp_first);
  out << ", " << "quit_by_tracker_failed=" << to_string(quit_by_tracker_failed);
  out << ", " << "storage_pre_allocate=" << to_string(storage_pre_allocate);
  out << ", " << "dynamic_allocate=" << to_string(dynamic_allocate);
  out << ", " << "use_dio_read=" << to_string(use_dio_read);
  out << ", " << "use_dio_write=" << to_string(use_dio_write);
  out << ", " << "ignore_hdfs_error=" << to_string(ignore_hdfs_error);
  out << ", " << "torrent_path=" << to_string(torrent_path);
  out << ", " << "infohash=" << to_string(infohash);
  out << ", " << "torrent_url=" << to_string(torrent_url);
  out << ", " << "new_name=" << to_string(new_name);
  out << ", " << "save_path=" << to_string(save_path);
  out << ", " << "cluster_config=" << to_string(cluster_config);
  out << ", " << "web_seeds=" << to_string(web_seeds);
  out << ", " << "listen_port_range=" << to_string(listen_port_range);
  out << ", " << "include_regex=" << to_string(include_regex);
  out << ", " << "exclude_regex=" << to_string(exclude_regex);
  out << ", " << "control_path=" << to_string(control_path);
  out << ", " << "save_torrent_path=" << to_string(save_torrent_path);
  out << ", " << "cmd=" << to_string(cmd);
  out << ", " << "filter=" << to_string(filter);
  out << ", " << "trackers=" << to_string(trackers);
  out << ", " << "cluster_thread_num=" << to_string(cluster_thread_num);
  out << ")";
}


TaskStatus::~TaskStatus() throw() {
}


void TaskStatus::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void TaskStatus::__set_ip(const std::string& val) {
  this->ip = val;
}

void TaskStatus::__set_port(const int32_t val) {
  this->port = val;
}

void TaskStatus::__set_infohash(const std::string& val) {
  this->infohash = val;
}

void TaskStatus::__set_payload_downloaded(const int64_t val) {
  this->payload_downloaded = val;
}

void TaskStatus::__set_payload_uploaded(const int64_t val) {
  this->payload_uploaded = val;
}

void TaskStatus::__set_progress_ppm(const int32_t val) {
  this->progress_ppm = val;
}

void TaskStatus::__set_start_time(const int64_t val) {
  this->start_time = val;
}

void TaskStatus::__set_end_time(const int64_t val) {
  this->end_time = val;
}

void TaskStatus::__set_time_for_download_metadata(const int32_t val) {
  this->time_for_download_metadata = val;
}

void TaskStatus::__set_time_for_download(const int32_t val) {
  this->time_for_download = val;
}

void TaskStatus::__set_time_for_check_files(const int32_t val) {
  this->time_for_check_files = val;
}

void TaskStatus::__set_time_for_seeding(const int32_t val) {
  this->time_for_seeding = val;
}

void TaskStatus::__set_download_limit(const int32_t val) {
  this->download_limit = val;
}

void TaskStatus::__set_upload_limit(const int32_t val) {
  this->upload_limit = val;
}

void TaskStatus::__set_num_files(const int32_t val) {
  this->num_files = val;
}

void TaskStatus::__set_num_paths(const int32_t val) {
  this->num_paths = val;
}

void TaskStatus::__set_num_symlinks(const int32_t val) {
  this->num_symlinks = val;
}

void TaskStatus::__set_piece_length(const int32_t val) {
  this->piece_length = val;
}

void TaskStatus::__set_num_pieces(const int32_t val) {
  this->num_pieces = val;
}

void TaskStatus::__set_is_hdfs_download(const bool val) {
  this->is_hdfs_download = val;
}

void TaskStatus::__set_hdfs_address(const std::string& val) {
  this->hdfs_address = val;
}

void TaskStatus::__set_downloaded_from_hdfs(const int64_t val) {
  this->downloaded_from_hdfs = val;
}

void TaskStatus::__set_state(const int32_t val) {
  this->state = val;
}

void TaskStatus::__set_progress(const double val) {
  this->progress = val;
}

void TaskStatus::__set_download_rate(const int32_t val) {
  this->download_rate = val;
}

void TaskStatus::__set_upload_rate(const int32_t val) {
  this->upload_rate = val;
}

void TaskStatus::__set_is_task_finished(const bool val) {
  this->is_task_finished = val;
}

void TaskStatus::__set_retval(const int32_t val) {
  this->retval = val;
}

void TaskStatus::__set_state_string(const std::string& val) {
  this->state_string = val;
}

void TaskStatus::__set_uid(const int32_t val) {
  this->uid = val;
}

void TaskStatus::__set_save_path(const std::string& val) {
  this->save_path = val;
}

uint32_t TaskStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          this->__isset.hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->infohash);
          this->__isset.infohash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->payload_downloaded);
          this->__isset.payload_downloaded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->payload_uploaded);
          this->__isset.payload_uploaded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->progress_ppm);
          this->__isset.progress_ppm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_time);
          this->__isset.start_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->end_time);
          this->__isset.end_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->time_for_download_metadata);
          this->__isset.time_for_download_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->time_for_download);
          this->__isset.time_for_download = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->time_for_check_files);
          this->__isset.time_for_check_files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->time_for_seeding);
          this->__isset.time_for_seeding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->download_limit);
          this->__isset.download_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->upload_limit);
          this->__isset.upload_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_files);
          this->__isset.num_files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_paths);
          this->__isset.num_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_symlinks);
          this->__isset.num_symlinks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->piece_length);
          this->__isset.piece_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_pieces);
          this->__isset.num_pieces = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_hdfs_download);
          this->__isset.is_hdfs_download = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hdfs_address);
          this->__isset.hdfs_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->downloaded_from_hdfs);
          this->__isset.downloaded_from_hdfs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->progress);
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->download_rate);
          this->__isset.download_rate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->upload_rate);
          this->__isset.upload_rate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_task_finished);
          this->__isset.is_task_finished = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->retval);
          this->__isset.retval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state_string);
          this->__isset.state_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->save_path);
          this->__isset.save_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TaskStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TaskStatus");

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infohash", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->infohash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("payload_downloaded", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->payload_downloaded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("payload_uploaded", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->payload_uploaded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("progress_ppm", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->progress_ppm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_time", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->start_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_time", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->end_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_for_download_metadata", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->time_for_download_metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_for_download", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->time_for_download);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_for_check_files", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->time_for_check_files);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_for_seeding", ::apache::thrift::protocol::T_I32, 13);
  xfer += oprot->writeI32(this->time_for_seeding);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("download_limit", ::apache::thrift::protocol::T_I32, 14);
  xfer += oprot->writeI32(this->download_limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("upload_limit", ::apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32(this->upload_limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_files", ::apache::thrift::protocol::T_I32, 16);
  xfer += oprot->writeI32(this->num_files);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_paths", ::apache::thrift::protocol::T_I32, 17);
  xfer += oprot->writeI32(this->num_paths);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_symlinks", ::apache::thrift::protocol::T_I32, 18);
  xfer += oprot->writeI32(this->num_symlinks);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("piece_length", ::apache::thrift::protocol::T_I32, 19);
  xfer += oprot->writeI32(this->piece_length);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_pieces", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->num_pieces);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_hdfs_download", ::apache::thrift::protocol::T_BOOL, 21);
  xfer += oprot->writeBool(this->is_hdfs_download);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hdfs_address", ::apache::thrift::protocol::T_STRING, 22);
  xfer += oprot->writeString(this->hdfs_address);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("downloaded_from_hdfs", ::apache::thrift::protocol::T_I64, 23);
  xfer += oprot->writeI64(this->downloaded_from_hdfs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 24);
  xfer += oprot->writeI32(this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_DOUBLE, 25);
  xfer += oprot->writeDouble(this->progress);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("download_rate", ::apache::thrift::protocol::T_I32, 26);
  xfer += oprot->writeI32(this->download_rate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("upload_rate", ::apache::thrift::protocol::T_I32, 27);
  xfer += oprot->writeI32(this->upload_rate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_task_finished", ::apache::thrift::protocol::T_BOOL, 28);
  xfer += oprot->writeBool(this->is_task_finished);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("retval", ::apache::thrift::protocol::T_I32, 29);
  xfer += oprot->writeI32(this->retval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state_string", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeString(this->state_string);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I32, 31);
  xfer += oprot->writeI32(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("save_path", ::apache::thrift::protocol::T_STRING, 32);
  xfer += oprot->writeString(this->save_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TaskStatus &a, TaskStatus &b) {
  using ::std::swap;
  swap(a.hostname, b.hostname);
  swap(a.ip, b.ip);
  swap(a.port, b.port);
  swap(a.infohash, b.infohash);
  swap(a.payload_downloaded, b.payload_downloaded);
  swap(a.payload_uploaded, b.payload_uploaded);
  swap(a.progress_ppm, b.progress_ppm);
  swap(a.start_time, b.start_time);
  swap(a.end_time, b.end_time);
  swap(a.time_for_download_metadata, b.time_for_download_metadata);
  swap(a.time_for_download, b.time_for_download);
  swap(a.time_for_check_files, b.time_for_check_files);
  swap(a.time_for_seeding, b.time_for_seeding);
  swap(a.download_limit, b.download_limit);
  swap(a.upload_limit, b.upload_limit);
  swap(a.num_files, b.num_files);
  swap(a.num_paths, b.num_paths);
  swap(a.num_symlinks, b.num_symlinks);
  swap(a.piece_length, b.piece_length);
  swap(a.num_pieces, b.num_pieces);
  swap(a.is_hdfs_download, b.is_hdfs_download);
  swap(a.hdfs_address, b.hdfs_address);
  swap(a.downloaded_from_hdfs, b.downloaded_from_hdfs);
  swap(a.state, b.state);
  swap(a.progress, b.progress);
  swap(a.download_rate, b.download_rate);
  swap(a.upload_rate, b.upload_rate);
  swap(a.is_task_finished, b.is_task_finished);
  swap(a.retval, b.retval);
  swap(a.state_string, b.state_string);
  swap(a.uid, b.uid);
  swap(a.save_path, b.save_path);
  swap(a.__isset, b.__isset);
}

TaskStatus::TaskStatus(const TaskStatus& other38) {
  hostname = other38.hostname;
  ip = other38.ip;
  port = other38.port;
  infohash = other38.infohash;
  payload_downloaded = other38.payload_downloaded;
  payload_uploaded = other38.payload_uploaded;
  progress_ppm = other38.progress_ppm;
  start_time = other38.start_time;
  end_time = other38.end_time;
  time_for_download_metadata = other38.time_for_download_metadata;
  time_for_download = other38.time_for_download;
  time_for_check_files = other38.time_for_check_files;
  time_for_seeding = other38.time_for_seeding;
  download_limit = other38.download_limit;
  upload_limit = other38.upload_limit;
  num_files = other38.num_files;
  num_paths = other38.num_paths;
  num_symlinks = other38.num_symlinks;
  piece_length = other38.piece_length;
  num_pieces = other38.num_pieces;
  is_hdfs_download = other38.is_hdfs_download;
  hdfs_address = other38.hdfs_address;
  downloaded_from_hdfs = other38.downloaded_from_hdfs;
  state = other38.state;
  progress = other38.progress;
  download_rate = other38.download_rate;
  upload_rate = other38.upload_rate;
  is_task_finished = other38.is_task_finished;
  retval = other38.retval;
  state_string = other38.state_string;
  uid = other38.uid;
  save_path = other38.save_path;
  __isset = other38.__isset;
}
TaskStatus& TaskStatus::operator=(const TaskStatus& other39) {
  hostname = other39.hostname;
  ip = other39.ip;
  port = other39.port;
  infohash = other39.infohash;
  payload_downloaded = other39.payload_downloaded;
  payload_uploaded = other39.payload_uploaded;
  progress_ppm = other39.progress_ppm;
  start_time = other39.start_time;
  end_time = other39.end_time;
  time_for_download_metadata = other39.time_for_download_metadata;
  time_for_download = other39.time_for_download;
  time_for_check_files = other39.time_for_check_files;
  time_for_seeding = other39.time_for_seeding;
  download_limit = other39.download_limit;
  upload_limit = other39.upload_limit;
  num_files = other39.num_files;
  num_paths = other39.num_paths;
  num_symlinks = other39.num_symlinks;
  piece_length = other39.piece_length;
  num_pieces = other39.num_pieces;
  is_hdfs_download = other39.is_hdfs_download;
  hdfs_address = other39.hdfs_address;
  downloaded_from_hdfs = other39.downloaded_from_hdfs;
  state = other39.state;
  progress = other39.progress;
  download_rate = other39.download_rate;
  upload_rate = other39.upload_rate;
  is_task_finished = other39.is_task_finished;
  retval = other39.retval;
  state_string = other39.state_string;
  uid = other39.uid;
  save_path = other39.save_path;
  __isset = other39.__isset;
  return *this;
}
void TaskStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TaskStatus(";
  out << "hostname=" << to_string(hostname);
  out << ", " << "ip=" << to_string(ip);
  out << ", " << "port=" << to_string(port);
  out << ", " << "infohash=" << to_string(infohash);
  out << ", " << "payload_downloaded=" << to_string(payload_downloaded);
  out << ", " << "payload_uploaded=" << to_string(payload_uploaded);
  out << ", " << "progress_ppm=" << to_string(progress_ppm);
  out << ", " << "start_time=" << to_string(start_time);
  out << ", " << "end_time=" << to_string(end_time);
  out << ", " << "time_for_download_metadata=" << to_string(time_for_download_metadata);
  out << ", " << "time_for_download=" << to_string(time_for_download);
  out << ", " << "time_for_check_files=" << to_string(time_for_check_files);
  out << ", " << "time_for_seeding=" << to_string(time_for_seeding);
  out << ", " << "download_limit=" << to_string(download_limit);
  out << ", " << "upload_limit=" << to_string(upload_limit);
  out << ", " << "num_files=" << to_string(num_files);
  out << ", " << "num_paths=" << to_string(num_paths);
  out << ", " << "num_symlinks=" << to_string(num_symlinks);
  out << ", " << "piece_length=" << to_string(piece_length);
  out << ", " << "num_pieces=" << to_string(num_pieces);
  out << ", " << "is_hdfs_download=" << to_string(is_hdfs_download);
  out << ", " << "hdfs_address=" << to_string(hdfs_address);
  out << ", " << "downloaded_from_hdfs=" << to_string(downloaded_from_hdfs);
  out << ", " << "state=" << to_string(state);
  out << ", " << "progress=" << to_string(progress);
  out << ", " << "download_rate=" << to_string(download_rate);
  out << ", " << "upload_rate=" << to_string(upload_rate);
  out << ", " << "is_task_finished=" << to_string(is_task_finished);
  out << ", " << "retval=" << to_string(retval);
  out << ", " << "state_string=" << to_string(state_string);
  out << ", " << "uid=" << to_string(uid);
  out << ", " << "save_path=" << to_string(save_path);
  out << ")";
}


TaskOptions::~TaskOptions() throw() {
}


void TaskOptions::__set_infohash(const std::string& val) {
  this->infohash = val;
__isset.infohash = true;
}

void TaskOptions::__set_download_limit(const int32_t val) {
  this->download_limit = val;
__isset.download_limit = true;
}

void TaskOptions::__set_upload_limit(const int32_t val) {
  this->upload_limit = val;
__isset.upload_limit = true;
}

void TaskOptions::__set_connections_limit(const int32_t val) {
  this->connections_limit = val;
__isset.connections_limit = true;
}

uint32_t TaskOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->infohash);
          this->__isset.infohash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->download_limit);
          this->__isset.download_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->upload_limit);
          this->__isset.upload_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connections_limit);
          this->__isset.connections_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TaskOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TaskOptions");

  if (this->__isset.infohash) {
    xfer += oprot->writeFieldBegin("infohash", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->infohash);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.download_limit) {
    xfer += oprot->writeFieldBegin("download_limit", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->download_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upload_limit) {
    xfer += oprot->writeFieldBegin("upload_limit", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->upload_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connections_limit) {
    xfer += oprot->writeFieldBegin("connections_limit", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->connections_limit);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TaskOptions &a, TaskOptions &b) {
  using ::std::swap;
  swap(a.infohash, b.infohash);
  swap(a.download_limit, b.download_limit);
  swap(a.upload_limit, b.upload_limit);
  swap(a.connections_limit, b.connections_limit);
  swap(a.__isset, b.__isset);
}

TaskOptions::TaskOptions(const TaskOptions& other40) {
  infohash = other40.infohash;
  download_limit = other40.download_limit;
  upload_limit = other40.upload_limit;
  connections_limit = other40.connections_limit;
  __isset = other40.__isset;
}
TaskOptions& TaskOptions::operator=(const TaskOptions& other41) {
  infohash = other41.infohash;
  download_limit = other41.download_limit;
  upload_limit = other41.upload_limit;
  connections_limit = other41.connections_limit;
  __isset = other41.__isset;
  return *this;
}
void TaskOptions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TaskOptions(";
  out << "infohash="; (__isset.infohash ? (out << to_string(infohash)) : (out << "<null>"));
  out << ", " << "download_limit="; (__isset.download_limit ? (out << to_string(download_limit)) : (out << "<null>"));
  out << ", " << "upload_limit="; (__isset.upload_limit ? (out << to_string(upload_limit)) : (out << "<null>"));
  out << ", " << "connections_limit="; (__isset.connections_limit ? (out << to_string(connections_limit)) : (out << "<null>"));
  out << ")";
}

}} // namespace
