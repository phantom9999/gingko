// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: configure.proto

#ifndef PROTOBUF_configure_2eproto__INCLUDED
#define PROTOBUF_configure_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace bbts {
namespace message {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_configure_2eproto();
void protobuf_AssignDesc_configure_2eproto();
void protobuf_ShutdownFile_configure_2eproto();

class DownloadConfigure;
class AgentConfigure;

// ===================================================================

class DownloadConfigure : public ::google::protobuf::Message {
 public:
  DownloadConfigure();
  virtual ~DownloadConfigure();
  
  DownloadConfigure(const DownloadConfigure& from);
  
  inline DownloadConfigure& operator=(const DownloadConfigure& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DownloadConfigure& default_instance();
  
  void Swap(DownloadConfigure* other);
  
  // implements Message ----------------------------------------------
  
  DownloadConfigure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DownloadConfigure& from);
  void MergeFrom(const DownloadConfigure& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 download_timeout = 1;
  inline bool has_download_timeout() const;
  inline void clear_download_timeout();
  static const int kDownloadTimeoutFieldNumber = 1;
  inline ::google::protobuf::int32 download_timeout() const;
  inline void set_download_timeout(::google::protobuf::int32 value);
  
  // optional int32 max_announce_interval = 2;
  inline bool has_max_announce_interval() const;
  inline void clear_max_announce_interval();
  static const int kMaxAnnounceIntervalFieldNumber = 2;
  inline ::google::protobuf::int32 max_announce_interval() const;
  inline void set_max_announce_interval(::google::protobuf::int32 value);
  
  // optional int32 cluster_thread_num = 3;
  inline bool has_cluster_thread_num() const;
  inline void clear_cluster_thread_num();
  static const int kClusterThreadNumFieldNumber = 3;
  inline ::google::protobuf::int32 cluster_thread_num() const;
  inline void set_cluster_thread_num(::google::protobuf::int32 value);
  
  // optional string java_home = 4;
  inline bool has_java_home() const;
  inline void clear_java_home();
  static const int kJavaHomeFieldNumber = 4;
  inline const ::std::string& java_home() const;
  inline void set_java_home(const ::std::string& value);
  inline void set_java_home(const char* value);
  inline void set_java_home(const char* value, size_t size);
  inline ::std::string* mutable_java_home();
  inline ::std::string* release_java_home();
  
  // optional string class_path = 5;
  inline bool has_class_path() const;
  inline void clear_class_path();
  static const int kClassPathFieldNumber = 5;
  inline const ::std::string& class_path() const;
  inline void set_class_path(const ::std::string& value);
  inline void set_class_path(const char* value);
  inline void set_class_path(const char* value, size_t size);
  inline ::std::string* mutable_class_path();
  inline ::std::string* release_class_path();
  
  // optional string socket_file = 6;
  inline bool has_socket_file() const;
  inline void clear_socket_file();
  static const int kSocketFileFieldNumber = 6;
  inline const ::std::string& socket_file() const;
  inline void set_socket_file(const ::std::string& value);
  inline void set_socket_file(const char* value);
  inline void set_socket_file(const char* value, size_t size);
  inline ::std::string* mutable_socket_file();
  inline ::std::string* release_socket_file();
  
  // optional string task_stat_file = 7;
  inline bool has_task_stat_file() const;
  inline void clear_task_stat_file();
  static const int kTaskStatFileFieldNumber = 7;
  inline const ::std::string& task_stat_file() const;
  inline void set_task_stat_file(const ::std::string& value);
  inline void set_task_stat_file(const char* value);
  inline void set_task_stat_file(const char* value, size_t size);
  inline ::std::string* mutable_task_stat_file();
  inline ::std::string* release_task_stat_file();
  
  // optional string peer_stat_file = 8;
  inline bool has_peer_stat_file() const;
  inline void clear_peer_stat_file();
  static const int kPeerStatFileFieldNumber = 8;
  inline const ::std::string& peer_stat_file() const;
  inline void set_peer_stat_file(const ::std::string& value);
  inline void set_peer_stat_file(const char* value);
  inline void set_peer_stat_file(const char* value, size_t size);
  inline ::std::string* mutable_peer_stat_file();
  inline ::std::string* release_peer_stat_file();
  
  // optional string download_log_file = 9;
  inline bool has_download_log_file() const;
  inline void clear_download_log_file();
  static const int kDownloadLogFileFieldNumber = 9;
  inline const ::std::string& download_log_file() const;
  inline void set_download_log_file(const ::std::string& value);
  inline void set_download_log_file(const char* value);
  inline void set_download_log_file(const char* value, size_t size);
  inline ::std::string* mutable_download_log_file();
  inline ::std::string* release_download_log_file();
  
  // optional string tracker_conf_file = 10;
  inline bool has_tracker_conf_file() const;
  inline void clear_tracker_conf_file();
  static const int kTrackerConfFileFieldNumber = 10;
  inline const ::std::string& tracker_conf_file() const;
  inline void set_tracker_conf_file(const ::std::string& value);
  inline void set_tracker_conf_file(const char* value);
  inline void set_tracker_conf_file(const char* value, size_t size);
  inline ::std::string* mutable_tracker_conf_file();
  inline ::std::string* release_tracker_conf_file();
  
  // optional int32 upload_limit = 51;
  inline bool has_upload_limit() const;
  inline void clear_upload_limit();
  static const int kUploadLimitFieldNumber = 51;
  inline ::google::protobuf::int32 upload_limit() const;
  inline void set_upload_limit(::google::protobuf::int32 value);
  
  // optional int32 download_limit = 52;
  inline bool has_download_limit() const;
  inline void clear_download_limit();
  static const int kDownloadLimitFieldNumber = 52;
  inline ::google::protobuf::int32 download_limit() const;
  inline void set_download_limit(::google::protobuf::int32 value);
  
  // optional int32 connection_limit = 53;
  inline bool has_connection_limit() const;
  inline void clear_connection_limit();
  static const int kConnectionLimitFieldNumber = 53;
  inline ::google::protobuf::int32 connection_limit() const;
  inline void set_connection_limit(::google::protobuf::int32 value);
  
  // optional int32 peers_num_want = 54;
  inline bool has_peers_num_want() const;
  inline void clear_peers_num_want();
  static const int kPeersNumWantFieldNumber = 54;
  inline ::google::protobuf::int32 peers_num_want() const;
  inline void set_peers_num_want(::google::protobuf::int32 value);
  
  // optional int32 cache_size = 56;
  inline bool has_cache_size() const;
  inline void clear_cache_size();
  static const int kCacheSizeFieldNumber = 56;
  inline ::google::protobuf::int32 cache_size() const;
  inline void set_cache_size(::google::protobuf::int32 value);
  
  // optional int32 cache_expiry = 57;
  inline bool has_cache_expiry() const;
  inline void clear_cache_expiry();
  static const int kCacheExpiryFieldNumber = 57;
  inline ::google::protobuf::int32 cache_expiry() const;
  inline void set_cache_expiry(::google::protobuf::int32 value);
  
  // optional int32 file_pool_size = 58;
  inline bool has_file_pool_size() const;
  inline void clear_file_pool_size();
  static const int kFilePoolSizeFieldNumber = 58;
  inline ::google::protobuf::int32 file_pool_size() const;
  inline void set_file_pool_size(::google::protobuf::int32 value);
  
  // optional int32 max_metadata_size = 59;
  inline bool has_max_metadata_size() const;
  inline void clear_max_metadata_size();
  static const int kMaxMetadataSizeFieldNumber = 59;
  inline ::google::protobuf::int32 max_metadata_size() const;
  inline void set_max_metadata_size(::google::protobuf::int32 value);
  
  // optional int32 seeding_announce_interval = 60;
  inline bool has_seeding_announce_interval() const;
  inline void clear_seeding_announce_interval();
  static const int kSeedingAnnounceIntervalFieldNumber = 60;
  inline ::google::protobuf::int32 seeding_announce_interval() const;
  inline void set_seeding_announce_interval(::google::protobuf::int32 value);
  
  // optional int32 min_reconnect_time = 61;
  inline bool has_min_reconnect_time() const;
  inline void clear_min_reconnect_time();
  static const int kMinReconnectTimeFieldNumber = 61;
  inline ::google::protobuf::int32 min_reconnect_time() const;
  inline void set_min_reconnect_time(::google::protobuf::int32 value);
  
  // optional int32 peer_connect_timeout = 62;
  inline bool has_peer_connect_timeout() const;
  inline void clear_peer_connect_timeout();
  static const int kPeerConnectTimeoutFieldNumber = 62;
  inline ::google::protobuf::int32 peer_connect_timeout() const;
  inline void set_peer_connect_timeout(::google::protobuf::int32 value);
  
  // optional int32 read_cache_line_size = 63;
  inline bool has_read_cache_line_size() const;
  inline void clear_read_cache_line_size();
  static const int kReadCacheLineSizeFieldNumber = 63;
  inline ::google::protobuf::int32 read_cache_line_size() const;
  inline void set_read_cache_line_size(::google::protobuf::int32 value);
  
  // optional int32 write_cache_line_size = 64;
  inline bool has_write_cache_line_size() const;
  inline void clear_write_cache_line_size();
  static const int kWriteCacheLineSizeFieldNumber = 64;
  inline ::google::protobuf::int32 write_cache_line_size() const;
  inline void set_write_cache_line_size(::google::protobuf::int32 value);
  
  // optional bool lock_disk_cache = 65;
  inline bool has_lock_disk_cache() const;
  inline void clear_lock_disk_cache();
  static const int kLockDiskCacheFieldNumber = 65;
  inline bool lock_disk_cache() const;
  inline void set_lock_disk_cache(bool value);
  
  // optional bool suggest_mode = 66;
  inline bool has_suggest_mode() const;
  inline void clear_suggest_mode();
  static const int kSuggestModeFieldNumber = 66;
  inline bool suggest_mode() const;
  inline void set_suggest_mode(bool value);
  
  // optional int32 max_queued_disk_bytes = 67;
  inline bool has_max_queued_disk_bytes() const;
  inline void clear_max_queued_disk_bytes();
  static const int kMaxQueuedDiskBytesFieldNumber = 67;
  inline ::google::protobuf::int32 max_queued_disk_bytes() const;
  inline void set_max_queued_disk_bytes(::google::protobuf::int32 value);
  
  // optional int32 max_out_request_queue = 68;
  inline bool has_max_out_request_queue() const;
  inline void clear_max_out_request_queue();
  static const int kMaxOutRequestQueueFieldNumber = 68;
  inline ::google::protobuf::int32 max_out_request_queue() const;
  inline void set_max_out_request_queue(::google::protobuf::int32 value);
  
  // optional int32 max_allowed_in_request_queue = 69;
  inline bool has_max_allowed_in_request_queue() const;
  inline void clear_max_allowed_in_request_queue();
  static const int kMaxAllowedInRequestQueueFieldNumber = 69;
  inline ::google::protobuf::int32 max_allowed_in_request_queue() const;
  inline void set_max_allowed_in_request_queue(::google::protobuf::int32 value);
  
  // optional int32 whole_pieces_threshold = 70;
  inline bool has_whole_pieces_threshold() const;
  inline void clear_whole_pieces_threshold();
  static const int kWholePiecesThresholdFieldNumber = 70;
  inline ::google::protobuf::int32 whole_pieces_threshold() const;
  inline void set_whole_pieces_threshold(::google::protobuf::int32 value);
  
  // optional int32 request_queue_time = 71;
  inline bool has_request_queue_time() const;
  inline void clear_request_queue_time();
  static const int kRequestQueueTimeFieldNumber = 71;
  inline ::google::protobuf::int32 request_queue_time() const;
  inline void set_request_queue_time(::google::protobuf::int32 value);
  
  // optional int32 send_buffer_low_watermark = 72;
  inline bool has_send_buffer_low_watermark() const;
  inline void clear_send_buffer_low_watermark();
  static const int kSendBufferLowWatermarkFieldNumber = 72;
  inline ::google::protobuf::int32 send_buffer_low_watermark() const;
  inline void set_send_buffer_low_watermark(::google::protobuf::int32 value);
  
  // optional int32 send_buffer_watermark = 73;
  inline bool has_send_buffer_watermark() const;
  inline void clear_send_buffer_watermark();
  static const int kSendBufferWatermarkFieldNumber = 73;
  inline ::google::protobuf::int32 send_buffer_watermark() const;
  inline void set_send_buffer_watermark(::google::protobuf::int32 value);
  
  // optional int32 send_socket_buffer_size = 74;
  inline bool has_send_socket_buffer_size() const;
  inline void clear_send_socket_buffer_size();
  static const int kSendSocketBufferSizeFieldNumber = 74;
  inline ::google::protobuf::int32 send_socket_buffer_size() const;
  inline void set_send_socket_buffer_size(::google::protobuf::int32 value);
  
  // optional int32 recv_socket_buffer_size = 75;
  inline bool has_recv_socket_buffer_size() const;
  inline void clear_recv_socket_buffer_size();
  static const int kRecvSocketBufferSizeFieldNumber = 75;
  inline ::google::protobuf::int32 recv_socket_buffer_size() const;
  inline void set_recv_socket_buffer_size(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:bbts.message.DownloadConfigure)
 private:
  inline void set_has_download_timeout();
  inline void clear_has_download_timeout();
  inline void set_has_max_announce_interval();
  inline void clear_has_max_announce_interval();
  inline void set_has_cluster_thread_num();
  inline void clear_has_cluster_thread_num();
  inline void set_has_java_home();
  inline void clear_has_java_home();
  inline void set_has_class_path();
  inline void clear_has_class_path();
  inline void set_has_socket_file();
  inline void clear_has_socket_file();
  inline void set_has_task_stat_file();
  inline void clear_has_task_stat_file();
  inline void set_has_peer_stat_file();
  inline void clear_has_peer_stat_file();
  inline void set_has_download_log_file();
  inline void clear_has_download_log_file();
  inline void set_has_tracker_conf_file();
  inline void clear_has_tracker_conf_file();
  inline void set_has_upload_limit();
  inline void clear_has_upload_limit();
  inline void set_has_download_limit();
  inline void clear_has_download_limit();
  inline void set_has_connection_limit();
  inline void clear_has_connection_limit();
  inline void set_has_peers_num_want();
  inline void clear_has_peers_num_want();
  inline void set_has_cache_size();
  inline void clear_has_cache_size();
  inline void set_has_cache_expiry();
  inline void clear_has_cache_expiry();
  inline void set_has_file_pool_size();
  inline void clear_has_file_pool_size();
  inline void set_has_max_metadata_size();
  inline void clear_has_max_metadata_size();
  inline void set_has_seeding_announce_interval();
  inline void clear_has_seeding_announce_interval();
  inline void set_has_min_reconnect_time();
  inline void clear_has_min_reconnect_time();
  inline void set_has_peer_connect_timeout();
  inline void clear_has_peer_connect_timeout();
  inline void set_has_read_cache_line_size();
  inline void clear_has_read_cache_line_size();
  inline void set_has_write_cache_line_size();
  inline void clear_has_write_cache_line_size();
  inline void set_has_lock_disk_cache();
  inline void clear_has_lock_disk_cache();
  inline void set_has_suggest_mode();
  inline void clear_has_suggest_mode();
  inline void set_has_max_queued_disk_bytes();
  inline void clear_has_max_queued_disk_bytes();
  inline void set_has_max_out_request_queue();
  inline void clear_has_max_out_request_queue();
  inline void set_has_max_allowed_in_request_queue();
  inline void clear_has_max_allowed_in_request_queue();
  inline void set_has_whole_pieces_threshold();
  inline void clear_has_whole_pieces_threshold();
  inline void set_has_request_queue_time();
  inline void clear_has_request_queue_time();
  inline void set_has_send_buffer_low_watermark();
  inline void clear_has_send_buffer_low_watermark();
  inline void set_has_send_buffer_watermark();
  inline void clear_has_send_buffer_watermark();
  inline void set_has_send_socket_buffer_size();
  inline void clear_has_send_socket_buffer_size();
  inline void set_has_recv_socket_buffer_size();
  inline void clear_has_recv_socket_buffer_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 download_timeout_;
  ::google::protobuf::int32 max_announce_interval_;
  ::std::string* java_home_;
  ::std::string* class_path_;
  ::std::string* socket_file_;
  ::std::string* task_stat_file_;
  ::google::protobuf::int32 cluster_thread_num_;
  ::google::protobuf::int32 upload_limit_;
  ::std::string* peer_stat_file_;
  ::std::string* download_log_file_;
  ::std::string* tracker_conf_file_;
  ::google::protobuf::int32 download_limit_;
  ::google::protobuf::int32 connection_limit_;
  ::google::protobuf::int32 peers_num_want_;
  ::google::protobuf::int32 cache_size_;
  ::google::protobuf::int32 cache_expiry_;
  ::google::protobuf::int32 file_pool_size_;
  ::google::protobuf::int32 max_metadata_size_;
  ::google::protobuf::int32 seeding_announce_interval_;
  ::google::protobuf::int32 min_reconnect_time_;
  ::google::protobuf::int32 peer_connect_timeout_;
  ::google::protobuf::int32 read_cache_line_size_;
  ::google::protobuf::int32 write_cache_line_size_;
  bool lock_disk_cache_;
  bool suggest_mode_;
  ::google::protobuf::int32 max_queued_disk_bytes_;
  ::google::protobuf::int32 max_out_request_queue_;
  ::google::protobuf::int32 max_allowed_in_request_queue_;
  ::google::protobuf::int32 whole_pieces_threshold_;
  ::google::protobuf::int32 request_queue_time_;
  ::google::protobuf::int32 send_buffer_low_watermark_;
  ::google::protobuf::int32 send_buffer_watermark_;
  ::google::protobuf::int32 send_socket_buffer_size_;
  ::google::protobuf::int32 recv_socket_buffer_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(34 + 31) / 32];
  
  friend void  protobuf_AddDesc_configure_2eproto();
  friend void protobuf_AssignDesc_configure_2eproto();
  friend void protobuf_ShutdownFile_configure_2eproto();
  
  void InitAsDefaultInstance();
  static DownloadConfigure* default_instance_;
};
// -------------------------------------------------------------------

class AgentConfigure : public ::google::protobuf::Message {
 public:
  AgentConfigure();
  virtual ~AgentConfigure();
  
  AgentConfigure(const AgentConfigure& from);
  
  inline AgentConfigure& operator=(const AgentConfigure& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentConfigure& default_instance();
  
  void Swap(AgentConfigure* other);
  
  // implements Message ----------------------------------------------
  
  AgentConfigure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentConfigure& from);
  void MergeFrom(const AgentConfigure& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string working_dir = 1;
  inline bool has_working_dir() const;
  inline void clear_working_dir();
  static const int kWorkingDirFieldNumber = 1;
  inline const ::std::string& working_dir() const;
  inline void set_working_dir(const ::std::string& value);
  inline void set_working_dir(const char* value);
  inline void set_working_dir(const char* value, size_t size);
  inline ::std::string* mutable_working_dir();
  inline ::std::string* release_working_dir();
  
  // optional string dynamic_conf_file = 2;
  inline bool has_dynamic_conf_file() const;
  inline void clear_dynamic_conf_file();
  static const int kDynamicConfFileFieldNumber = 2;
  inline const ::std::string& dynamic_conf_file() const;
  inline void set_dynamic_conf_file(const ::std::string& value);
  inline void set_dynamic_conf_file(const char* value);
  inline void set_dynamic_conf_file(const char* value, size_t size);
  inline ::std::string* mutable_dynamic_conf_file();
  inline ::std::string* release_dynamic_conf_file();
  
  // optional string resume_dir = 3;
  inline bool has_resume_dir() const;
  inline void clear_resume_dir();
  static const int kResumeDirFieldNumber = 3;
  inline const ::std::string& resume_dir() const;
  inline void set_resume_dir(const ::std::string& value);
  inline void set_resume_dir(const char* value);
  inline void set_resume_dir(const char* value, size_t size);
  inline ::std::string* mutable_resume_dir();
  inline ::std::string* release_resume_dir();
  
  // optional string lock_file = 4;
  inline bool has_lock_file() const;
  inline void clear_lock_file();
  static const int kLockFileFieldNumber = 4;
  inline const ::std::string& lock_file() const;
  inline void set_lock_file(const ::std::string& value);
  inline void set_lock_file(const char* value);
  inline void set_lock_file(const char* value, size_t size);
  inline ::std::string* mutable_lock_file();
  inline ::std::string* release_lock_file();
  
  // optional string database_file = 5;
  inline bool has_database_file() const;
  inline void clear_database_file();
  static const int kDatabaseFileFieldNumber = 5;
  inline const ::std::string& database_file() const;
  inline void set_database_file(const ::std::string& value);
  inline void set_database_file(const char* value);
  inline void set_database_file(const char* value, size_t size);
  inline ::std::string* mutable_database_file();
  inline ::std::string* release_database_file();
  
  // optional string socket_file = 6;
  inline bool has_socket_file() const;
  inline void clear_socket_file();
  static const int kSocketFileFieldNumber = 6;
  inline const ::std::string& socket_file() const;
  inline void set_socket_file(const ::std::string& value);
  inline void set_socket_file(const char* value);
  inline void set_socket_file(const char* value, size_t size);
  inline ::std::string* mutable_socket_file();
  inline ::std::string* release_socket_file();
  
  // optional string task_stat_file = 7;
  inline bool has_task_stat_file() const;
  inline void clear_task_stat_file();
  static const int kTaskStatFileFieldNumber = 7;
  inline const ::std::string& task_stat_file() const;
  inline void set_task_stat_file(const ::std::string& value);
  inline void set_task_stat_file(const char* value);
  inline void set_task_stat_file(const char* value, size_t size);
  inline ::std::string* mutable_task_stat_file();
  inline ::std::string* release_task_stat_file();
  
  // optional string peer_stat_file = 8;
  inline bool has_peer_stat_file() const;
  inline void clear_peer_stat_file();
  static const int kPeerStatFileFieldNumber = 8;
  inline const ::std::string& peer_stat_file() const;
  inline void set_peer_stat_file(const ::std::string& value);
  inline void set_peer_stat_file(const char* value);
  inline void set_peer_stat_file(const char* value, size_t size);
  inline ::std::string* mutable_peer_stat_file();
  inline ::std::string* release_peer_stat_file();
  
  // optional string download_log_file = 9;
  inline bool has_download_log_file() const;
  inline void clear_download_log_file();
  static const int kDownloadLogFileFieldNumber = 9;
  inline const ::std::string& download_log_file() const;
  inline void set_download_log_file(const ::std::string& value);
  inline void set_download_log_file(const char* value);
  inline void set_download_log_file(const char* value, size_t size);
  inline ::std::string* mutable_download_log_file();
  inline ::std::string* release_download_log_file();
  
  // optional string tracker_conf_file = 10;
  inline bool has_tracker_conf_file() const;
  inline void clear_tracker_conf_file();
  static const int kTrackerConfFileFieldNumber = 10;
  inline const ::std::string& tracker_conf_file() const;
  inline void set_tracker_conf_file(const ::std::string& value);
  inline void set_tracker_conf_file(const char* value);
  inline void set_tracker_conf_file(const char* value, size_t size);
  inline ::std::string* mutable_tracker_conf_file();
  inline ::std::string* release_tracker_conf_file();
  
  // optional int32 listen_port = 20;
  inline bool has_listen_port() const;
  inline void clear_listen_port();
  static const int kListenPortFieldNumber = 20;
  inline ::google::protobuf::int32 listen_port() const;
  inline void set_listen_port(::google::protobuf::int32 value);
  
  // optional int32 worker_thread_num = 21;
  inline bool has_worker_thread_num() const;
  inline void clear_worker_thread_num();
  static const int kWorkerThreadNumFieldNumber = 21;
  inline ::google::protobuf::int32 worker_thread_num() const;
  inline void set_worker_thread_num(::google::protobuf::int32 value);
  
  // optional int32 db_del_interval = 22;
  inline bool has_db_del_interval() const;
  inline void clear_db_del_interval();
  static const int kDbDelIntervalFieldNumber = 22;
  inline ::google::protobuf::int32 db_del_interval() const;
  inline void set_db_del_interval(::google::protobuf::int32 value);
  
  // optional int32 active_seeds = 23;
  inline bool has_active_seeds() const;
  inline void clear_active_seeds();
  static const int kActiveSeedsFieldNumber = 23;
  inline ::google::protobuf::int32 active_seeds() const;
  inline void set_active_seeds(::google::protobuf::int32 value);
  
  // optional int32 max_total_meta_num = 24;
  inline bool has_max_total_meta_num() const;
  inline void clear_max_total_meta_num();
  static const int kMaxTotalMetaNumFieldNumber = 24;
  inline ::google::protobuf::int32 max_total_meta_num() const;
  inline void set_max_total_meta_num(::google::protobuf::int32 value);
  
  // optional int32 max_total_meta_size = 25;
  inline bool has_max_total_meta_size() const;
  inline void clear_max_total_meta_size();
  static const int kMaxTotalMetaSizeFieldNumber = 25;
  inline ::google::protobuf::int32 max_total_meta_size() const;
  inline void set_max_total_meta_size(::google::protobuf::int32 value);
  
  // optional int32 upload_limit = 51;
  inline bool has_upload_limit() const;
  inline void clear_upload_limit();
  static const int kUploadLimitFieldNumber = 51;
  inline ::google::protobuf::int32 upload_limit() const;
  inline void set_upload_limit(::google::protobuf::int32 value);
  
  // optional int32 download_limit = 52;
  inline bool has_download_limit() const;
  inline void clear_download_limit();
  static const int kDownloadLimitFieldNumber = 52;
  inline ::google::protobuf::int32 download_limit() const;
  inline void set_download_limit(::google::protobuf::int32 value);
  
  // optional int32 connection_limit = 53;
  inline bool has_connection_limit() const;
  inline void clear_connection_limit();
  static const int kConnectionLimitFieldNumber = 53;
  inline ::google::protobuf::int32 connection_limit() const;
  inline void set_connection_limit(::google::protobuf::int32 value);
  
  // optional int32 peers_num_want = 54;
  inline bool has_peers_num_want() const;
  inline void clear_peers_num_want();
  static const int kPeersNumWantFieldNumber = 54;
  inline ::google::protobuf::int32 peers_num_want() const;
  inline void set_peers_num_want(::google::protobuf::int32 value);
  
  // optional bool disable_os_cache = 55;
  inline bool has_disable_os_cache() const;
  inline void clear_disable_os_cache();
  static const int kDisableOsCacheFieldNumber = 55;
  inline bool disable_os_cache() const;
  inline void set_disable_os_cache(bool value);
  
  // optional int32 cache_size = 56;
  inline bool has_cache_size() const;
  inline void clear_cache_size();
  static const int kCacheSizeFieldNumber = 56;
  inline ::google::protobuf::int32 cache_size() const;
  inline void set_cache_size(::google::protobuf::int32 value);
  
  // optional int32 cache_expiry = 57;
  inline bool has_cache_expiry() const;
  inline void clear_cache_expiry();
  static const int kCacheExpiryFieldNumber = 57;
  inline ::google::protobuf::int32 cache_expiry() const;
  inline void set_cache_expiry(::google::protobuf::int32 value);
  
  // optional int32 file_pool_size = 58;
  inline bool has_file_pool_size() const;
  inline void clear_file_pool_size();
  static const int kFilePoolSizeFieldNumber = 58;
  inline ::google::protobuf::int32 file_pool_size() const;
  inline void set_file_pool_size(::google::protobuf::int32 value);
  
  // optional int32 max_metadata_size = 59;
  inline bool has_max_metadata_size() const;
  inline void clear_max_metadata_size();
  static const int kMaxMetadataSizeFieldNumber = 59;
  inline ::google::protobuf::int32 max_metadata_size() const;
  inline void set_max_metadata_size(::google::protobuf::int32 value);
  
  // optional int32 seeding_announce_interval = 60;
  inline bool has_seeding_announce_interval() const;
  inline void clear_seeding_announce_interval();
  static const int kSeedingAnnounceIntervalFieldNumber = 60;
  inline ::google::protobuf::int32 seeding_announce_interval() const;
  inline void set_seeding_announce_interval(::google::protobuf::int32 value);
  
  // optional int32 min_reconnect_time = 61;
  inline bool has_min_reconnect_time() const;
  inline void clear_min_reconnect_time();
  static const int kMinReconnectTimeFieldNumber = 61;
  inline ::google::protobuf::int32 min_reconnect_time() const;
  inline void set_min_reconnect_time(::google::protobuf::int32 value);
  
  // optional int32 peer_connect_timeout = 62;
  inline bool has_peer_connect_timeout() const;
  inline void clear_peer_connect_timeout();
  static const int kPeerConnectTimeoutFieldNumber = 62;
  inline ::google::protobuf::int32 peer_connect_timeout() const;
  inline void set_peer_connect_timeout(::google::protobuf::int32 value);
  
  // optional int32 read_cache_line_size = 63;
  inline bool has_read_cache_line_size() const;
  inline void clear_read_cache_line_size();
  static const int kReadCacheLineSizeFieldNumber = 63;
  inline ::google::protobuf::int32 read_cache_line_size() const;
  inline void set_read_cache_line_size(::google::protobuf::int32 value);
  
  // optional int32 write_cache_line_size = 64;
  inline bool has_write_cache_line_size() const;
  inline void clear_write_cache_line_size();
  static const int kWriteCacheLineSizeFieldNumber = 64;
  inline ::google::protobuf::int32 write_cache_line_size() const;
  inline void set_write_cache_line_size(::google::protobuf::int32 value);
  
  // optional bool lock_disk_cache = 65;
  inline bool has_lock_disk_cache() const;
  inline void clear_lock_disk_cache();
  static const int kLockDiskCacheFieldNumber = 65;
  inline bool lock_disk_cache() const;
  inline void set_lock_disk_cache(bool value);
  
  // optional bool suggest_mode = 66;
  inline bool has_suggest_mode() const;
  inline void clear_suggest_mode();
  static const int kSuggestModeFieldNumber = 66;
  inline bool suggest_mode() const;
  inline void set_suggest_mode(bool value);
  
  // optional int32 max_queued_disk_bytes = 67;
  inline bool has_max_queued_disk_bytes() const;
  inline void clear_max_queued_disk_bytes();
  static const int kMaxQueuedDiskBytesFieldNumber = 67;
  inline ::google::protobuf::int32 max_queued_disk_bytes() const;
  inline void set_max_queued_disk_bytes(::google::protobuf::int32 value);
  
  // optional int32 max_out_request_queue = 68;
  inline bool has_max_out_request_queue() const;
  inline void clear_max_out_request_queue();
  static const int kMaxOutRequestQueueFieldNumber = 68;
  inline ::google::protobuf::int32 max_out_request_queue() const;
  inline void set_max_out_request_queue(::google::protobuf::int32 value);
  
  // optional int32 max_allowed_in_request_queue = 69;
  inline bool has_max_allowed_in_request_queue() const;
  inline void clear_max_allowed_in_request_queue();
  static const int kMaxAllowedInRequestQueueFieldNumber = 69;
  inline ::google::protobuf::int32 max_allowed_in_request_queue() const;
  inline void set_max_allowed_in_request_queue(::google::protobuf::int32 value);
  
  // optional int32 whole_pieces_threshold = 70;
  inline bool has_whole_pieces_threshold() const;
  inline void clear_whole_pieces_threshold();
  static const int kWholePiecesThresholdFieldNumber = 70;
  inline ::google::protobuf::int32 whole_pieces_threshold() const;
  inline void set_whole_pieces_threshold(::google::protobuf::int32 value);
  
  // optional int32 request_queue_time = 71;
  inline bool has_request_queue_time() const;
  inline void clear_request_queue_time();
  static const int kRequestQueueTimeFieldNumber = 71;
  inline ::google::protobuf::int32 request_queue_time() const;
  inline void set_request_queue_time(::google::protobuf::int32 value);
  
  // optional int32 send_buffer_low_watermark = 72;
  inline bool has_send_buffer_low_watermark() const;
  inline void clear_send_buffer_low_watermark();
  static const int kSendBufferLowWatermarkFieldNumber = 72;
  inline ::google::protobuf::int32 send_buffer_low_watermark() const;
  inline void set_send_buffer_low_watermark(::google::protobuf::int32 value);
  
  // optional int32 send_buffer_watermark = 73;
  inline bool has_send_buffer_watermark() const;
  inline void clear_send_buffer_watermark();
  static const int kSendBufferWatermarkFieldNumber = 73;
  inline ::google::protobuf::int32 send_buffer_watermark() const;
  inline void set_send_buffer_watermark(::google::protobuf::int32 value);
  
  // optional int32 send_socket_buffer_size = 74;
  inline bool has_send_socket_buffer_size() const;
  inline void clear_send_socket_buffer_size();
  static const int kSendSocketBufferSizeFieldNumber = 74;
  inline ::google::protobuf::int32 send_socket_buffer_size() const;
  inline void set_send_socket_buffer_size(::google::protobuf::int32 value);
  
  // optional int32 recv_socket_buffer_size = 75;
  inline bool has_recv_socket_buffer_size() const;
  inline void clear_recv_socket_buffer_size();
  static const int kRecvSocketBufferSizeFieldNumber = 75;
  inline ::google::protobuf::int32 recv_socket_buffer_size() const;
  inline void set_recv_socket_buffer_size(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:bbts.message.AgentConfigure)
 private:
  inline void set_has_working_dir();
  inline void clear_has_working_dir();
  inline void set_has_dynamic_conf_file();
  inline void clear_has_dynamic_conf_file();
  inline void set_has_resume_dir();
  inline void clear_has_resume_dir();
  inline void set_has_lock_file();
  inline void clear_has_lock_file();
  inline void set_has_database_file();
  inline void clear_has_database_file();
  inline void set_has_socket_file();
  inline void clear_has_socket_file();
  inline void set_has_task_stat_file();
  inline void clear_has_task_stat_file();
  inline void set_has_peer_stat_file();
  inline void clear_has_peer_stat_file();
  inline void set_has_download_log_file();
  inline void clear_has_download_log_file();
  inline void set_has_tracker_conf_file();
  inline void clear_has_tracker_conf_file();
  inline void set_has_listen_port();
  inline void clear_has_listen_port();
  inline void set_has_worker_thread_num();
  inline void clear_has_worker_thread_num();
  inline void set_has_db_del_interval();
  inline void clear_has_db_del_interval();
  inline void set_has_active_seeds();
  inline void clear_has_active_seeds();
  inline void set_has_max_total_meta_num();
  inline void clear_has_max_total_meta_num();
  inline void set_has_max_total_meta_size();
  inline void clear_has_max_total_meta_size();
  inline void set_has_upload_limit();
  inline void clear_has_upload_limit();
  inline void set_has_download_limit();
  inline void clear_has_download_limit();
  inline void set_has_connection_limit();
  inline void clear_has_connection_limit();
  inline void set_has_peers_num_want();
  inline void clear_has_peers_num_want();
  inline void set_has_disable_os_cache();
  inline void clear_has_disable_os_cache();
  inline void set_has_cache_size();
  inline void clear_has_cache_size();
  inline void set_has_cache_expiry();
  inline void clear_has_cache_expiry();
  inline void set_has_file_pool_size();
  inline void clear_has_file_pool_size();
  inline void set_has_max_metadata_size();
  inline void clear_has_max_metadata_size();
  inline void set_has_seeding_announce_interval();
  inline void clear_has_seeding_announce_interval();
  inline void set_has_min_reconnect_time();
  inline void clear_has_min_reconnect_time();
  inline void set_has_peer_connect_timeout();
  inline void clear_has_peer_connect_timeout();
  inline void set_has_read_cache_line_size();
  inline void clear_has_read_cache_line_size();
  inline void set_has_write_cache_line_size();
  inline void clear_has_write_cache_line_size();
  inline void set_has_lock_disk_cache();
  inline void clear_has_lock_disk_cache();
  inline void set_has_suggest_mode();
  inline void clear_has_suggest_mode();
  inline void set_has_max_queued_disk_bytes();
  inline void clear_has_max_queued_disk_bytes();
  inline void set_has_max_out_request_queue();
  inline void clear_has_max_out_request_queue();
  inline void set_has_max_allowed_in_request_queue();
  inline void clear_has_max_allowed_in_request_queue();
  inline void set_has_whole_pieces_threshold();
  inline void clear_has_whole_pieces_threshold();
  inline void set_has_request_queue_time();
  inline void clear_has_request_queue_time();
  inline void set_has_send_buffer_low_watermark();
  inline void clear_has_send_buffer_low_watermark();
  inline void set_has_send_buffer_watermark();
  inline void clear_has_send_buffer_watermark();
  inline void set_has_send_socket_buffer_size();
  inline void clear_has_send_socket_buffer_size();
  inline void set_has_recv_socket_buffer_size();
  inline void clear_has_recv_socket_buffer_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* working_dir_;
  ::std::string* dynamic_conf_file_;
  ::std::string* resume_dir_;
  ::std::string* lock_file_;
  ::std::string* database_file_;
  ::std::string* socket_file_;
  ::std::string* task_stat_file_;
  ::std::string* peer_stat_file_;
  ::std::string* download_log_file_;
  ::std::string* tracker_conf_file_;
  ::google::protobuf::int32 listen_port_;
  ::google::protobuf::int32 worker_thread_num_;
  ::google::protobuf::int32 db_del_interval_;
  ::google::protobuf::int32 active_seeds_;
  ::google::protobuf::int32 max_total_meta_num_;
  ::google::protobuf::int32 max_total_meta_size_;
  ::google::protobuf::int32 upload_limit_;
  ::google::protobuf::int32 download_limit_;
  ::google::protobuf::int32 connection_limit_;
  ::google::protobuf::int32 peers_num_want_;
  ::google::protobuf::int32 cache_size_;
  ::google::protobuf::int32 cache_expiry_;
  ::google::protobuf::int32 file_pool_size_;
  ::google::protobuf::int32 max_metadata_size_;
  ::google::protobuf::int32 seeding_announce_interval_;
  ::google::protobuf::int32 min_reconnect_time_;
  ::google::protobuf::int32 peer_connect_timeout_;
  bool disable_os_cache_;
  bool lock_disk_cache_;
  bool suggest_mode_;
  ::google::protobuf::int32 read_cache_line_size_;
  ::google::protobuf::int32 write_cache_line_size_;
  ::google::protobuf::int32 max_queued_disk_bytes_;
  ::google::protobuf::int32 max_out_request_queue_;
  ::google::protobuf::int32 max_allowed_in_request_queue_;
  ::google::protobuf::int32 whole_pieces_threshold_;
  ::google::protobuf::int32 request_queue_time_;
  ::google::protobuf::int32 send_buffer_low_watermark_;
  ::google::protobuf::int32 send_buffer_watermark_;
  ::google::protobuf::int32 send_socket_buffer_size_;
  ::google::protobuf::int32 recv_socket_buffer_size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(41 + 31) / 32];
  
  friend void  protobuf_AddDesc_configure_2eproto();
  friend void protobuf_AssignDesc_configure_2eproto();
  friend void protobuf_ShutdownFile_configure_2eproto();
  
  void InitAsDefaultInstance();
  static AgentConfigure* default_instance_;
};
// ===================================================================


// ===================================================================

// DownloadConfigure

// optional int32 download_timeout = 1;
inline bool DownloadConfigure::has_download_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DownloadConfigure::set_has_download_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DownloadConfigure::clear_has_download_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DownloadConfigure::clear_download_timeout() {
  download_timeout_ = 0;
  clear_has_download_timeout();
}
inline ::google::protobuf::int32 DownloadConfigure::download_timeout() const {
  return download_timeout_;
}
inline void DownloadConfigure::set_download_timeout(::google::protobuf::int32 value) {
  set_has_download_timeout();
  download_timeout_ = value;
}

// optional int32 max_announce_interval = 2;
inline bool DownloadConfigure::has_max_announce_interval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DownloadConfigure::set_has_max_announce_interval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DownloadConfigure::clear_has_max_announce_interval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DownloadConfigure::clear_max_announce_interval() {
  max_announce_interval_ = 0;
  clear_has_max_announce_interval();
}
inline ::google::protobuf::int32 DownloadConfigure::max_announce_interval() const {
  return max_announce_interval_;
}
inline void DownloadConfigure::set_max_announce_interval(::google::protobuf::int32 value) {
  set_has_max_announce_interval();
  max_announce_interval_ = value;
}

// optional int32 cluster_thread_num = 3;
inline bool DownloadConfigure::has_cluster_thread_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DownloadConfigure::set_has_cluster_thread_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DownloadConfigure::clear_has_cluster_thread_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DownloadConfigure::clear_cluster_thread_num() {
  cluster_thread_num_ = 0;
  clear_has_cluster_thread_num();
}
inline ::google::protobuf::int32 DownloadConfigure::cluster_thread_num() const {
  return cluster_thread_num_;
}
inline void DownloadConfigure::set_cluster_thread_num(::google::protobuf::int32 value) {
  set_has_cluster_thread_num();
  cluster_thread_num_ = value;
}

// optional string java_home = 4;
inline bool DownloadConfigure::has_java_home() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DownloadConfigure::set_has_java_home() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DownloadConfigure::clear_has_java_home() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DownloadConfigure::clear_java_home() {
  if (java_home_ != &::google::protobuf::internal::kEmptyString) {
    java_home_->clear();
  }
  clear_has_java_home();
}
inline const ::std::string& DownloadConfigure::java_home() const {
  return *java_home_;
}
inline void DownloadConfigure::set_java_home(const ::std::string& value) {
  set_has_java_home();
  if (java_home_ == &::google::protobuf::internal::kEmptyString) {
    java_home_ = new ::std::string;
  }
  java_home_->assign(value);
}
inline void DownloadConfigure::set_java_home(const char* value) {
  set_has_java_home();
  if (java_home_ == &::google::protobuf::internal::kEmptyString) {
    java_home_ = new ::std::string;
  }
  java_home_->assign(value);
}
inline void DownloadConfigure::set_java_home(const char* value, size_t size) {
  set_has_java_home();
  if (java_home_ == &::google::protobuf::internal::kEmptyString) {
    java_home_ = new ::std::string;
  }
  java_home_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DownloadConfigure::mutable_java_home() {
  set_has_java_home();
  if (java_home_ == &::google::protobuf::internal::kEmptyString) {
    java_home_ = new ::std::string;
  }
  return java_home_;
}
inline ::std::string* DownloadConfigure::release_java_home() {
  clear_has_java_home();
  if (java_home_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = java_home_;
    java_home_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string class_path = 5;
inline bool DownloadConfigure::has_class_path() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DownloadConfigure::set_has_class_path() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DownloadConfigure::clear_has_class_path() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DownloadConfigure::clear_class_path() {
  if (class_path_ != &::google::protobuf::internal::kEmptyString) {
    class_path_->clear();
  }
  clear_has_class_path();
}
inline const ::std::string& DownloadConfigure::class_path() const {
  return *class_path_;
}
inline void DownloadConfigure::set_class_path(const ::std::string& value) {
  set_has_class_path();
  if (class_path_ == &::google::protobuf::internal::kEmptyString) {
    class_path_ = new ::std::string;
  }
  class_path_->assign(value);
}
inline void DownloadConfigure::set_class_path(const char* value) {
  set_has_class_path();
  if (class_path_ == &::google::protobuf::internal::kEmptyString) {
    class_path_ = new ::std::string;
  }
  class_path_->assign(value);
}
inline void DownloadConfigure::set_class_path(const char* value, size_t size) {
  set_has_class_path();
  if (class_path_ == &::google::protobuf::internal::kEmptyString) {
    class_path_ = new ::std::string;
  }
  class_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DownloadConfigure::mutable_class_path() {
  set_has_class_path();
  if (class_path_ == &::google::protobuf::internal::kEmptyString) {
    class_path_ = new ::std::string;
  }
  return class_path_;
}
inline ::std::string* DownloadConfigure::release_class_path() {
  clear_has_class_path();
  if (class_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = class_path_;
    class_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string socket_file = 6;
inline bool DownloadConfigure::has_socket_file() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DownloadConfigure::set_has_socket_file() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DownloadConfigure::clear_has_socket_file() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DownloadConfigure::clear_socket_file() {
  if (socket_file_ != &::google::protobuf::internal::kEmptyString) {
    socket_file_->clear();
  }
  clear_has_socket_file();
}
inline const ::std::string& DownloadConfigure::socket_file() const {
  return *socket_file_;
}
inline void DownloadConfigure::set_socket_file(const ::std::string& value) {
  set_has_socket_file();
  if (socket_file_ == &::google::protobuf::internal::kEmptyString) {
    socket_file_ = new ::std::string;
  }
  socket_file_->assign(value);
}
inline void DownloadConfigure::set_socket_file(const char* value) {
  set_has_socket_file();
  if (socket_file_ == &::google::protobuf::internal::kEmptyString) {
    socket_file_ = new ::std::string;
  }
  socket_file_->assign(value);
}
inline void DownloadConfigure::set_socket_file(const char* value, size_t size) {
  set_has_socket_file();
  if (socket_file_ == &::google::protobuf::internal::kEmptyString) {
    socket_file_ = new ::std::string;
  }
  socket_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DownloadConfigure::mutable_socket_file() {
  set_has_socket_file();
  if (socket_file_ == &::google::protobuf::internal::kEmptyString) {
    socket_file_ = new ::std::string;
  }
  return socket_file_;
}
inline ::std::string* DownloadConfigure::release_socket_file() {
  clear_has_socket_file();
  if (socket_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = socket_file_;
    socket_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string task_stat_file = 7;
inline bool DownloadConfigure::has_task_stat_file() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DownloadConfigure::set_has_task_stat_file() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DownloadConfigure::clear_has_task_stat_file() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DownloadConfigure::clear_task_stat_file() {
  if (task_stat_file_ != &::google::protobuf::internal::kEmptyString) {
    task_stat_file_->clear();
  }
  clear_has_task_stat_file();
}
inline const ::std::string& DownloadConfigure::task_stat_file() const {
  return *task_stat_file_;
}
inline void DownloadConfigure::set_task_stat_file(const ::std::string& value) {
  set_has_task_stat_file();
  if (task_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    task_stat_file_ = new ::std::string;
  }
  task_stat_file_->assign(value);
}
inline void DownloadConfigure::set_task_stat_file(const char* value) {
  set_has_task_stat_file();
  if (task_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    task_stat_file_ = new ::std::string;
  }
  task_stat_file_->assign(value);
}
inline void DownloadConfigure::set_task_stat_file(const char* value, size_t size) {
  set_has_task_stat_file();
  if (task_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    task_stat_file_ = new ::std::string;
  }
  task_stat_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DownloadConfigure::mutable_task_stat_file() {
  set_has_task_stat_file();
  if (task_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    task_stat_file_ = new ::std::string;
  }
  return task_stat_file_;
}
inline ::std::string* DownloadConfigure::release_task_stat_file() {
  clear_has_task_stat_file();
  if (task_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_stat_file_;
    task_stat_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string peer_stat_file = 8;
inline bool DownloadConfigure::has_peer_stat_file() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DownloadConfigure::set_has_peer_stat_file() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DownloadConfigure::clear_has_peer_stat_file() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DownloadConfigure::clear_peer_stat_file() {
  if (peer_stat_file_ != &::google::protobuf::internal::kEmptyString) {
    peer_stat_file_->clear();
  }
  clear_has_peer_stat_file();
}
inline const ::std::string& DownloadConfigure::peer_stat_file() const {
  return *peer_stat_file_;
}
inline void DownloadConfigure::set_peer_stat_file(const ::std::string& value) {
  set_has_peer_stat_file();
  if (peer_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    peer_stat_file_ = new ::std::string;
  }
  peer_stat_file_->assign(value);
}
inline void DownloadConfigure::set_peer_stat_file(const char* value) {
  set_has_peer_stat_file();
  if (peer_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    peer_stat_file_ = new ::std::string;
  }
  peer_stat_file_->assign(value);
}
inline void DownloadConfigure::set_peer_stat_file(const char* value, size_t size) {
  set_has_peer_stat_file();
  if (peer_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    peer_stat_file_ = new ::std::string;
  }
  peer_stat_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DownloadConfigure::mutable_peer_stat_file() {
  set_has_peer_stat_file();
  if (peer_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    peer_stat_file_ = new ::std::string;
  }
  return peer_stat_file_;
}
inline ::std::string* DownloadConfigure::release_peer_stat_file() {
  clear_has_peer_stat_file();
  if (peer_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peer_stat_file_;
    peer_stat_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string download_log_file = 9;
inline bool DownloadConfigure::has_download_log_file() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DownloadConfigure::set_has_download_log_file() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DownloadConfigure::clear_has_download_log_file() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DownloadConfigure::clear_download_log_file() {
  if (download_log_file_ != &::google::protobuf::internal::kEmptyString) {
    download_log_file_->clear();
  }
  clear_has_download_log_file();
}
inline const ::std::string& DownloadConfigure::download_log_file() const {
  return *download_log_file_;
}
inline void DownloadConfigure::set_download_log_file(const ::std::string& value) {
  set_has_download_log_file();
  if (download_log_file_ == &::google::protobuf::internal::kEmptyString) {
    download_log_file_ = new ::std::string;
  }
  download_log_file_->assign(value);
}
inline void DownloadConfigure::set_download_log_file(const char* value) {
  set_has_download_log_file();
  if (download_log_file_ == &::google::protobuf::internal::kEmptyString) {
    download_log_file_ = new ::std::string;
  }
  download_log_file_->assign(value);
}
inline void DownloadConfigure::set_download_log_file(const char* value, size_t size) {
  set_has_download_log_file();
  if (download_log_file_ == &::google::protobuf::internal::kEmptyString) {
    download_log_file_ = new ::std::string;
  }
  download_log_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DownloadConfigure::mutable_download_log_file() {
  set_has_download_log_file();
  if (download_log_file_ == &::google::protobuf::internal::kEmptyString) {
    download_log_file_ = new ::std::string;
  }
  return download_log_file_;
}
inline ::std::string* DownloadConfigure::release_download_log_file() {
  clear_has_download_log_file();
  if (download_log_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = download_log_file_;
    download_log_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string tracker_conf_file = 10;
inline bool DownloadConfigure::has_tracker_conf_file() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DownloadConfigure::set_has_tracker_conf_file() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DownloadConfigure::clear_has_tracker_conf_file() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DownloadConfigure::clear_tracker_conf_file() {
  if (tracker_conf_file_ != &::google::protobuf::internal::kEmptyString) {
    tracker_conf_file_->clear();
  }
  clear_has_tracker_conf_file();
}
inline const ::std::string& DownloadConfigure::tracker_conf_file() const {
  return *tracker_conf_file_;
}
inline void DownloadConfigure::set_tracker_conf_file(const ::std::string& value) {
  set_has_tracker_conf_file();
  if (tracker_conf_file_ == &::google::protobuf::internal::kEmptyString) {
    tracker_conf_file_ = new ::std::string;
  }
  tracker_conf_file_->assign(value);
}
inline void DownloadConfigure::set_tracker_conf_file(const char* value) {
  set_has_tracker_conf_file();
  if (tracker_conf_file_ == &::google::protobuf::internal::kEmptyString) {
    tracker_conf_file_ = new ::std::string;
  }
  tracker_conf_file_->assign(value);
}
inline void DownloadConfigure::set_tracker_conf_file(const char* value, size_t size) {
  set_has_tracker_conf_file();
  if (tracker_conf_file_ == &::google::protobuf::internal::kEmptyString) {
    tracker_conf_file_ = new ::std::string;
  }
  tracker_conf_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DownloadConfigure::mutable_tracker_conf_file() {
  set_has_tracker_conf_file();
  if (tracker_conf_file_ == &::google::protobuf::internal::kEmptyString) {
    tracker_conf_file_ = new ::std::string;
  }
  return tracker_conf_file_;
}
inline ::std::string* DownloadConfigure::release_tracker_conf_file() {
  clear_has_tracker_conf_file();
  if (tracker_conf_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tracker_conf_file_;
    tracker_conf_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 upload_limit = 51;
inline bool DownloadConfigure::has_upload_limit() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DownloadConfigure::set_has_upload_limit() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DownloadConfigure::clear_has_upload_limit() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DownloadConfigure::clear_upload_limit() {
  upload_limit_ = 0;
  clear_has_upload_limit();
}
inline ::google::protobuf::int32 DownloadConfigure::upload_limit() const {
  return upload_limit_;
}
inline void DownloadConfigure::set_upload_limit(::google::protobuf::int32 value) {
  set_has_upload_limit();
  upload_limit_ = value;
}

// optional int32 download_limit = 52;
inline bool DownloadConfigure::has_download_limit() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DownloadConfigure::set_has_download_limit() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DownloadConfigure::clear_has_download_limit() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DownloadConfigure::clear_download_limit() {
  download_limit_ = 0;
  clear_has_download_limit();
}
inline ::google::protobuf::int32 DownloadConfigure::download_limit() const {
  return download_limit_;
}
inline void DownloadConfigure::set_download_limit(::google::protobuf::int32 value) {
  set_has_download_limit();
  download_limit_ = value;
}

// optional int32 connection_limit = 53;
inline bool DownloadConfigure::has_connection_limit() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DownloadConfigure::set_has_connection_limit() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DownloadConfigure::clear_has_connection_limit() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DownloadConfigure::clear_connection_limit() {
  connection_limit_ = 0;
  clear_has_connection_limit();
}
inline ::google::protobuf::int32 DownloadConfigure::connection_limit() const {
  return connection_limit_;
}
inline void DownloadConfigure::set_connection_limit(::google::protobuf::int32 value) {
  set_has_connection_limit();
  connection_limit_ = value;
}

// optional int32 peers_num_want = 54;
inline bool DownloadConfigure::has_peers_num_want() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DownloadConfigure::set_has_peers_num_want() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DownloadConfigure::clear_has_peers_num_want() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DownloadConfigure::clear_peers_num_want() {
  peers_num_want_ = 0;
  clear_has_peers_num_want();
}
inline ::google::protobuf::int32 DownloadConfigure::peers_num_want() const {
  return peers_num_want_;
}
inline void DownloadConfigure::set_peers_num_want(::google::protobuf::int32 value) {
  set_has_peers_num_want();
  peers_num_want_ = value;
}

// optional int32 cache_size = 56;
inline bool DownloadConfigure::has_cache_size() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DownloadConfigure::set_has_cache_size() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DownloadConfigure::clear_has_cache_size() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DownloadConfigure::clear_cache_size() {
  cache_size_ = 0;
  clear_has_cache_size();
}
inline ::google::protobuf::int32 DownloadConfigure::cache_size() const {
  return cache_size_;
}
inline void DownloadConfigure::set_cache_size(::google::protobuf::int32 value) {
  set_has_cache_size();
  cache_size_ = value;
}

// optional int32 cache_expiry = 57;
inline bool DownloadConfigure::has_cache_expiry() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DownloadConfigure::set_has_cache_expiry() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DownloadConfigure::clear_has_cache_expiry() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DownloadConfigure::clear_cache_expiry() {
  cache_expiry_ = 0;
  clear_has_cache_expiry();
}
inline ::google::protobuf::int32 DownloadConfigure::cache_expiry() const {
  return cache_expiry_;
}
inline void DownloadConfigure::set_cache_expiry(::google::protobuf::int32 value) {
  set_has_cache_expiry();
  cache_expiry_ = value;
}

// optional int32 file_pool_size = 58;
inline bool DownloadConfigure::has_file_pool_size() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DownloadConfigure::set_has_file_pool_size() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DownloadConfigure::clear_has_file_pool_size() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DownloadConfigure::clear_file_pool_size() {
  file_pool_size_ = 0;
  clear_has_file_pool_size();
}
inline ::google::protobuf::int32 DownloadConfigure::file_pool_size() const {
  return file_pool_size_;
}
inline void DownloadConfigure::set_file_pool_size(::google::protobuf::int32 value) {
  set_has_file_pool_size();
  file_pool_size_ = value;
}

// optional int32 max_metadata_size = 59;
inline bool DownloadConfigure::has_max_metadata_size() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DownloadConfigure::set_has_max_metadata_size() {
  _has_bits_[0] |= 0x00020000u;
}
inline void DownloadConfigure::clear_has_max_metadata_size() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void DownloadConfigure::clear_max_metadata_size() {
  max_metadata_size_ = 0;
  clear_has_max_metadata_size();
}
inline ::google::protobuf::int32 DownloadConfigure::max_metadata_size() const {
  return max_metadata_size_;
}
inline void DownloadConfigure::set_max_metadata_size(::google::protobuf::int32 value) {
  set_has_max_metadata_size();
  max_metadata_size_ = value;
}

// optional int32 seeding_announce_interval = 60;
inline bool DownloadConfigure::has_seeding_announce_interval() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void DownloadConfigure::set_has_seeding_announce_interval() {
  _has_bits_[0] |= 0x00040000u;
}
inline void DownloadConfigure::clear_has_seeding_announce_interval() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void DownloadConfigure::clear_seeding_announce_interval() {
  seeding_announce_interval_ = 0;
  clear_has_seeding_announce_interval();
}
inline ::google::protobuf::int32 DownloadConfigure::seeding_announce_interval() const {
  return seeding_announce_interval_;
}
inline void DownloadConfigure::set_seeding_announce_interval(::google::protobuf::int32 value) {
  set_has_seeding_announce_interval();
  seeding_announce_interval_ = value;
}

// optional int32 min_reconnect_time = 61;
inline bool DownloadConfigure::has_min_reconnect_time() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void DownloadConfigure::set_has_min_reconnect_time() {
  _has_bits_[0] |= 0x00080000u;
}
inline void DownloadConfigure::clear_has_min_reconnect_time() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void DownloadConfigure::clear_min_reconnect_time() {
  min_reconnect_time_ = 0;
  clear_has_min_reconnect_time();
}
inline ::google::protobuf::int32 DownloadConfigure::min_reconnect_time() const {
  return min_reconnect_time_;
}
inline void DownloadConfigure::set_min_reconnect_time(::google::protobuf::int32 value) {
  set_has_min_reconnect_time();
  min_reconnect_time_ = value;
}

// optional int32 peer_connect_timeout = 62;
inline bool DownloadConfigure::has_peer_connect_timeout() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void DownloadConfigure::set_has_peer_connect_timeout() {
  _has_bits_[0] |= 0x00100000u;
}
inline void DownloadConfigure::clear_has_peer_connect_timeout() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void DownloadConfigure::clear_peer_connect_timeout() {
  peer_connect_timeout_ = 0;
  clear_has_peer_connect_timeout();
}
inline ::google::protobuf::int32 DownloadConfigure::peer_connect_timeout() const {
  return peer_connect_timeout_;
}
inline void DownloadConfigure::set_peer_connect_timeout(::google::protobuf::int32 value) {
  set_has_peer_connect_timeout();
  peer_connect_timeout_ = value;
}

// optional int32 read_cache_line_size = 63;
inline bool DownloadConfigure::has_read_cache_line_size() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void DownloadConfigure::set_has_read_cache_line_size() {
  _has_bits_[0] |= 0x00200000u;
}
inline void DownloadConfigure::clear_has_read_cache_line_size() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void DownloadConfigure::clear_read_cache_line_size() {
  read_cache_line_size_ = 0;
  clear_has_read_cache_line_size();
}
inline ::google::protobuf::int32 DownloadConfigure::read_cache_line_size() const {
  return read_cache_line_size_;
}
inline void DownloadConfigure::set_read_cache_line_size(::google::protobuf::int32 value) {
  set_has_read_cache_line_size();
  read_cache_line_size_ = value;
}

// optional int32 write_cache_line_size = 64;
inline bool DownloadConfigure::has_write_cache_line_size() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void DownloadConfigure::set_has_write_cache_line_size() {
  _has_bits_[0] |= 0x00400000u;
}
inline void DownloadConfigure::clear_has_write_cache_line_size() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void DownloadConfigure::clear_write_cache_line_size() {
  write_cache_line_size_ = 0;
  clear_has_write_cache_line_size();
}
inline ::google::protobuf::int32 DownloadConfigure::write_cache_line_size() const {
  return write_cache_line_size_;
}
inline void DownloadConfigure::set_write_cache_line_size(::google::protobuf::int32 value) {
  set_has_write_cache_line_size();
  write_cache_line_size_ = value;
}

// optional bool lock_disk_cache = 65;
inline bool DownloadConfigure::has_lock_disk_cache() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void DownloadConfigure::set_has_lock_disk_cache() {
  _has_bits_[0] |= 0x00800000u;
}
inline void DownloadConfigure::clear_has_lock_disk_cache() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void DownloadConfigure::clear_lock_disk_cache() {
  lock_disk_cache_ = false;
  clear_has_lock_disk_cache();
}
inline bool DownloadConfigure::lock_disk_cache() const {
  return lock_disk_cache_;
}
inline void DownloadConfigure::set_lock_disk_cache(bool value) {
  set_has_lock_disk_cache();
  lock_disk_cache_ = value;
}

// optional bool suggest_mode = 66;
inline bool DownloadConfigure::has_suggest_mode() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void DownloadConfigure::set_has_suggest_mode() {
  _has_bits_[0] |= 0x01000000u;
}
inline void DownloadConfigure::clear_has_suggest_mode() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void DownloadConfigure::clear_suggest_mode() {
  suggest_mode_ = false;
  clear_has_suggest_mode();
}
inline bool DownloadConfigure::suggest_mode() const {
  return suggest_mode_;
}
inline void DownloadConfigure::set_suggest_mode(bool value) {
  set_has_suggest_mode();
  suggest_mode_ = value;
}

// optional int32 max_queued_disk_bytes = 67;
inline bool DownloadConfigure::has_max_queued_disk_bytes() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void DownloadConfigure::set_has_max_queued_disk_bytes() {
  _has_bits_[0] |= 0x02000000u;
}
inline void DownloadConfigure::clear_has_max_queued_disk_bytes() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void DownloadConfigure::clear_max_queued_disk_bytes() {
  max_queued_disk_bytes_ = 0;
  clear_has_max_queued_disk_bytes();
}
inline ::google::protobuf::int32 DownloadConfigure::max_queued_disk_bytes() const {
  return max_queued_disk_bytes_;
}
inline void DownloadConfigure::set_max_queued_disk_bytes(::google::protobuf::int32 value) {
  set_has_max_queued_disk_bytes();
  max_queued_disk_bytes_ = value;
}

// optional int32 max_out_request_queue = 68;
inline bool DownloadConfigure::has_max_out_request_queue() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void DownloadConfigure::set_has_max_out_request_queue() {
  _has_bits_[0] |= 0x04000000u;
}
inline void DownloadConfigure::clear_has_max_out_request_queue() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void DownloadConfigure::clear_max_out_request_queue() {
  max_out_request_queue_ = 0;
  clear_has_max_out_request_queue();
}
inline ::google::protobuf::int32 DownloadConfigure::max_out_request_queue() const {
  return max_out_request_queue_;
}
inline void DownloadConfigure::set_max_out_request_queue(::google::protobuf::int32 value) {
  set_has_max_out_request_queue();
  max_out_request_queue_ = value;
}

// optional int32 max_allowed_in_request_queue = 69;
inline bool DownloadConfigure::has_max_allowed_in_request_queue() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void DownloadConfigure::set_has_max_allowed_in_request_queue() {
  _has_bits_[0] |= 0x08000000u;
}
inline void DownloadConfigure::clear_has_max_allowed_in_request_queue() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void DownloadConfigure::clear_max_allowed_in_request_queue() {
  max_allowed_in_request_queue_ = 0;
  clear_has_max_allowed_in_request_queue();
}
inline ::google::protobuf::int32 DownloadConfigure::max_allowed_in_request_queue() const {
  return max_allowed_in_request_queue_;
}
inline void DownloadConfigure::set_max_allowed_in_request_queue(::google::protobuf::int32 value) {
  set_has_max_allowed_in_request_queue();
  max_allowed_in_request_queue_ = value;
}

// optional int32 whole_pieces_threshold = 70;
inline bool DownloadConfigure::has_whole_pieces_threshold() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void DownloadConfigure::set_has_whole_pieces_threshold() {
  _has_bits_[0] |= 0x10000000u;
}
inline void DownloadConfigure::clear_has_whole_pieces_threshold() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void DownloadConfigure::clear_whole_pieces_threshold() {
  whole_pieces_threshold_ = 0;
  clear_has_whole_pieces_threshold();
}
inline ::google::protobuf::int32 DownloadConfigure::whole_pieces_threshold() const {
  return whole_pieces_threshold_;
}
inline void DownloadConfigure::set_whole_pieces_threshold(::google::protobuf::int32 value) {
  set_has_whole_pieces_threshold();
  whole_pieces_threshold_ = value;
}

// optional int32 request_queue_time = 71;
inline bool DownloadConfigure::has_request_queue_time() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void DownloadConfigure::set_has_request_queue_time() {
  _has_bits_[0] |= 0x20000000u;
}
inline void DownloadConfigure::clear_has_request_queue_time() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void DownloadConfigure::clear_request_queue_time() {
  request_queue_time_ = 0;
  clear_has_request_queue_time();
}
inline ::google::protobuf::int32 DownloadConfigure::request_queue_time() const {
  return request_queue_time_;
}
inline void DownloadConfigure::set_request_queue_time(::google::protobuf::int32 value) {
  set_has_request_queue_time();
  request_queue_time_ = value;
}

// optional int32 send_buffer_low_watermark = 72;
inline bool DownloadConfigure::has_send_buffer_low_watermark() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void DownloadConfigure::set_has_send_buffer_low_watermark() {
  _has_bits_[0] |= 0x40000000u;
}
inline void DownloadConfigure::clear_has_send_buffer_low_watermark() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void DownloadConfigure::clear_send_buffer_low_watermark() {
  send_buffer_low_watermark_ = 0;
  clear_has_send_buffer_low_watermark();
}
inline ::google::protobuf::int32 DownloadConfigure::send_buffer_low_watermark() const {
  return send_buffer_low_watermark_;
}
inline void DownloadConfigure::set_send_buffer_low_watermark(::google::protobuf::int32 value) {
  set_has_send_buffer_low_watermark();
  send_buffer_low_watermark_ = value;
}

// optional int32 send_buffer_watermark = 73;
inline bool DownloadConfigure::has_send_buffer_watermark() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void DownloadConfigure::set_has_send_buffer_watermark() {
  _has_bits_[0] |= 0x80000000u;
}
inline void DownloadConfigure::clear_has_send_buffer_watermark() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void DownloadConfigure::clear_send_buffer_watermark() {
  send_buffer_watermark_ = 0;
  clear_has_send_buffer_watermark();
}
inline ::google::protobuf::int32 DownloadConfigure::send_buffer_watermark() const {
  return send_buffer_watermark_;
}
inline void DownloadConfigure::set_send_buffer_watermark(::google::protobuf::int32 value) {
  set_has_send_buffer_watermark();
  send_buffer_watermark_ = value;
}

// optional int32 send_socket_buffer_size = 74;
inline bool DownloadConfigure::has_send_socket_buffer_size() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void DownloadConfigure::set_has_send_socket_buffer_size() {
  _has_bits_[1] |= 0x00000001u;
}
inline void DownloadConfigure::clear_has_send_socket_buffer_size() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void DownloadConfigure::clear_send_socket_buffer_size() {
  send_socket_buffer_size_ = 0;
  clear_has_send_socket_buffer_size();
}
inline ::google::protobuf::int32 DownloadConfigure::send_socket_buffer_size() const {
  return send_socket_buffer_size_;
}
inline void DownloadConfigure::set_send_socket_buffer_size(::google::protobuf::int32 value) {
  set_has_send_socket_buffer_size();
  send_socket_buffer_size_ = value;
}

// optional int32 recv_socket_buffer_size = 75;
inline bool DownloadConfigure::has_recv_socket_buffer_size() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void DownloadConfigure::set_has_recv_socket_buffer_size() {
  _has_bits_[1] |= 0x00000002u;
}
inline void DownloadConfigure::clear_has_recv_socket_buffer_size() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void DownloadConfigure::clear_recv_socket_buffer_size() {
  recv_socket_buffer_size_ = 0;
  clear_has_recv_socket_buffer_size();
}
inline ::google::protobuf::int32 DownloadConfigure::recv_socket_buffer_size() const {
  return recv_socket_buffer_size_;
}
inline void DownloadConfigure::set_recv_socket_buffer_size(::google::protobuf::int32 value) {
  set_has_recv_socket_buffer_size();
  recv_socket_buffer_size_ = value;
}

// -------------------------------------------------------------------

// AgentConfigure

// optional string working_dir = 1;
inline bool AgentConfigure::has_working_dir() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentConfigure::set_has_working_dir() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentConfigure::clear_has_working_dir() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentConfigure::clear_working_dir() {
  if (working_dir_ != &::google::protobuf::internal::kEmptyString) {
    working_dir_->clear();
  }
  clear_has_working_dir();
}
inline const ::std::string& AgentConfigure::working_dir() const {
  return *working_dir_;
}
inline void AgentConfigure::set_working_dir(const ::std::string& value) {
  set_has_working_dir();
  if (working_dir_ == &::google::protobuf::internal::kEmptyString) {
    working_dir_ = new ::std::string;
  }
  working_dir_->assign(value);
}
inline void AgentConfigure::set_working_dir(const char* value) {
  set_has_working_dir();
  if (working_dir_ == &::google::protobuf::internal::kEmptyString) {
    working_dir_ = new ::std::string;
  }
  working_dir_->assign(value);
}
inline void AgentConfigure::set_working_dir(const char* value, size_t size) {
  set_has_working_dir();
  if (working_dir_ == &::google::protobuf::internal::kEmptyString) {
    working_dir_ = new ::std::string;
  }
  working_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentConfigure::mutable_working_dir() {
  set_has_working_dir();
  if (working_dir_ == &::google::protobuf::internal::kEmptyString) {
    working_dir_ = new ::std::string;
  }
  return working_dir_;
}
inline ::std::string* AgentConfigure::release_working_dir() {
  clear_has_working_dir();
  if (working_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = working_dir_;
    working_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string dynamic_conf_file = 2;
inline bool AgentConfigure::has_dynamic_conf_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentConfigure::set_has_dynamic_conf_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentConfigure::clear_has_dynamic_conf_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentConfigure::clear_dynamic_conf_file() {
  if (dynamic_conf_file_ != &::google::protobuf::internal::kEmptyString) {
    dynamic_conf_file_->clear();
  }
  clear_has_dynamic_conf_file();
}
inline const ::std::string& AgentConfigure::dynamic_conf_file() const {
  return *dynamic_conf_file_;
}
inline void AgentConfigure::set_dynamic_conf_file(const ::std::string& value) {
  set_has_dynamic_conf_file();
  if (dynamic_conf_file_ == &::google::protobuf::internal::kEmptyString) {
    dynamic_conf_file_ = new ::std::string;
  }
  dynamic_conf_file_->assign(value);
}
inline void AgentConfigure::set_dynamic_conf_file(const char* value) {
  set_has_dynamic_conf_file();
  if (dynamic_conf_file_ == &::google::protobuf::internal::kEmptyString) {
    dynamic_conf_file_ = new ::std::string;
  }
  dynamic_conf_file_->assign(value);
}
inline void AgentConfigure::set_dynamic_conf_file(const char* value, size_t size) {
  set_has_dynamic_conf_file();
  if (dynamic_conf_file_ == &::google::protobuf::internal::kEmptyString) {
    dynamic_conf_file_ = new ::std::string;
  }
  dynamic_conf_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentConfigure::mutable_dynamic_conf_file() {
  set_has_dynamic_conf_file();
  if (dynamic_conf_file_ == &::google::protobuf::internal::kEmptyString) {
    dynamic_conf_file_ = new ::std::string;
  }
  return dynamic_conf_file_;
}
inline ::std::string* AgentConfigure::release_dynamic_conf_file() {
  clear_has_dynamic_conf_file();
  if (dynamic_conf_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dynamic_conf_file_;
    dynamic_conf_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string resume_dir = 3;
inline bool AgentConfigure::has_resume_dir() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentConfigure::set_has_resume_dir() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentConfigure::clear_has_resume_dir() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentConfigure::clear_resume_dir() {
  if (resume_dir_ != &::google::protobuf::internal::kEmptyString) {
    resume_dir_->clear();
  }
  clear_has_resume_dir();
}
inline const ::std::string& AgentConfigure::resume_dir() const {
  return *resume_dir_;
}
inline void AgentConfigure::set_resume_dir(const ::std::string& value) {
  set_has_resume_dir();
  if (resume_dir_ == &::google::protobuf::internal::kEmptyString) {
    resume_dir_ = new ::std::string;
  }
  resume_dir_->assign(value);
}
inline void AgentConfigure::set_resume_dir(const char* value) {
  set_has_resume_dir();
  if (resume_dir_ == &::google::protobuf::internal::kEmptyString) {
    resume_dir_ = new ::std::string;
  }
  resume_dir_->assign(value);
}
inline void AgentConfigure::set_resume_dir(const char* value, size_t size) {
  set_has_resume_dir();
  if (resume_dir_ == &::google::protobuf::internal::kEmptyString) {
    resume_dir_ = new ::std::string;
  }
  resume_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentConfigure::mutable_resume_dir() {
  set_has_resume_dir();
  if (resume_dir_ == &::google::protobuf::internal::kEmptyString) {
    resume_dir_ = new ::std::string;
  }
  return resume_dir_;
}
inline ::std::string* AgentConfigure::release_resume_dir() {
  clear_has_resume_dir();
  if (resume_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resume_dir_;
    resume_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string lock_file = 4;
inline bool AgentConfigure::has_lock_file() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AgentConfigure::set_has_lock_file() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AgentConfigure::clear_has_lock_file() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AgentConfigure::clear_lock_file() {
  if (lock_file_ != &::google::protobuf::internal::kEmptyString) {
    lock_file_->clear();
  }
  clear_has_lock_file();
}
inline const ::std::string& AgentConfigure::lock_file() const {
  return *lock_file_;
}
inline void AgentConfigure::set_lock_file(const ::std::string& value) {
  set_has_lock_file();
  if (lock_file_ == &::google::protobuf::internal::kEmptyString) {
    lock_file_ = new ::std::string;
  }
  lock_file_->assign(value);
}
inline void AgentConfigure::set_lock_file(const char* value) {
  set_has_lock_file();
  if (lock_file_ == &::google::protobuf::internal::kEmptyString) {
    lock_file_ = new ::std::string;
  }
  lock_file_->assign(value);
}
inline void AgentConfigure::set_lock_file(const char* value, size_t size) {
  set_has_lock_file();
  if (lock_file_ == &::google::protobuf::internal::kEmptyString) {
    lock_file_ = new ::std::string;
  }
  lock_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentConfigure::mutable_lock_file() {
  set_has_lock_file();
  if (lock_file_ == &::google::protobuf::internal::kEmptyString) {
    lock_file_ = new ::std::string;
  }
  return lock_file_;
}
inline ::std::string* AgentConfigure::release_lock_file() {
  clear_has_lock_file();
  if (lock_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lock_file_;
    lock_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string database_file = 5;
inline bool AgentConfigure::has_database_file() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AgentConfigure::set_has_database_file() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AgentConfigure::clear_has_database_file() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AgentConfigure::clear_database_file() {
  if (database_file_ != &::google::protobuf::internal::kEmptyString) {
    database_file_->clear();
  }
  clear_has_database_file();
}
inline const ::std::string& AgentConfigure::database_file() const {
  return *database_file_;
}
inline void AgentConfigure::set_database_file(const ::std::string& value) {
  set_has_database_file();
  if (database_file_ == &::google::protobuf::internal::kEmptyString) {
    database_file_ = new ::std::string;
  }
  database_file_->assign(value);
}
inline void AgentConfigure::set_database_file(const char* value) {
  set_has_database_file();
  if (database_file_ == &::google::protobuf::internal::kEmptyString) {
    database_file_ = new ::std::string;
  }
  database_file_->assign(value);
}
inline void AgentConfigure::set_database_file(const char* value, size_t size) {
  set_has_database_file();
  if (database_file_ == &::google::protobuf::internal::kEmptyString) {
    database_file_ = new ::std::string;
  }
  database_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentConfigure::mutable_database_file() {
  set_has_database_file();
  if (database_file_ == &::google::protobuf::internal::kEmptyString) {
    database_file_ = new ::std::string;
  }
  return database_file_;
}
inline ::std::string* AgentConfigure::release_database_file() {
  clear_has_database_file();
  if (database_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = database_file_;
    database_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string socket_file = 6;
inline bool AgentConfigure::has_socket_file() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AgentConfigure::set_has_socket_file() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AgentConfigure::clear_has_socket_file() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AgentConfigure::clear_socket_file() {
  if (socket_file_ != &::google::protobuf::internal::kEmptyString) {
    socket_file_->clear();
  }
  clear_has_socket_file();
}
inline const ::std::string& AgentConfigure::socket_file() const {
  return *socket_file_;
}
inline void AgentConfigure::set_socket_file(const ::std::string& value) {
  set_has_socket_file();
  if (socket_file_ == &::google::protobuf::internal::kEmptyString) {
    socket_file_ = new ::std::string;
  }
  socket_file_->assign(value);
}
inline void AgentConfigure::set_socket_file(const char* value) {
  set_has_socket_file();
  if (socket_file_ == &::google::protobuf::internal::kEmptyString) {
    socket_file_ = new ::std::string;
  }
  socket_file_->assign(value);
}
inline void AgentConfigure::set_socket_file(const char* value, size_t size) {
  set_has_socket_file();
  if (socket_file_ == &::google::protobuf::internal::kEmptyString) {
    socket_file_ = new ::std::string;
  }
  socket_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentConfigure::mutable_socket_file() {
  set_has_socket_file();
  if (socket_file_ == &::google::protobuf::internal::kEmptyString) {
    socket_file_ = new ::std::string;
  }
  return socket_file_;
}
inline ::std::string* AgentConfigure::release_socket_file() {
  clear_has_socket_file();
  if (socket_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = socket_file_;
    socket_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string task_stat_file = 7;
inline bool AgentConfigure::has_task_stat_file() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AgentConfigure::set_has_task_stat_file() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AgentConfigure::clear_has_task_stat_file() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AgentConfigure::clear_task_stat_file() {
  if (task_stat_file_ != &::google::protobuf::internal::kEmptyString) {
    task_stat_file_->clear();
  }
  clear_has_task_stat_file();
}
inline const ::std::string& AgentConfigure::task_stat_file() const {
  return *task_stat_file_;
}
inline void AgentConfigure::set_task_stat_file(const ::std::string& value) {
  set_has_task_stat_file();
  if (task_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    task_stat_file_ = new ::std::string;
  }
  task_stat_file_->assign(value);
}
inline void AgentConfigure::set_task_stat_file(const char* value) {
  set_has_task_stat_file();
  if (task_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    task_stat_file_ = new ::std::string;
  }
  task_stat_file_->assign(value);
}
inline void AgentConfigure::set_task_stat_file(const char* value, size_t size) {
  set_has_task_stat_file();
  if (task_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    task_stat_file_ = new ::std::string;
  }
  task_stat_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentConfigure::mutable_task_stat_file() {
  set_has_task_stat_file();
  if (task_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    task_stat_file_ = new ::std::string;
  }
  return task_stat_file_;
}
inline ::std::string* AgentConfigure::release_task_stat_file() {
  clear_has_task_stat_file();
  if (task_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_stat_file_;
    task_stat_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string peer_stat_file = 8;
inline bool AgentConfigure::has_peer_stat_file() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AgentConfigure::set_has_peer_stat_file() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AgentConfigure::clear_has_peer_stat_file() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AgentConfigure::clear_peer_stat_file() {
  if (peer_stat_file_ != &::google::protobuf::internal::kEmptyString) {
    peer_stat_file_->clear();
  }
  clear_has_peer_stat_file();
}
inline const ::std::string& AgentConfigure::peer_stat_file() const {
  return *peer_stat_file_;
}
inline void AgentConfigure::set_peer_stat_file(const ::std::string& value) {
  set_has_peer_stat_file();
  if (peer_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    peer_stat_file_ = new ::std::string;
  }
  peer_stat_file_->assign(value);
}
inline void AgentConfigure::set_peer_stat_file(const char* value) {
  set_has_peer_stat_file();
  if (peer_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    peer_stat_file_ = new ::std::string;
  }
  peer_stat_file_->assign(value);
}
inline void AgentConfigure::set_peer_stat_file(const char* value, size_t size) {
  set_has_peer_stat_file();
  if (peer_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    peer_stat_file_ = new ::std::string;
  }
  peer_stat_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentConfigure::mutable_peer_stat_file() {
  set_has_peer_stat_file();
  if (peer_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    peer_stat_file_ = new ::std::string;
  }
  return peer_stat_file_;
}
inline ::std::string* AgentConfigure::release_peer_stat_file() {
  clear_has_peer_stat_file();
  if (peer_stat_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peer_stat_file_;
    peer_stat_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string download_log_file = 9;
inline bool AgentConfigure::has_download_log_file() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AgentConfigure::set_has_download_log_file() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AgentConfigure::clear_has_download_log_file() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AgentConfigure::clear_download_log_file() {
  if (download_log_file_ != &::google::protobuf::internal::kEmptyString) {
    download_log_file_->clear();
  }
  clear_has_download_log_file();
}
inline const ::std::string& AgentConfigure::download_log_file() const {
  return *download_log_file_;
}
inline void AgentConfigure::set_download_log_file(const ::std::string& value) {
  set_has_download_log_file();
  if (download_log_file_ == &::google::protobuf::internal::kEmptyString) {
    download_log_file_ = new ::std::string;
  }
  download_log_file_->assign(value);
}
inline void AgentConfigure::set_download_log_file(const char* value) {
  set_has_download_log_file();
  if (download_log_file_ == &::google::protobuf::internal::kEmptyString) {
    download_log_file_ = new ::std::string;
  }
  download_log_file_->assign(value);
}
inline void AgentConfigure::set_download_log_file(const char* value, size_t size) {
  set_has_download_log_file();
  if (download_log_file_ == &::google::protobuf::internal::kEmptyString) {
    download_log_file_ = new ::std::string;
  }
  download_log_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentConfigure::mutable_download_log_file() {
  set_has_download_log_file();
  if (download_log_file_ == &::google::protobuf::internal::kEmptyString) {
    download_log_file_ = new ::std::string;
  }
  return download_log_file_;
}
inline ::std::string* AgentConfigure::release_download_log_file() {
  clear_has_download_log_file();
  if (download_log_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = download_log_file_;
    download_log_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string tracker_conf_file = 10;
inline bool AgentConfigure::has_tracker_conf_file() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AgentConfigure::set_has_tracker_conf_file() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AgentConfigure::clear_has_tracker_conf_file() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AgentConfigure::clear_tracker_conf_file() {
  if (tracker_conf_file_ != &::google::protobuf::internal::kEmptyString) {
    tracker_conf_file_->clear();
  }
  clear_has_tracker_conf_file();
}
inline const ::std::string& AgentConfigure::tracker_conf_file() const {
  return *tracker_conf_file_;
}
inline void AgentConfigure::set_tracker_conf_file(const ::std::string& value) {
  set_has_tracker_conf_file();
  if (tracker_conf_file_ == &::google::protobuf::internal::kEmptyString) {
    tracker_conf_file_ = new ::std::string;
  }
  tracker_conf_file_->assign(value);
}
inline void AgentConfigure::set_tracker_conf_file(const char* value) {
  set_has_tracker_conf_file();
  if (tracker_conf_file_ == &::google::protobuf::internal::kEmptyString) {
    tracker_conf_file_ = new ::std::string;
  }
  tracker_conf_file_->assign(value);
}
inline void AgentConfigure::set_tracker_conf_file(const char* value, size_t size) {
  set_has_tracker_conf_file();
  if (tracker_conf_file_ == &::google::protobuf::internal::kEmptyString) {
    tracker_conf_file_ = new ::std::string;
  }
  tracker_conf_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentConfigure::mutable_tracker_conf_file() {
  set_has_tracker_conf_file();
  if (tracker_conf_file_ == &::google::protobuf::internal::kEmptyString) {
    tracker_conf_file_ = new ::std::string;
  }
  return tracker_conf_file_;
}
inline ::std::string* AgentConfigure::release_tracker_conf_file() {
  clear_has_tracker_conf_file();
  if (tracker_conf_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tracker_conf_file_;
    tracker_conf_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 listen_port = 20;
inline bool AgentConfigure::has_listen_port() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AgentConfigure::set_has_listen_port() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AgentConfigure::clear_has_listen_port() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AgentConfigure::clear_listen_port() {
  listen_port_ = 0;
  clear_has_listen_port();
}
inline ::google::protobuf::int32 AgentConfigure::listen_port() const {
  return listen_port_;
}
inline void AgentConfigure::set_listen_port(::google::protobuf::int32 value) {
  set_has_listen_port();
  listen_port_ = value;
}

// optional int32 worker_thread_num = 21;
inline bool AgentConfigure::has_worker_thread_num() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AgentConfigure::set_has_worker_thread_num() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AgentConfigure::clear_has_worker_thread_num() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AgentConfigure::clear_worker_thread_num() {
  worker_thread_num_ = 0;
  clear_has_worker_thread_num();
}
inline ::google::protobuf::int32 AgentConfigure::worker_thread_num() const {
  return worker_thread_num_;
}
inline void AgentConfigure::set_worker_thread_num(::google::protobuf::int32 value) {
  set_has_worker_thread_num();
  worker_thread_num_ = value;
}

// optional int32 db_del_interval = 22;
inline bool AgentConfigure::has_db_del_interval() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AgentConfigure::set_has_db_del_interval() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AgentConfigure::clear_has_db_del_interval() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AgentConfigure::clear_db_del_interval() {
  db_del_interval_ = 0;
  clear_has_db_del_interval();
}
inline ::google::protobuf::int32 AgentConfigure::db_del_interval() const {
  return db_del_interval_;
}
inline void AgentConfigure::set_db_del_interval(::google::protobuf::int32 value) {
  set_has_db_del_interval();
  db_del_interval_ = value;
}

// optional int32 active_seeds = 23;
inline bool AgentConfigure::has_active_seeds() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AgentConfigure::set_has_active_seeds() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AgentConfigure::clear_has_active_seeds() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AgentConfigure::clear_active_seeds() {
  active_seeds_ = 0;
  clear_has_active_seeds();
}
inline ::google::protobuf::int32 AgentConfigure::active_seeds() const {
  return active_seeds_;
}
inline void AgentConfigure::set_active_seeds(::google::protobuf::int32 value) {
  set_has_active_seeds();
  active_seeds_ = value;
}

// optional int32 max_total_meta_num = 24;
inline bool AgentConfigure::has_max_total_meta_num() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AgentConfigure::set_has_max_total_meta_num() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AgentConfigure::clear_has_max_total_meta_num() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AgentConfigure::clear_max_total_meta_num() {
  max_total_meta_num_ = 0;
  clear_has_max_total_meta_num();
}
inline ::google::protobuf::int32 AgentConfigure::max_total_meta_num() const {
  return max_total_meta_num_;
}
inline void AgentConfigure::set_max_total_meta_num(::google::protobuf::int32 value) {
  set_has_max_total_meta_num();
  max_total_meta_num_ = value;
}

// optional int32 max_total_meta_size = 25;
inline bool AgentConfigure::has_max_total_meta_size() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void AgentConfigure::set_has_max_total_meta_size() {
  _has_bits_[0] |= 0x00008000u;
}
inline void AgentConfigure::clear_has_max_total_meta_size() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void AgentConfigure::clear_max_total_meta_size() {
  max_total_meta_size_ = 0;
  clear_has_max_total_meta_size();
}
inline ::google::protobuf::int32 AgentConfigure::max_total_meta_size() const {
  return max_total_meta_size_;
}
inline void AgentConfigure::set_max_total_meta_size(::google::protobuf::int32 value) {
  set_has_max_total_meta_size();
  max_total_meta_size_ = value;
}

// optional int32 upload_limit = 51;
inline bool AgentConfigure::has_upload_limit() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void AgentConfigure::set_has_upload_limit() {
  _has_bits_[0] |= 0x00010000u;
}
inline void AgentConfigure::clear_has_upload_limit() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void AgentConfigure::clear_upload_limit() {
  upload_limit_ = 0;
  clear_has_upload_limit();
}
inline ::google::protobuf::int32 AgentConfigure::upload_limit() const {
  return upload_limit_;
}
inline void AgentConfigure::set_upload_limit(::google::protobuf::int32 value) {
  set_has_upload_limit();
  upload_limit_ = value;
}

// optional int32 download_limit = 52;
inline bool AgentConfigure::has_download_limit() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void AgentConfigure::set_has_download_limit() {
  _has_bits_[0] |= 0x00020000u;
}
inline void AgentConfigure::clear_has_download_limit() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void AgentConfigure::clear_download_limit() {
  download_limit_ = 0;
  clear_has_download_limit();
}
inline ::google::protobuf::int32 AgentConfigure::download_limit() const {
  return download_limit_;
}
inline void AgentConfigure::set_download_limit(::google::protobuf::int32 value) {
  set_has_download_limit();
  download_limit_ = value;
}

// optional int32 connection_limit = 53;
inline bool AgentConfigure::has_connection_limit() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void AgentConfigure::set_has_connection_limit() {
  _has_bits_[0] |= 0x00040000u;
}
inline void AgentConfigure::clear_has_connection_limit() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void AgentConfigure::clear_connection_limit() {
  connection_limit_ = 0;
  clear_has_connection_limit();
}
inline ::google::protobuf::int32 AgentConfigure::connection_limit() const {
  return connection_limit_;
}
inline void AgentConfigure::set_connection_limit(::google::protobuf::int32 value) {
  set_has_connection_limit();
  connection_limit_ = value;
}

// optional int32 peers_num_want = 54;
inline bool AgentConfigure::has_peers_num_want() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void AgentConfigure::set_has_peers_num_want() {
  _has_bits_[0] |= 0x00080000u;
}
inline void AgentConfigure::clear_has_peers_num_want() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void AgentConfigure::clear_peers_num_want() {
  peers_num_want_ = 0;
  clear_has_peers_num_want();
}
inline ::google::protobuf::int32 AgentConfigure::peers_num_want() const {
  return peers_num_want_;
}
inline void AgentConfigure::set_peers_num_want(::google::protobuf::int32 value) {
  set_has_peers_num_want();
  peers_num_want_ = value;
}

// optional bool disable_os_cache = 55;
inline bool AgentConfigure::has_disable_os_cache() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void AgentConfigure::set_has_disable_os_cache() {
  _has_bits_[0] |= 0x00100000u;
}
inline void AgentConfigure::clear_has_disable_os_cache() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void AgentConfigure::clear_disable_os_cache() {
  disable_os_cache_ = false;
  clear_has_disable_os_cache();
}
inline bool AgentConfigure::disable_os_cache() const {
  return disable_os_cache_;
}
inline void AgentConfigure::set_disable_os_cache(bool value) {
  set_has_disable_os_cache();
  disable_os_cache_ = value;
}

// optional int32 cache_size = 56;
inline bool AgentConfigure::has_cache_size() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void AgentConfigure::set_has_cache_size() {
  _has_bits_[0] |= 0x00200000u;
}
inline void AgentConfigure::clear_has_cache_size() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void AgentConfigure::clear_cache_size() {
  cache_size_ = 0;
  clear_has_cache_size();
}
inline ::google::protobuf::int32 AgentConfigure::cache_size() const {
  return cache_size_;
}
inline void AgentConfigure::set_cache_size(::google::protobuf::int32 value) {
  set_has_cache_size();
  cache_size_ = value;
}

// optional int32 cache_expiry = 57;
inline bool AgentConfigure::has_cache_expiry() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void AgentConfigure::set_has_cache_expiry() {
  _has_bits_[0] |= 0x00400000u;
}
inline void AgentConfigure::clear_has_cache_expiry() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void AgentConfigure::clear_cache_expiry() {
  cache_expiry_ = 0;
  clear_has_cache_expiry();
}
inline ::google::protobuf::int32 AgentConfigure::cache_expiry() const {
  return cache_expiry_;
}
inline void AgentConfigure::set_cache_expiry(::google::protobuf::int32 value) {
  set_has_cache_expiry();
  cache_expiry_ = value;
}

// optional int32 file_pool_size = 58;
inline bool AgentConfigure::has_file_pool_size() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void AgentConfigure::set_has_file_pool_size() {
  _has_bits_[0] |= 0x00800000u;
}
inline void AgentConfigure::clear_has_file_pool_size() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void AgentConfigure::clear_file_pool_size() {
  file_pool_size_ = 0;
  clear_has_file_pool_size();
}
inline ::google::protobuf::int32 AgentConfigure::file_pool_size() const {
  return file_pool_size_;
}
inline void AgentConfigure::set_file_pool_size(::google::protobuf::int32 value) {
  set_has_file_pool_size();
  file_pool_size_ = value;
}

// optional int32 max_metadata_size = 59;
inline bool AgentConfigure::has_max_metadata_size() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void AgentConfigure::set_has_max_metadata_size() {
  _has_bits_[0] |= 0x01000000u;
}
inline void AgentConfigure::clear_has_max_metadata_size() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void AgentConfigure::clear_max_metadata_size() {
  max_metadata_size_ = 0;
  clear_has_max_metadata_size();
}
inline ::google::protobuf::int32 AgentConfigure::max_metadata_size() const {
  return max_metadata_size_;
}
inline void AgentConfigure::set_max_metadata_size(::google::protobuf::int32 value) {
  set_has_max_metadata_size();
  max_metadata_size_ = value;
}

// optional int32 seeding_announce_interval = 60;
inline bool AgentConfigure::has_seeding_announce_interval() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void AgentConfigure::set_has_seeding_announce_interval() {
  _has_bits_[0] |= 0x02000000u;
}
inline void AgentConfigure::clear_has_seeding_announce_interval() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void AgentConfigure::clear_seeding_announce_interval() {
  seeding_announce_interval_ = 0;
  clear_has_seeding_announce_interval();
}
inline ::google::protobuf::int32 AgentConfigure::seeding_announce_interval() const {
  return seeding_announce_interval_;
}
inline void AgentConfigure::set_seeding_announce_interval(::google::protobuf::int32 value) {
  set_has_seeding_announce_interval();
  seeding_announce_interval_ = value;
}

// optional int32 min_reconnect_time = 61;
inline bool AgentConfigure::has_min_reconnect_time() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void AgentConfigure::set_has_min_reconnect_time() {
  _has_bits_[0] |= 0x04000000u;
}
inline void AgentConfigure::clear_has_min_reconnect_time() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void AgentConfigure::clear_min_reconnect_time() {
  min_reconnect_time_ = 0;
  clear_has_min_reconnect_time();
}
inline ::google::protobuf::int32 AgentConfigure::min_reconnect_time() const {
  return min_reconnect_time_;
}
inline void AgentConfigure::set_min_reconnect_time(::google::protobuf::int32 value) {
  set_has_min_reconnect_time();
  min_reconnect_time_ = value;
}

// optional int32 peer_connect_timeout = 62;
inline bool AgentConfigure::has_peer_connect_timeout() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void AgentConfigure::set_has_peer_connect_timeout() {
  _has_bits_[0] |= 0x08000000u;
}
inline void AgentConfigure::clear_has_peer_connect_timeout() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void AgentConfigure::clear_peer_connect_timeout() {
  peer_connect_timeout_ = 0;
  clear_has_peer_connect_timeout();
}
inline ::google::protobuf::int32 AgentConfigure::peer_connect_timeout() const {
  return peer_connect_timeout_;
}
inline void AgentConfigure::set_peer_connect_timeout(::google::protobuf::int32 value) {
  set_has_peer_connect_timeout();
  peer_connect_timeout_ = value;
}

// optional int32 read_cache_line_size = 63;
inline bool AgentConfigure::has_read_cache_line_size() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void AgentConfigure::set_has_read_cache_line_size() {
  _has_bits_[0] |= 0x10000000u;
}
inline void AgentConfigure::clear_has_read_cache_line_size() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void AgentConfigure::clear_read_cache_line_size() {
  read_cache_line_size_ = 0;
  clear_has_read_cache_line_size();
}
inline ::google::protobuf::int32 AgentConfigure::read_cache_line_size() const {
  return read_cache_line_size_;
}
inline void AgentConfigure::set_read_cache_line_size(::google::protobuf::int32 value) {
  set_has_read_cache_line_size();
  read_cache_line_size_ = value;
}

// optional int32 write_cache_line_size = 64;
inline bool AgentConfigure::has_write_cache_line_size() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void AgentConfigure::set_has_write_cache_line_size() {
  _has_bits_[0] |= 0x20000000u;
}
inline void AgentConfigure::clear_has_write_cache_line_size() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void AgentConfigure::clear_write_cache_line_size() {
  write_cache_line_size_ = 0;
  clear_has_write_cache_line_size();
}
inline ::google::protobuf::int32 AgentConfigure::write_cache_line_size() const {
  return write_cache_line_size_;
}
inline void AgentConfigure::set_write_cache_line_size(::google::protobuf::int32 value) {
  set_has_write_cache_line_size();
  write_cache_line_size_ = value;
}

// optional bool lock_disk_cache = 65;
inline bool AgentConfigure::has_lock_disk_cache() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void AgentConfigure::set_has_lock_disk_cache() {
  _has_bits_[0] |= 0x40000000u;
}
inline void AgentConfigure::clear_has_lock_disk_cache() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void AgentConfigure::clear_lock_disk_cache() {
  lock_disk_cache_ = false;
  clear_has_lock_disk_cache();
}
inline bool AgentConfigure::lock_disk_cache() const {
  return lock_disk_cache_;
}
inline void AgentConfigure::set_lock_disk_cache(bool value) {
  set_has_lock_disk_cache();
  lock_disk_cache_ = value;
}

// optional bool suggest_mode = 66;
inline bool AgentConfigure::has_suggest_mode() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void AgentConfigure::set_has_suggest_mode() {
  _has_bits_[0] |= 0x80000000u;
}
inline void AgentConfigure::clear_has_suggest_mode() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void AgentConfigure::clear_suggest_mode() {
  suggest_mode_ = false;
  clear_has_suggest_mode();
}
inline bool AgentConfigure::suggest_mode() const {
  return suggest_mode_;
}
inline void AgentConfigure::set_suggest_mode(bool value) {
  set_has_suggest_mode();
  suggest_mode_ = value;
}

// optional int32 max_queued_disk_bytes = 67;
inline bool AgentConfigure::has_max_queued_disk_bytes() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void AgentConfigure::set_has_max_queued_disk_bytes() {
  _has_bits_[1] |= 0x00000001u;
}
inline void AgentConfigure::clear_has_max_queued_disk_bytes() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void AgentConfigure::clear_max_queued_disk_bytes() {
  max_queued_disk_bytes_ = 0;
  clear_has_max_queued_disk_bytes();
}
inline ::google::protobuf::int32 AgentConfigure::max_queued_disk_bytes() const {
  return max_queued_disk_bytes_;
}
inline void AgentConfigure::set_max_queued_disk_bytes(::google::protobuf::int32 value) {
  set_has_max_queued_disk_bytes();
  max_queued_disk_bytes_ = value;
}

// optional int32 max_out_request_queue = 68;
inline bool AgentConfigure::has_max_out_request_queue() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void AgentConfigure::set_has_max_out_request_queue() {
  _has_bits_[1] |= 0x00000002u;
}
inline void AgentConfigure::clear_has_max_out_request_queue() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void AgentConfigure::clear_max_out_request_queue() {
  max_out_request_queue_ = 0;
  clear_has_max_out_request_queue();
}
inline ::google::protobuf::int32 AgentConfigure::max_out_request_queue() const {
  return max_out_request_queue_;
}
inline void AgentConfigure::set_max_out_request_queue(::google::protobuf::int32 value) {
  set_has_max_out_request_queue();
  max_out_request_queue_ = value;
}

// optional int32 max_allowed_in_request_queue = 69;
inline bool AgentConfigure::has_max_allowed_in_request_queue() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void AgentConfigure::set_has_max_allowed_in_request_queue() {
  _has_bits_[1] |= 0x00000004u;
}
inline void AgentConfigure::clear_has_max_allowed_in_request_queue() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void AgentConfigure::clear_max_allowed_in_request_queue() {
  max_allowed_in_request_queue_ = 0;
  clear_has_max_allowed_in_request_queue();
}
inline ::google::protobuf::int32 AgentConfigure::max_allowed_in_request_queue() const {
  return max_allowed_in_request_queue_;
}
inline void AgentConfigure::set_max_allowed_in_request_queue(::google::protobuf::int32 value) {
  set_has_max_allowed_in_request_queue();
  max_allowed_in_request_queue_ = value;
}

// optional int32 whole_pieces_threshold = 70;
inline bool AgentConfigure::has_whole_pieces_threshold() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void AgentConfigure::set_has_whole_pieces_threshold() {
  _has_bits_[1] |= 0x00000008u;
}
inline void AgentConfigure::clear_has_whole_pieces_threshold() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void AgentConfigure::clear_whole_pieces_threshold() {
  whole_pieces_threshold_ = 0;
  clear_has_whole_pieces_threshold();
}
inline ::google::protobuf::int32 AgentConfigure::whole_pieces_threshold() const {
  return whole_pieces_threshold_;
}
inline void AgentConfigure::set_whole_pieces_threshold(::google::protobuf::int32 value) {
  set_has_whole_pieces_threshold();
  whole_pieces_threshold_ = value;
}

// optional int32 request_queue_time = 71;
inline bool AgentConfigure::has_request_queue_time() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void AgentConfigure::set_has_request_queue_time() {
  _has_bits_[1] |= 0x00000010u;
}
inline void AgentConfigure::clear_has_request_queue_time() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void AgentConfigure::clear_request_queue_time() {
  request_queue_time_ = 0;
  clear_has_request_queue_time();
}
inline ::google::protobuf::int32 AgentConfigure::request_queue_time() const {
  return request_queue_time_;
}
inline void AgentConfigure::set_request_queue_time(::google::protobuf::int32 value) {
  set_has_request_queue_time();
  request_queue_time_ = value;
}

// optional int32 send_buffer_low_watermark = 72;
inline bool AgentConfigure::has_send_buffer_low_watermark() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void AgentConfigure::set_has_send_buffer_low_watermark() {
  _has_bits_[1] |= 0x00000020u;
}
inline void AgentConfigure::clear_has_send_buffer_low_watermark() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void AgentConfigure::clear_send_buffer_low_watermark() {
  send_buffer_low_watermark_ = 0;
  clear_has_send_buffer_low_watermark();
}
inline ::google::protobuf::int32 AgentConfigure::send_buffer_low_watermark() const {
  return send_buffer_low_watermark_;
}
inline void AgentConfigure::set_send_buffer_low_watermark(::google::protobuf::int32 value) {
  set_has_send_buffer_low_watermark();
  send_buffer_low_watermark_ = value;
}

// optional int32 send_buffer_watermark = 73;
inline bool AgentConfigure::has_send_buffer_watermark() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void AgentConfigure::set_has_send_buffer_watermark() {
  _has_bits_[1] |= 0x00000040u;
}
inline void AgentConfigure::clear_has_send_buffer_watermark() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void AgentConfigure::clear_send_buffer_watermark() {
  send_buffer_watermark_ = 0;
  clear_has_send_buffer_watermark();
}
inline ::google::protobuf::int32 AgentConfigure::send_buffer_watermark() const {
  return send_buffer_watermark_;
}
inline void AgentConfigure::set_send_buffer_watermark(::google::protobuf::int32 value) {
  set_has_send_buffer_watermark();
  send_buffer_watermark_ = value;
}

// optional int32 send_socket_buffer_size = 74;
inline bool AgentConfigure::has_send_socket_buffer_size() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void AgentConfigure::set_has_send_socket_buffer_size() {
  _has_bits_[1] |= 0x00000080u;
}
inline void AgentConfigure::clear_has_send_socket_buffer_size() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void AgentConfigure::clear_send_socket_buffer_size() {
  send_socket_buffer_size_ = 0;
  clear_has_send_socket_buffer_size();
}
inline ::google::protobuf::int32 AgentConfigure::send_socket_buffer_size() const {
  return send_socket_buffer_size_;
}
inline void AgentConfigure::set_send_socket_buffer_size(::google::protobuf::int32 value) {
  set_has_send_socket_buffer_size();
  send_socket_buffer_size_ = value;
}

// optional int32 recv_socket_buffer_size = 75;
inline bool AgentConfigure::has_recv_socket_buffer_size() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void AgentConfigure::set_has_recv_socket_buffer_size() {
  _has_bits_[1] |= 0x00000100u;
}
inline void AgentConfigure::clear_has_recv_socket_buffer_size() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void AgentConfigure::clear_recv_socket_buffer_size() {
  recv_socket_buffer_size_ = 0;
  clear_has_recv_socket_buffer_size();
}
inline ::google::protobuf::int32 AgentConfigure::recv_socket_buffer_size() const {
  return recv_socket_buffer_size_;
}
inline void AgentConfigure::set_recv_socket_buffer_size(::google::protobuf::int32 value) {
  set_has_recv_socket_buffer_size();
  recv_socket_buffer_size_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace message
}  // namespace bbts

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_configure_2eproto__INCLUDED
