// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GroupConf.proto

#ifndef PROTOBUF_GroupConf_2eproto__INCLUDED
#define PROTOBUF_GroupConf_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace bbts {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GroupConf_2eproto();
void protobuf_AssignDesc_GroupConf_2eproto();
void protobuf_ShutdownFile_GroupConf_2eproto();

class GroupConfig;

// ===================================================================

class GroupConfig : public ::google::protobuf::Message {
 public:
  GroupConfig();
  virtual ~GroupConfig();
  
  GroupConfig(const GroupConfig& from);
  
  inline GroupConfig& operator=(const GroupConfig& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupConfig& default_instance();
  
  void Swap(GroupConfig* other);
  
  // implements Message ----------------------------------------------
  
  GroupConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupConfig& from);
  void MergeFrom(const GroupConfig& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 timeout = 1 [default = -1];
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 1;
  inline ::google::protobuf::int32 timeout() const;
  inline void set_timeout(::google::protobuf::int32 value);
  
  // required int32 upload_rate_limit = 2 [default = 100];
  inline bool has_upload_rate_limit() const;
  inline void clear_upload_rate_limit();
  static const int kUploadRateLimitFieldNumber = 2;
  inline ::google::protobuf::int32 upload_rate_limit() const;
  inline void set_upload_rate_limit(::google::protobuf::int32 value);
  
  // required int32 download_rate_limit = 3 [default = 100];
  inline bool has_download_rate_limit() const;
  inline void clear_download_rate_limit();
  static const int kDownloadRateLimitFieldNumber = 3;
  inline ::google::protobuf::int32 download_rate_limit() const;
  inline void set_download_rate_limit(::google::protobuf::int32 value);
  
  // required int32 connection_limit = 4 [default = 8000];
  inline bool has_connection_limit() const;
  inline void clear_connection_limit();
  static const int kConnectionLimitFieldNumber = 4;
  inline ::google::protobuf::int32 connection_limit() const;
  inline void set_connection_limit(::google::protobuf::int32 value);
  
  // optional int32 finished_timeout = 5 [default = 3600];
  inline bool has_finished_timeout() const;
  inline void clear_finished_timeout();
  static const int kFinishedTimeoutFieldNumber = 5;
  inline ::google::protobuf::int32 finished_timeout() const;
  inline void set_finished_timeout(::google::protobuf::int32 value);
  
  // optional int32 max_cluster_thread_num = 6 [default = 10];
  inline bool has_max_cluster_thread_num() const;
  inline void clear_max_cluster_thread_num();
  static const int kMaxClusterThreadNumFieldNumber = 6;
  inline ::google::protobuf::int32 max_cluster_thread_num() const;
  inline void set_max_cluster_thread_num(::google::protobuf::int32 value);
  
  // optional bool is_allow_all_add = 7 [default = false];
  inline bool has_is_allow_all_add() const;
  inline void clear_is_allow_all_add();
  static const int kIsAllowAllAddFieldNumber = 7;
  inline bool is_allow_all_add() const;
  inline void set_is_allow_all_add(bool value);
  
  // optional string absolute_path = 11;
  inline bool has_absolute_path() const;
  inline void clear_absolute_path();
  static const int kAbsolutePathFieldNumber = 11;
  inline const ::std::string& absolute_path() const;
  inline void set_absolute_path(const ::std::string& value);
  inline void set_absolute_path(const char* value);
  inline void set_absolute_path(const char* value, size_t size);
  inline ::std::string* mutable_absolute_path();
  inline ::std::string* release_absolute_path();
  
  // optional string group_data_path = 12 [default = "/bbts-group-data"];
  inline bool has_group_data_path() const;
  inline void clear_group_data_path();
  static const int kGroupDataPathFieldNumber = 12;
  inline const ::std::string& group_data_path() const;
  inline void set_group_data_path(const ::std::string& value);
  inline void set_group_data_path(const char* value);
  inline void set_group_data_path(const char* value, size_t size);
  inline ::std::string* mutable_group_data_path();
  inline ::std::string* release_group_data_path();
  
  // optional string log_file = 13 [default = "bbts-group.log"];
  inline bool has_log_file() const;
  inline void clear_log_file();
  static const int kLogFileFieldNumber = 13;
  inline const ::std::string& log_file() const;
  inline void set_log_file(const ::std::string& value);
  inline void set_log_file(const char* value);
  inline void set_log_file(const char* value, size_t size);
  inline ::std::string* mutable_log_file();
  inline ::std::string* release_log_file();
  
  // optional string resume_dir = 14 [default = "bbts-group.resume"];
  inline bool has_resume_dir() const;
  inline void clear_resume_dir();
  static const int kResumeDirFieldNumber = 14;
  inline const ::std::string& resume_dir() const;
  inline void set_resume_dir(const ::std::string& value);
  inline void set_resume_dir(const char* value);
  inline void set_resume_dir(const char* value, size_t size);
  inline ::std::string* mutable_resume_dir();
  inline ::std::string* release_resume_dir();
  
  // optional string lock_file = 15 [default = "bbts-group.lock"];
  inline bool has_lock_file() const;
  inline void clear_lock_file();
  static const int kLockFileFieldNumber = 15;
  inline const ::std::string& lock_file() const;
  inline void set_lock_file(const ::std::string& value);
  inline void set_lock_file(const char* value);
  inline void set_lock_file(const char* value, size_t size);
  inline ::std::string* mutable_lock_file();
  inline ::std::string* release_lock_file();
  
  // optional string unix_socket = 16 [default = "bbts-group.sock"];
  inline bool has_unix_socket() const;
  inline void clear_unix_socket();
  static const int kUnixSocketFieldNumber = 16;
  inline const ::std::string& unix_socket() const;
  inline void set_unix_socket(const ::std::string& value);
  inline void set_unix_socket(const char* value);
  inline void set_unix_socket(const char* value, size_t size);
  inline ::std::string* mutable_unix_socket();
  inline ::std::string* release_unix_socket();
  
  // optional string peer_stat_log_file = 17 [default = "bbts-group.peer"];
  inline bool has_peer_stat_log_file() const;
  inline void clear_peer_stat_log_file();
  static const int kPeerStatLogFileFieldNumber = 17;
  inline const ::std::string& peer_stat_log_file() const;
  inline void set_peer_stat_log_file(const ::std::string& value);
  inline void set_peer_stat_log_file(const char* value);
  inline void set_peer_stat_log_file(const char* value, size_t size);
  inline ::std::string* mutable_peer_stat_log_file();
  inline ::std::string* release_peer_stat_log_file();
  
  // optional int32 max_metadata_size = 31 [default = 50];
  inline bool has_max_metadata_size() const;
  inline void clear_max_metadata_size();
  static const int kMaxMetadataSizeFieldNumber = 31;
  inline ::google::protobuf::int32 max_metadata_size() const;
  inline void set_max_metadata_size(::google::protobuf::int32 value);
  
  // optional int32 peers_num_want = 32 [default = 25];
  inline bool has_peers_num_want() const;
  inline void clear_peers_num_want();
  static const int kPeersNumWantFieldNumber = 32;
  inline ::google::protobuf::int32 peers_num_want() const;
  inline void set_peers_num_want(::google::protobuf::int32 value);
  
  // optional bool disk_io_read_mode = 33 [default = true];
  inline bool has_disk_io_read_mode() const;
  inline void clear_disk_io_read_mode();
  static const int kDiskIoReadModeFieldNumber = 33;
  inline bool disk_io_read_mode() const;
  inline void set_disk_io_read_mode(bool value);
  
  // optional bool disk_io_write_mode = 34 [default = true];
  inline bool has_disk_io_write_mode() const;
  inline void clear_disk_io_write_mode();
  static const int kDiskIoWriteModeFieldNumber = 34;
  inline bool disk_io_write_mode() const;
  inline void set_disk_io_write_mode(bool value);
  
  // optional int32 seed_announce_interval = 35 [default = 1800];
  inline bool has_seed_announce_interval() const;
  inline void clear_seed_announce_interval();
  static const int kSeedAnnounceIntervalFieldNumber = 35;
  inline ::google::protobuf::int32 seed_announce_interval() const;
  inline void set_seed_announce_interval(::google::protobuf::int32 value);
  
  // optional int32 min_reconnect_time = 36 [default = 1];
  inline bool has_min_reconnect_time() const;
  inline void clear_min_reconnect_time();
  static const int kMinReconnectTimeFieldNumber = 36;
  inline ::google::protobuf::int32 min_reconnect_time() const;
  inline void set_min_reconnect_time(::google::protobuf::int32 value);
  
  // optional int32 max_queued_disk_bytes = 37 [default = 20];
  inline bool has_max_queued_disk_bytes() const;
  inline void clear_max_queued_disk_bytes();
  static const int kMaxQueuedDiskBytesFieldNumber = 37;
  inline ::google::protobuf::int32 max_queued_disk_bytes() const;
  inline void set_max_queued_disk_bytes(::google::protobuf::int32 value);
  
  // optional int32 max_out_request_queue = 38 [default = 1500];
  inline bool has_max_out_request_queue() const;
  inline void clear_max_out_request_queue();
  static const int kMaxOutRequestQueueFieldNumber = 38;
  inline ::google::protobuf::int32 max_out_request_queue() const;
  inline void set_max_out_request_queue(::google::protobuf::int32 value);
  
  // optional int32 max_allowed_in_request_queue = 39 [default = 2000];
  inline bool has_max_allowed_in_request_queue() const;
  inline void clear_max_allowed_in_request_queue();
  static const int kMaxAllowedInRequestQueueFieldNumber = 39;
  inline ::google::protobuf::int32 max_allowed_in_request_queue() const;
  inline void set_max_allowed_in_request_queue(::google::protobuf::int32 value);
  
  // optional int32 whole_pieces_threshold = 40 [default = 20];
  inline bool has_whole_pieces_threshold() const;
  inline void clear_whole_pieces_threshold();
  static const int kWholePiecesThresholdFieldNumber = 40;
  inline ::google::protobuf::int32 whole_pieces_threshold() const;
  inline void set_whole_pieces_threshold(::google::protobuf::int32 value);
  
  // optional int32 request_queue_time = 41 [default = 3];
  inline bool has_request_queue_time() const;
  inline void clear_request_queue_time();
  static const int kRequestQueueTimeFieldNumber = 41;
  inline ::google::protobuf::int32 request_queue_time() const;
  inline void set_request_queue_time(::google::protobuf::int32 value);
  
  // optional int32 cache_size = 42 [default = 128];
  inline bool has_cache_size() const;
  inline void clear_cache_size();
  static const int kCacheSizeFieldNumber = 42;
  inline ::google::protobuf::int32 cache_size() const;
  inline void set_cache_size(::google::protobuf::int32 value);
  
  // optional int32 cache_expiry = 43 [default = 300];
  inline bool has_cache_expiry() const;
  inline void clear_cache_expiry();
  static const int kCacheExpiryFieldNumber = 43;
  inline ::google::protobuf::int32 cache_expiry() const;
  inline void set_cache_expiry(::google::protobuf::int32 value);
  
  // optional int32 read_cache_line_size = 44 [default = 32];
  inline bool has_read_cache_line_size() const;
  inline void clear_read_cache_line_size();
  static const int kReadCacheLineSizeFieldNumber = 44;
  inline ::google::protobuf::int32 read_cache_line_size() const;
  inline void set_read_cache_line_size(::google::protobuf::int32 value);
  
  // optional int32 write_cache_line_size = 45 [default = 32];
  inline bool has_write_cache_line_size() const;
  inline void clear_write_cache_line_size();
  static const int kWriteCacheLineSizeFieldNumber = 45;
  inline ::google::protobuf::int32 write_cache_line_size() const;
  inline void set_write_cache_line_size(::google::protobuf::int32 value);
  
  // optional int32 file_pool_size = 46 [default = 500];
  inline bool has_file_pool_size() const;
  inline void clear_file_pool_size();
  static const int kFilePoolSizeFieldNumber = 46;
  inline ::google::protobuf::int32 file_pool_size() const;
  inline void set_file_pool_size(::google::protobuf::int32 value);
  
  // optional int32 send_buffer_watermark = 47 [default = 10];
  inline bool has_send_buffer_watermark() const;
  inline void clear_send_buffer_watermark();
  static const int kSendBufferWatermarkFieldNumber = 47;
  inline ::google::protobuf::int32 send_buffer_watermark() const;
  inline void set_send_buffer_watermark(::google::protobuf::int32 value);
  
  // optional int32 send_buffer_low_watermark = 48 [default = 1024];
  inline bool has_send_buffer_low_watermark() const;
  inline void clear_send_buffer_low_watermark();
  static const int kSendBufferLowWatermarkFieldNumber = 48;
  inline ::google::protobuf::int32 send_buffer_low_watermark() const;
  inline void set_send_buffer_low_watermark(::google::protobuf::int32 value);
  
  // optional int32 send_socket_buffer_size = 49 [default = 2048];
  inline bool has_send_socket_buffer_size() const;
  inline void clear_send_socket_buffer_size();
  static const int kSendSocketBufferSizeFieldNumber = 49;
  inline ::google::protobuf::int32 send_socket_buffer_size() const;
  inline void set_send_socket_buffer_size(::google::protobuf::int32 value);
  
  // optional int32 recv_socket_buffer_size = 50 [default = 2048];
  inline bool has_recv_socket_buffer_size() const;
  inline void clear_recv_socket_buffer_size();
  static const int kRecvSocketBufferSizeFieldNumber = 50;
  inline ::google::protobuf::int32 recv_socket_buffer_size() const;
  inline void set_recv_socket_buffer_size(::google::protobuf::int32 value);
  
  // optional int32 active_seeds = 51 [default = 32000];
  inline bool has_active_seeds() const;
  inline void clear_active_seeds();
  static const int kActiveSeedsFieldNumber = 51;
  inline ::google::protobuf::int32 active_seeds() const;
  inline void set_active_seeds(::google::protobuf::int32 value);
  
  // optional int32 active_limit = 52 [default = 32000];
  inline bool has_active_limit() const;
  inline void clear_active_limit();
  static const int kActiveLimitFieldNumber = 52;
  inline ::google::protobuf::int32 active_limit() const;
  inline void set_active_limit(::google::protobuf::int32 value);
  
  // optional int32 active_downloads = 53 [default = 32000];
  inline bool has_active_downloads() const;
  inline void clear_active_downloads();
  static const int kActiveDownloadsFieldNumber = 53;
  inline ::google::protobuf::int32 active_downloads() const;
  inline void set_active_downloads(::google::protobuf::int32 value);
  
  // optional bool suggest_mode = 54 [default = true];
  inline bool has_suggest_mode() const;
  inline void clear_suggest_mode();
  static const int kSuggestModeFieldNumber = 54;
  inline bool suggest_mode() const;
  inline void set_suggest_mode(bool value);
  
  // optional int32 listen_port = 55 [default = 18000];
  inline bool has_listen_port() const;
  inline void clear_listen_port();
  static const int kListenPortFieldNumber = 55;
  inline ::google::protobuf::int32 listen_port() const;
  inline void set_listen_port(::google::protobuf::int32 value);
  
  // optional int32 peer_connection_timeout = 56 [default = 3];
  inline bool has_peer_connection_timeout() const;
  inline void clear_peer_connection_timeout();
  static const int kPeerConnectionTimeoutFieldNumber = 56;
  inline ::google::protobuf::int32 peer_connection_timeout() const;
  inline void set_peer_connection_timeout(::google::protobuf::int32 value);
  
  // optional bool disable_os_cache = 57 [default = false];
  inline bool has_disable_os_cache() const;
  inline void clear_disable_os_cache();
  static const int kDisableOsCacheFieldNumber = 57;
  inline bool disable_os_cache() const;
  inline void set_disable_os_cache(bool value);
  
  // @@protoc_insertion_point(class_scope:bbts.GroupConfig)
 private:
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_upload_rate_limit();
  inline void clear_has_upload_rate_limit();
  inline void set_has_download_rate_limit();
  inline void clear_has_download_rate_limit();
  inline void set_has_connection_limit();
  inline void clear_has_connection_limit();
  inline void set_has_finished_timeout();
  inline void clear_has_finished_timeout();
  inline void set_has_max_cluster_thread_num();
  inline void clear_has_max_cluster_thread_num();
  inline void set_has_is_allow_all_add();
  inline void clear_has_is_allow_all_add();
  inline void set_has_absolute_path();
  inline void clear_has_absolute_path();
  inline void set_has_group_data_path();
  inline void clear_has_group_data_path();
  inline void set_has_log_file();
  inline void clear_has_log_file();
  inline void set_has_resume_dir();
  inline void clear_has_resume_dir();
  inline void set_has_lock_file();
  inline void clear_has_lock_file();
  inline void set_has_unix_socket();
  inline void clear_has_unix_socket();
  inline void set_has_peer_stat_log_file();
  inline void clear_has_peer_stat_log_file();
  inline void set_has_max_metadata_size();
  inline void clear_has_max_metadata_size();
  inline void set_has_peers_num_want();
  inline void clear_has_peers_num_want();
  inline void set_has_disk_io_read_mode();
  inline void clear_has_disk_io_read_mode();
  inline void set_has_disk_io_write_mode();
  inline void clear_has_disk_io_write_mode();
  inline void set_has_seed_announce_interval();
  inline void clear_has_seed_announce_interval();
  inline void set_has_min_reconnect_time();
  inline void clear_has_min_reconnect_time();
  inline void set_has_max_queued_disk_bytes();
  inline void clear_has_max_queued_disk_bytes();
  inline void set_has_max_out_request_queue();
  inline void clear_has_max_out_request_queue();
  inline void set_has_max_allowed_in_request_queue();
  inline void clear_has_max_allowed_in_request_queue();
  inline void set_has_whole_pieces_threshold();
  inline void clear_has_whole_pieces_threshold();
  inline void set_has_request_queue_time();
  inline void clear_has_request_queue_time();
  inline void set_has_cache_size();
  inline void clear_has_cache_size();
  inline void set_has_cache_expiry();
  inline void clear_has_cache_expiry();
  inline void set_has_read_cache_line_size();
  inline void clear_has_read_cache_line_size();
  inline void set_has_write_cache_line_size();
  inline void clear_has_write_cache_line_size();
  inline void set_has_file_pool_size();
  inline void clear_has_file_pool_size();
  inline void set_has_send_buffer_watermark();
  inline void clear_has_send_buffer_watermark();
  inline void set_has_send_buffer_low_watermark();
  inline void clear_has_send_buffer_low_watermark();
  inline void set_has_send_socket_buffer_size();
  inline void clear_has_send_socket_buffer_size();
  inline void set_has_recv_socket_buffer_size();
  inline void clear_has_recv_socket_buffer_size();
  inline void set_has_active_seeds();
  inline void clear_has_active_seeds();
  inline void set_has_active_limit();
  inline void clear_has_active_limit();
  inline void set_has_active_downloads();
  inline void clear_has_active_downloads();
  inline void set_has_suggest_mode();
  inline void clear_has_suggest_mode();
  inline void set_has_listen_port();
  inline void clear_has_listen_port();
  inline void set_has_peer_connection_timeout();
  inline void clear_has_peer_connection_timeout();
  inline void set_has_disable_os_cache();
  inline void clear_has_disable_os_cache();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 timeout_;
  ::google::protobuf::int32 upload_rate_limit_;
  ::google::protobuf::int32 download_rate_limit_;
  ::google::protobuf::int32 connection_limit_;
  ::google::protobuf::int32 finished_timeout_;
  ::google::protobuf::int32 max_cluster_thread_num_;
  ::std::string* absolute_path_;
  ::std::string* group_data_path_;
  static const ::std::string _default_group_data_path_;
  ::std::string* log_file_;
  static const ::std::string _default_log_file_;
  ::std::string* resume_dir_;
  static const ::std::string _default_resume_dir_;
  ::std::string* lock_file_;
  static const ::std::string _default_lock_file_;
  ::std::string* unix_socket_;
  static const ::std::string _default_unix_socket_;
  ::std::string* peer_stat_log_file_;
  static const ::std::string _default_peer_stat_log_file_;
  ::google::protobuf::int32 max_metadata_size_;
  ::google::protobuf::int32 peers_num_want_;
  ::google::protobuf::int32 seed_announce_interval_;
  ::google::protobuf::int32 min_reconnect_time_;
  bool is_allow_all_add_;
  bool disk_io_read_mode_;
  bool disk_io_write_mode_;
  bool suggest_mode_;
  ::google::protobuf::int32 max_queued_disk_bytes_;
  ::google::protobuf::int32 max_out_request_queue_;
  ::google::protobuf::int32 max_allowed_in_request_queue_;
  ::google::protobuf::int32 whole_pieces_threshold_;
  ::google::protobuf::int32 request_queue_time_;
  ::google::protobuf::int32 cache_size_;
  ::google::protobuf::int32 cache_expiry_;
  ::google::protobuf::int32 read_cache_line_size_;
  ::google::protobuf::int32 write_cache_line_size_;
  ::google::protobuf::int32 file_pool_size_;
  ::google::protobuf::int32 send_buffer_watermark_;
  ::google::protobuf::int32 send_buffer_low_watermark_;
  ::google::protobuf::int32 send_socket_buffer_size_;
  ::google::protobuf::int32 recv_socket_buffer_size_;
  ::google::protobuf::int32 active_seeds_;
  ::google::protobuf::int32 active_limit_;
  ::google::protobuf::int32 active_downloads_;
  ::google::protobuf::int32 listen_port_;
  ::google::protobuf::int32 peer_connection_timeout_;
  bool disable_os_cache_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(41 + 31) / 32];
  
  friend void  protobuf_AddDesc_GroupConf_2eproto();
  friend void protobuf_AssignDesc_GroupConf_2eproto();
  friend void protobuf_ShutdownFile_GroupConf_2eproto();
  
  void InitAsDefaultInstance();
  static GroupConfig* default_instance_;
};
// ===================================================================


// ===================================================================

// GroupConfig

// required int32 timeout = 1 [default = -1];
inline bool GroupConfig::has_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupConfig::set_has_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupConfig::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupConfig::clear_timeout() {
  timeout_ = -1;
  clear_has_timeout();
}
inline ::google::protobuf::int32 GroupConfig::timeout() const {
  return timeout_;
}
inline void GroupConfig::set_timeout(::google::protobuf::int32 value) {
  set_has_timeout();
  timeout_ = value;
}

// required int32 upload_rate_limit = 2 [default = 100];
inline bool GroupConfig::has_upload_rate_limit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupConfig::set_has_upload_rate_limit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupConfig::clear_has_upload_rate_limit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupConfig::clear_upload_rate_limit() {
  upload_rate_limit_ = 100;
  clear_has_upload_rate_limit();
}
inline ::google::protobuf::int32 GroupConfig::upload_rate_limit() const {
  return upload_rate_limit_;
}
inline void GroupConfig::set_upload_rate_limit(::google::protobuf::int32 value) {
  set_has_upload_rate_limit();
  upload_rate_limit_ = value;
}

// required int32 download_rate_limit = 3 [default = 100];
inline bool GroupConfig::has_download_rate_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupConfig::set_has_download_rate_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupConfig::clear_has_download_rate_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupConfig::clear_download_rate_limit() {
  download_rate_limit_ = 100;
  clear_has_download_rate_limit();
}
inline ::google::protobuf::int32 GroupConfig::download_rate_limit() const {
  return download_rate_limit_;
}
inline void GroupConfig::set_download_rate_limit(::google::protobuf::int32 value) {
  set_has_download_rate_limit();
  download_rate_limit_ = value;
}

// required int32 connection_limit = 4 [default = 8000];
inline bool GroupConfig::has_connection_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupConfig::set_has_connection_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupConfig::clear_has_connection_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupConfig::clear_connection_limit() {
  connection_limit_ = 8000;
  clear_has_connection_limit();
}
inline ::google::protobuf::int32 GroupConfig::connection_limit() const {
  return connection_limit_;
}
inline void GroupConfig::set_connection_limit(::google::protobuf::int32 value) {
  set_has_connection_limit();
  connection_limit_ = value;
}

// optional int32 finished_timeout = 5 [default = 3600];
inline bool GroupConfig::has_finished_timeout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupConfig::set_has_finished_timeout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupConfig::clear_has_finished_timeout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupConfig::clear_finished_timeout() {
  finished_timeout_ = 3600;
  clear_has_finished_timeout();
}
inline ::google::protobuf::int32 GroupConfig::finished_timeout() const {
  return finished_timeout_;
}
inline void GroupConfig::set_finished_timeout(::google::protobuf::int32 value) {
  set_has_finished_timeout();
  finished_timeout_ = value;
}

// optional int32 max_cluster_thread_num = 6 [default = 10];
inline bool GroupConfig::has_max_cluster_thread_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupConfig::set_has_max_cluster_thread_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupConfig::clear_has_max_cluster_thread_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupConfig::clear_max_cluster_thread_num() {
  max_cluster_thread_num_ = 10;
  clear_has_max_cluster_thread_num();
}
inline ::google::protobuf::int32 GroupConfig::max_cluster_thread_num() const {
  return max_cluster_thread_num_;
}
inline void GroupConfig::set_max_cluster_thread_num(::google::protobuf::int32 value) {
  set_has_max_cluster_thread_num();
  max_cluster_thread_num_ = value;
}

// optional bool is_allow_all_add = 7 [default = false];
inline bool GroupConfig::has_is_allow_all_add() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupConfig::set_has_is_allow_all_add() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupConfig::clear_has_is_allow_all_add() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupConfig::clear_is_allow_all_add() {
  is_allow_all_add_ = false;
  clear_has_is_allow_all_add();
}
inline bool GroupConfig::is_allow_all_add() const {
  return is_allow_all_add_;
}
inline void GroupConfig::set_is_allow_all_add(bool value) {
  set_has_is_allow_all_add();
  is_allow_all_add_ = value;
}

// optional string absolute_path = 11;
inline bool GroupConfig::has_absolute_path() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GroupConfig::set_has_absolute_path() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GroupConfig::clear_has_absolute_path() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GroupConfig::clear_absolute_path() {
  if (absolute_path_ != &::google::protobuf::internal::kEmptyString) {
    absolute_path_->clear();
  }
  clear_has_absolute_path();
}
inline const ::std::string& GroupConfig::absolute_path() const {
  return *absolute_path_;
}
inline void GroupConfig::set_absolute_path(const ::std::string& value) {
  set_has_absolute_path();
  if (absolute_path_ == &::google::protobuf::internal::kEmptyString) {
    absolute_path_ = new ::std::string;
  }
  absolute_path_->assign(value);
}
inline void GroupConfig::set_absolute_path(const char* value) {
  set_has_absolute_path();
  if (absolute_path_ == &::google::protobuf::internal::kEmptyString) {
    absolute_path_ = new ::std::string;
  }
  absolute_path_->assign(value);
}
inline void GroupConfig::set_absolute_path(const char* value, size_t size) {
  set_has_absolute_path();
  if (absolute_path_ == &::google::protobuf::internal::kEmptyString) {
    absolute_path_ = new ::std::string;
  }
  absolute_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupConfig::mutable_absolute_path() {
  set_has_absolute_path();
  if (absolute_path_ == &::google::protobuf::internal::kEmptyString) {
    absolute_path_ = new ::std::string;
  }
  return absolute_path_;
}
inline ::std::string* GroupConfig::release_absolute_path() {
  clear_has_absolute_path();
  if (absolute_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = absolute_path_;
    absolute_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string group_data_path = 12 [default = "/bbts-group-data"];
inline bool GroupConfig::has_group_data_path() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GroupConfig::set_has_group_data_path() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GroupConfig::clear_has_group_data_path() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GroupConfig::clear_group_data_path() {
  if (group_data_path_ != &_default_group_data_path_) {
    group_data_path_->assign(_default_group_data_path_);
  }
  clear_has_group_data_path();
}
inline const ::std::string& GroupConfig::group_data_path() const {
  return *group_data_path_;
}
inline void GroupConfig::set_group_data_path(const ::std::string& value) {
  set_has_group_data_path();
  if (group_data_path_ == &_default_group_data_path_) {
    group_data_path_ = new ::std::string;
  }
  group_data_path_->assign(value);
}
inline void GroupConfig::set_group_data_path(const char* value) {
  set_has_group_data_path();
  if (group_data_path_ == &_default_group_data_path_) {
    group_data_path_ = new ::std::string;
  }
  group_data_path_->assign(value);
}
inline void GroupConfig::set_group_data_path(const char* value, size_t size) {
  set_has_group_data_path();
  if (group_data_path_ == &_default_group_data_path_) {
    group_data_path_ = new ::std::string;
  }
  group_data_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupConfig::mutable_group_data_path() {
  set_has_group_data_path();
  if (group_data_path_ == &_default_group_data_path_) {
    group_data_path_ = new ::std::string(_default_group_data_path_);
  }
  return group_data_path_;
}
inline ::std::string* GroupConfig::release_group_data_path() {
  clear_has_group_data_path();
  if (group_data_path_ == &_default_group_data_path_) {
    return NULL;
  } else {
    ::std::string* temp = group_data_path_;
    group_data_path_ = const_cast< ::std::string*>(&_default_group_data_path_);
    return temp;
  }
}

// optional string log_file = 13 [default = "bbts-group.log"];
inline bool GroupConfig::has_log_file() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GroupConfig::set_has_log_file() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GroupConfig::clear_has_log_file() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GroupConfig::clear_log_file() {
  if (log_file_ != &_default_log_file_) {
    log_file_->assign(_default_log_file_);
  }
  clear_has_log_file();
}
inline const ::std::string& GroupConfig::log_file() const {
  return *log_file_;
}
inline void GroupConfig::set_log_file(const ::std::string& value) {
  set_has_log_file();
  if (log_file_ == &_default_log_file_) {
    log_file_ = new ::std::string;
  }
  log_file_->assign(value);
}
inline void GroupConfig::set_log_file(const char* value) {
  set_has_log_file();
  if (log_file_ == &_default_log_file_) {
    log_file_ = new ::std::string;
  }
  log_file_->assign(value);
}
inline void GroupConfig::set_log_file(const char* value, size_t size) {
  set_has_log_file();
  if (log_file_ == &_default_log_file_) {
    log_file_ = new ::std::string;
  }
  log_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupConfig::mutable_log_file() {
  set_has_log_file();
  if (log_file_ == &_default_log_file_) {
    log_file_ = new ::std::string(_default_log_file_);
  }
  return log_file_;
}
inline ::std::string* GroupConfig::release_log_file() {
  clear_has_log_file();
  if (log_file_ == &_default_log_file_) {
    return NULL;
  } else {
    ::std::string* temp = log_file_;
    log_file_ = const_cast< ::std::string*>(&_default_log_file_);
    return temp;
  }
}

// optional string resume_dir = 14 [default = "bbts-group.resume"];
inline bool GroupConfig::has_resume_dir() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GroupConfig::set_has_resume_dir() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GroupConfig::clear_has_resume_dir() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GroupConfig::clear_resume_dir() {
  if (resume_dir_ != &_default_resume_dir_) {
    resume_dir_->assign(_default_resume_dir_);
  }
  clear_has_resume_dir();
}
inline const ::std::string& GroupConfig::resume_dir() const {
  return *resume_dir_;
}
inline void GroupConfig::set_resume_dir(const ::std::string& value) {
  set_has_resume_dir();
  if (resume_dir_ == &_default_resume_dir_) {
    resume_dir_ = new ::std::string;
  }
  resume_dir_->assign(value);
}
inline void GroupConfig::set_resume_dir(const char* value) {
  set_has_resume_dir();
  if (resume_dir_ == &_default_resume_dir_) {
    resume_dir_ = new ::std::string;
  }
  resume_dir_->assign(value);
}
inline void GroupConfig::set_resume_dir(const char* value, size_t size) {
  set_has_resume_dir();
  if (resume_dir_ == &_default_resume_dir_) {
    resume_dir_ = new ::std::string;
  }
  resume_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupConfig::mutable_resume_dir() {
  set_has_resume_dir();
  if (resume_dir_ == &_default_resume_dir_) {
    resume_dir_ = new ::std::string(_default_resume_dir_);
  }
  return resume_dir_;
}
inline ::std::string* GroupConfig::release_resume_dir() {
  clear_has_resume_dir();
  if (resume_dir_ == &_default_resume_dir_) {
    return NULL;
  } else {
    ::std::string* temp = resume_dir_;
    resume_dir_ = const_cast< ::std::string*>(&_default_resume_dir_);
    return temp;
  }
}

// optional string lock_file = 15 [default = "bbts-group.lock"];
inline bool GroupConfig::has_lock_file() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GroupConfig::set_has_lock_file() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GroupConfig::clear_has_lock_file() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GroupConfig::clear_lock_file() {
  if (lock_file_ != &_default_lock_file_) {
    lock_file_->assign(_default_lock_file_);
  }
  clear_has_lock_file();
}
inline const ::std::string& GroupConfig::lock_file() const {
  return *lock_file_;
}
inline void GroupConfig::set_lock_file(const ::std::string& value) {
  set_has_lock_file();
  if (lock_file_ == &_default_lock_file_) {
    lock_file_ = new ::std::string;
  }
  lock_file_->assign(value);
}
inline void GroupConfig::set_lock_file(const char* value) {
  set_has_lock_file();
  if (lock_file_ == &_default_lock_file_) {
    lock_file_ = new ::std::string;
  }
  lock_file_->assign(value);
}
inline void GroupConfig::set_lock_file(const char* value, size_t size) {
  set_has_lock_file();
  if (lock_file_ == &_default_lock_file_) {
    lock_file_ = new ::std::string;
  }
  lock_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupConfig::mutable_lock_file() {
  set_has_lock_file();
  if (lock_file_ == &_default_lock_file_) {
    lock_file_ = new ::std::string(_default_lock_file_);
  }
  return lock_file_;
}
inline ::std::string* GroupConfig::release_lock_file() {
  clear_has_lock_file();
  if (lock_file_ == &_default_lock_file_) {
    return NULL;
  } else {
    ::std::string* temp = lock_file_;
    lock_file_ = const_cast< ::std::string*>(&_default_lock_file_);
    return temp;
  }
}

// optional string unix_socket = 16 [default = "bbts-group.sock"];
inline bool GroupConfig::has_unix_socket() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GroupConfig::set_has_unix_socket() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GroupConfig::clear_has_unix_socket() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GroupConfig::clear_unix_socket() {
  if (unix_socket_ != &_default_unix_socket_) {
    unix_socket_->assign(_default_unix_socket_);
  }
  clear_has_unix_socket();
}
inline const ::std::string& GroupConfig::unix_socket() const {
  return *unix_socket_;
}
inline void GroupConfig::set_unix_socket(const ::std::string& value) {
  set_has_unix_socket();
  if (unix_socket_ == &_default_unix_socket_) {
    unix_socket_ = new ::std::string;
  }
  unix_socket_->assign(value);
}
inline void GroupConfig::set_unix_socket(const char* value) {
  set_has_unix_socket();
  if (unix_socket_ == &_default_unix_socket_) {
    unix_socket_ = new ::std::string;
  }
  unix_socket_->assign(value);
}
inline void GroupConfig::set_unix_socket(const char* value, size_t size) {
  set_has_unix_socket();
  if (unix_socket_ == &_default_unix_socket_) {
    unix_socket_ = new ::std::string;
  }
  unix_socket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupConfig::mutable_unix_socket() {
  set_has_unix_socket();
  if (unix_socket_ == &_default_unix_socket_) {
    unix_socket_ = new ::std::string(_default_unix_socket_);
  }
  return unix_socket_;
}
inline ::std::string* GroupConfig::release_unix_socket() {
  clear_has_unix_socket();
  if (unix_socket_ == &_default_unix_socket_) {
    return NULL;
  } else {
    ::std::string* temp = unix_socket_;
    unix_socket_ = const_cast< ::std::string*>(&_default_unix_socket_);
    return temp;
  }
}

// optional string peer_stat_log_file = 17 [default = "bbts-group.peer"];
inline bool GroupConfig::has_peer_stat_log_file() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GroupConfig::set_has_peer_stat_log_file() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GroupConfig::clear_has_peer_stat_log_file() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GroupConfig::clear_peer_stat_log_file() {
  if (peer_stat_log_file_ != &_default_peer_stat_log_file_) {
    peer_stat_log_file_->assign(_default_peer_stat_log_file_);
  }
  clear_has_peer_stat_log_file();
}
inline const ::std::string& GroupConfig::peer_stat_log_file() const {
  return *peer_stat_log_file_;
}
inline void GroupConfig::set_peer_stat_log_file(const ::std::string& value) {
  set_has_peer_stat_log_file();
  if (peer_stat_log_file_ == &_default_peer_stat_log_file_) {
    peer_stat_log_file_ = new ::std::string;
  }
  peer_stat_log_file_->assign(value);
}
inline void GroupConfig::set_peer_stat_log_file(const char* value) {
  set_has_peer_stat_log_file();
  if (peer_stat_log_file_ == &_default_peer_stat_log_file_) {
    peer_stat_log_file_ = new ::std::string;
  }
  peer_stat_log_file_->assign(value);
}
inline void GroupConfig::set_peer_stat_log_file(const char* value, size_t size) {
  set_has_peer_stat_log_file();
  if (peer_stat_log_file_ == &_default_peer_stat_log_file_) {
    peer_stat_log_file_ = new ::std::string;
  }
  peer_stat_log_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupConfig::mutable_peer_stat_log_file() {
  set_has_peer_stat_log_file();
  if (peer_stat_log_file_ == &_default_peer_stat_log_file_) {
    peer_stat_log_file_ = new ::std::string(_default_peer_stat_log_file_);
  }
  return peer_stat_log_file_;
}
inline ::std::string* GroupConfig::release_peer_stat_log_file() {
  clear_has_peer_stat_log_file();
  if (peer_stat_log_file_ == &_default_peer_stat_log_file_) {
    return NULL;
  } else {
    ::std::string* temp = peer_stat_log_file_;
    peer_stat_log_file_ = const_cast< ::std::string*>(&_default_peer_stat_log_file_);
    return temp;
  }
}

// optional int32 max_metadata_size = 31 [default = 50];
inline bool GroupConfig::has_max_metadata_size() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GroupConfig::set_has_max_metadata_size() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GroupConfig::clear_has_max_metadata_size() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GroupConfig::clear_max_metadata_size() {
  max_metadata_size_ = 50;
  clear_has_max_metadata_size();
}
inline ::google::protobuf::int32 GroupConfig::max_metadata_size() const {
  return max_metadata_size_;
}
inline void GroupConfig::set_max_metadata_size(::google::protobuf::int32 value) {
  set_has_max_metadata_size();
  max_metadata_size_ = value;
}

// optional int32 peers_num_want = 32 [default = 25];
inline bool GroupConfig::has_peers_num_want() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GroupConfig::set_has_peers_num_want() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GroupConfig::clear_has_peers_num_want() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GroupConfig::clear_peers_num_want() {
  peers_num_want_ = 25;
  clear_has_peers_num_want();
}
inline ::google::protobuf::int32 GroupConfig::peers_num_want() const {
  return peers_num_want_;
}
inline void GroupConfig::set_peers_num_want(::google::protobuf::int32 value) {
  set_has_peers_num_want();
  peers_num_want_ = value;
}

// optional bool disk_io_read_mode = 33 [default = true];
inline bool GroupConfig::has_disk_io_read_mode() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GroupConfig::set_has_disk_io_read_mode() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GroupConfig::clear_has_disk_io_read_mode() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GroupConfig::clear_disk_io_read_mode() {
  disk_io_read_mode_ = true;
  clear_has_disk_io_read_mode();
}
inline bool GroupConfig::disk_io_read_mode() const {
  return disk_io_read_mode_;
}
inline void GroupConfig::set_disk_io_read_mode(bool value) {
  set_has_disk_io_read_mode();
  disk_io_read_mode_ = value;
}

// optional bool disk_io_write_mode = 34 [default = true];
inline bool GroupConfig::has_disk_io_write_mode() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GroupConfig::set_has_disk_io_write_mode() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GroupConfig::clear_has_disk_io_write_mode() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GroupConfig::clear_disk_io_write_mode() {
  disk_io_write_mode_ = true;
  clear_has_disk_io_write_mode();
}
inline bool GroupConfig::disk_io_write_mode() const {
  return disk_io_write_mode_;
}
inline void GroupConfig::set_disk_io_write_mode(bool value) {
  set_has_disk_io_write_mode();
  disk_io_write_mode_ = value;
}

// optional int32 seed_announce_interval = 35 [default = 1800];
inline bool GroupConfig::has_seed_announce_interval() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GroupConfig::set_has_seed_announce_interval() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GroupConfig::clear_has_seed_announce_interval() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GroupConfig::clear_seed_announce_interval() {
  seed_announce_interval_ = 1800;
  clear_has_seed_announce_interval();
}
inline ::google::protobuf::int32 GroupConfig::seed_announce_interval() const {
  return seed_announce_interval_;
}
inline void GroupConfig::set_seed_announce_interval(::google::protobuf::int32 value) {
  set_has_seed_announce_interval();
  seed_announce_interval_ = value;
}

// optional int32 min_reconnect_time = 36 [default = 1];
inline bool GroupConfig::has_min_reconnect_time() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GroupConfig::set_has_min_reconnect_time() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GroupConfig::clear_has_min_reconnect_time() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GroupConfig::clear_min_reconnect_time() {
  min_reconnect_time_ = 1;
  clear_has_min_reconnect_time();
}
inline ::google::protobuf::int32 GroupConfig::min_reconnect_time() const {
  return min_reconnect_time_;
}
inline void GroupConfig::set_min_reconnect_time(::google::protobuf::int32 value) {
  set_has_min_reconnect_time();
  min_reconnect_time_ = value;
}

// optional int32 max_queued_disk_bytes = 37 [default = 20];
inline bool GroupConfig::has_max_queued_disk_bytes() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GroupConfig::set_has_max_queued_disk_bytes() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GroupConfig::clear_has_max_queued_disk_bytes() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GroupConfig::clear_max_queued_disk_bytes() {
  max_queued_disk_bytes_ = 20;
  clear_has_max_queued_disk_bytes();
}
inline ::google::protobuf::int32 GroupConfig::max_queued_disk_bytes() const {
  return max_queued_disk_bytes_;
}
inline void GroupConfig::set_max_queued_disk_bytes(::google::protobuf::int32 value) {
  set_has_max_queued_disk_bytes();
  max_queued_disk_bytes_ = value;
}

// optional int32 max_out_request_queue = 38 [default = 1500];
inline bool GroupConfig::has_max_out_request_queue() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void GroupConfig::set_has_max_out_request_queue() {
  _has_bits_[0] |= 0x00200000u;
}
inline void GroupConfig::clear_has_max_out_request_queue() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void GroupConfig::clear_max_out_request_queue() {
  max_out_request_queue_ = 1500;
  clear_has_max_out_request_queue();
}
inline ::google::protobuf::int32 GroupConfig::max_out_request_queue() const {
  return max_out_request_queue_;
}
inline void GroupConfig::set_max_out_request_queue(::google::protobuf::int32 value) {
  set_has_max_out_request_queue();
  max_out_request_queue_ = value;
}

// optional int32 max_allowed_in_request_queue = 39 [default = 2000];
inline bool GroupConfig::has_max_allowed_in_request_queue() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void GroupConfig::set_has_max_allowed_in_request_queue() {
  _has_bits_[0] |= 0x00400000u;
}
inline void GroupConfig::clear_has_max_allowed_in_request_queue() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void GroupConfig::clear_max_allowed_in_request_queue() {
  max_allowed_in_request_queue_ = 2000;
  clear_has_max_allowed_in_request_queue();
}
inline ::google::protobuf::int32 GroupConfig::max_allowed_in_request_queue() const {
  return max_allowed_in_request_queue_;
}
inline void GroupConfig::set_max_allowed_in_request_queue(::google::protobuf::int32 value) {
  set_has_max_allowed_in_request_queue();
  max_allowed_in_request_queue_ = value;
}

// optional int32 whole_pieces_threshold = 40 [default = 20];
inline bool GroupConfig::has_whole_pieces_threshold() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void GroupConfig::set_has_whole_pieces_threshold() {
  _has_bits_[0] |= 0x00800000u;
}
inline void GroupConfig::clear_has_whole_pieces_threshold() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void GroupConfig::clear_whole_pieces_threshold() {
  whole_pieces_threshold_ = 20;
  clear_has_whole_pieces_threshold();
}
inline ::google::protobuf::int32 GroupConfig::whole_pieces_threshold() const {
  return whole_pieces_threshold_;
}
inline void GroupConfig::set_whole_pieces_threshold(::google::protobuf::int32 value) {
  set_has_whole_pieces_threshold();
  whole_pieces_threshold_ = value;
}

// optional int32 request_queue_time = 41 [default = 3];
inline bool GroupConfig::has_request_queue_time() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void GroupConfig::set_has_request_queue_time() {
  _has_bits_[0] |= 0x01000000u;
}
inline void GroupConfig::clear_has_request_queue_time() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void GroupConfig::clear_request_queue_time() {
  request_queue_time_ = 3;
  clear_has_request_queue_time();
}
inline ::google::protobuf::int32 GroupConfig::request_queue_time() const {
  return request_queue_time_;
}
inline void GroupConfig::set_request_queue_time(::google::protobuf::int32 value) {
  set_has_request_queue_time();
  request_queue_time_ = value;
}

// optional int32 cache_size = 42 [default = 128];
inline bool GroupConfig::has_cache_size() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void GroupConfig::set_has_cache_size() {
  _has_bits_[0] |= 0x02000000u;
}
inline void GroupConfig::clear_has_cache_size() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void GroupConfig::clear_cache_size() {
  cache_size_ = 128;
  clear_has_cache_size();
}
inline ::google::protobuf::int32 GroupConfig::cache_size() const {
  return cache_size_;
}
inline void GroupConfig::set_cache_size(::google::protobuf::int32 value) {
  set_has_cache_size();
  cache_size_ = value;
}

// optional int32 cache_expiry = 43 [default = 300];
inline bool GroupConfig::has_cache_expiry() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void GroupConfig::set_has_cache_expiry() {
  _has_bits_[0] |= 0x04000000u;
}
inline void GroupConfig::clear_has_cache_expiry() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void GroupConfig::clear_cache_expiry() {
  cache_expiry_ = 300;
  clear_has_cache_expiry();
}
inline ::google::protobuf::int32 GroupConfig::cache_expiry() const {
  return cache_expiry_;
}
inline void GroupConfig::set_cache_expiry(::google::protobuf::int32 value) {
  set_has_cache_expiry();
  cache_expiry_ = value;
}

// optional int32 read_cache_line_size = 44 [default = 32];
inline bool GroupConfig::has_read_cache_line_size() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void GroupConfig::set_has_read_cache_line_size() {
  _has_bits_[0] |= 0x08000000u;
}
inline void GroupConfig::clear_has_read_cache_line_size() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void GroupConfig::clear_read_cache_line_size() {
  read_cache_line_size_ = 32;
  clear_has_read_cache_line_size();
}
inline ::google::protobuf::int32 GroupConfig::read_cache_line_size() const {
  return read_cache_line_size_;
}
inline void GroupConfig::set_read_cache_line_size(::google::protobuf::int32 value) {
  set_has_read_cache_line_size();
  read_cache_line_size_ = value;
}

// optional int32 write_cache_line_size = 45 [default = 32];
inline bool GroupConfig::has_write_cache_line_size() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void GroupConfig::set_has_write_cache_line_size() {
  _has_bits_[0] |= 0x10000000u;
}
inline void GroupConfig::clear_has_write_cache_line_size() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void GroupConfig::clear_write_cache_line_size() {
  write_cache_line_size_ = 32;
  clear_has_write_cache_line_size();
}
inline ::google::protobuf::int32 GroupConfig::write_cache_line_size() const {
  return write_cache_line_size_;
}
inline void GroupConfig::set_write_cache_line_size(::google::protobuf::int32 value) {
  set_has_write_cache_line_size();
  write_cache_line_size_ = value;
}

// optional int32 file_pool_size = 46 [default = 500];
inline bool GroupConfig::has_file_pool_size() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void GroupConfig::set_has_file_pool_size() {
  _has_bits_[0] |= 0x20000000u;
}
inline void GroupConfig::clear_has_file_pool_size() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void GroupConfig::clear_file_pool_size() {
  file_pool_size_ = 500;
  clear_has_file_pool_size();
}
inline ::google::protobuf::int32 GroupConfig::file_pool_size() const {
  return file_pool_size_;
}
inline void GroupConfig::set_file_pool_size(::google::protobuf::int32 value) {
  set_has_file_pool_size();
  file_pool_size_ = value;
}

// optional int32 send_buffer_watermark = 47 [default = 10];
inline bool GroupConfig::has_send_buffer_watermark() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void GroupConfig::set_has_send_buffer_watermark() {
  _has_bits_[0] |= 0x40000000u;
}
inline void GroupConfig::clear_has_send_buffer_watermark() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void GroupConfig::clear_send_buffer_watermark() {
  send_buffer_watermark_ = 10;
  clear_has_send_buffer_watermark();
}
inline ::google::protobuf::int32 GroupConfig::send_buffer_watermark() const {
  return send_buffer_watermark_;
}
inline void GroupConfig::set_send_buffer_watermark(::google::protobuf::int32 value) {
  set_has_send_buffer_watermark();
  send_buffer_watermark_ = value;
}

// optional int32 send_buffer_low_watermark = 48 [default = 1024];
inline bool GroupConfig::has_send_buffer_low_watermark() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void GroupConfig::set_has_send_buffer_low_watermark() {
  _has_bits_[0] |= 0x80000000u;
}
inline void GroupConfig::clear_has_send_buffer_low_watermark() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void GroupConfig::clear_send_buffer_low_watermark() {
  send_buffer_low_watermark_ = 1024;
  clear_has_send_buffer_low_watermark();
}
inline ::google::protobuf::int32 GroupConfig::send_buffer_low_watermark() const {
  return send_buffer_low_watermark_;
}
inline void GroupConfig::set_send_buffer_low_watermark(::google::protobuf::int32 value) {
  set_has_send_buffer_low_watermark();
  send_buffer_low_watermark_ = value;
}

// optional int32 send_socket_buffer_size = 49 [default = 2048];
inline bool GroupConfig::has_send_socket_buffer_size() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void GroupConfig::set_has_send_socket_buffer_size() {
  _has_bits_[1] |= 0x00000001u;
}
inline void GroupConfig::clear_has_send_socket_buffer_size() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void GroupConfig::clear_send_socket_buffer_size() {
  send_socket_buffer_size_ = 2048;
  clear_has_send_socket_buffer_size();
}
inline ::google::protobuf::int32 GroupConfig::send_socket_buffer_size() const {
  return send_socket_buffer_size_;
}
inline void GroupConfig::set_send_socket_buffer_size(::google::protobuf::int32 value) {
  set_has_send_socket_buffer_size();
  send_socket_buffer_size_ = value;
}

// optional int32 recv_socket_buffer_size = 50 [default = 2048];
inline bool GroupConfig::has_recv_socket_buffer_size() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void GroupConfig::set_has_recv_socket_buffer_size() {
  _has_bits_[1] |= 0x00000002u;
}
inline void GroupConfig::clear_has_recv_socket_buffer_size() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void GroupConfig::clear_recv_socket_buffer_size() {
  recv_socket_buffer_size_ = 2048;
  clear_has_recv_socket_buffer_size();
}
inline ::google::protobuf::int32 GroupConfig::recv_socket_buffer_size() const {
  return recv_socket_buffer_size_;
}
inline void GroupConfig::set_recv_socket_buffer_size(::google::protobuf::int32 value) {
  set_has_recv_socket_buffer_size();
  recv_socket_buffer_size_ = value;
}

// optional int32 active_seeds = 51 [default = 32000];
inline bool GroupConfig::has_active_seeds() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void GroupConfig::set_has_active_seeds() {
  _has_bits_[1] |= 0x00000004u;
}
inline void GroupConfig::clear_has_active_seeds() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void GroupConfig::clear_active_seeds() {
  active_seeds_ = 32000;
  clear_has_active_seeds();
}
inline ::google::protobuf::int32 GroupConfig::active_seeds() const {
  return active_seeds_;
}
inline void GroupConfig::set_active_seeds(::google::protobuf::int32 value) {
  set_has_active_seeds();
  active_seeds_ = value;
}

// optional int32 active_limit = 52 [default = 32000];
inline bool GroupConfig::has_active_limit() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void GroupConfig::set_has_active_limit() {
  _has_bits_[1] |= 0x00000008u;
}
inline void GroupConfig::clear_has_active_limit() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void GroupConfig::clear_active_limit() {
  active_limit_ = 32000;
  clear_has_active_limit();
}
inline ::google::protobuf::int32 GroupConfig::active_limit() const {
  return active_limit_;
}
inline void GroupConfig::set_active_limit(::google::protobuf::int32 value) {
  set_has_active_limit();
  active_limit_ = value;
}

// optional int32 active_downloads = 53 [default = 32000];
inline bool GroupConfig::has_active_downloads() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void GroupConfig::set_has_active_downloads() {
  _has_bits_[1] |= 0x00000010u;
}
inline void GroupConfig::clear_has_active_downloads() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void GroupConfig::clear_active_downloads() {
  active_downloads_ = 32000;
  clear_has_active_downloads();
}
inline ::google::protobuf::int32 GroupConfig::active_downloads() const {
  return active_downloads_;
}
inline void GroupConfig::set_active_downloads(::google::protobuf::int32 value) {
  set_has_active_downloads();
  active_downloads_ = value;
}

// optional bool suggest_mode = 54 [default = true];
inline bool GroupConfig::has_suggest_mode() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void GroupConfig::set_has_suggest_mode() {
  _has_bits_[1] |= 0x00000020u;
}
inline void GroupConfig::clear_has_suggest_mode() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void GroupConfig::clear_suggest_mode() {
  suggest_mode_ = true;
  clear_has_suggest_mode();
}
inline bool GroupConfig::suggest_mode() const {
  return suggest_mode_;
}
inline void GroupConfig::set_suggest_mode(bool value) {
  set_has_suggest_mode();
  suggest_mode_ = value;
}

// optional int32 listen_port = 55 [default = 18000];
inline bool GroupConfig::has_listen_port() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void GroupConfig::set_has_listen_port() {
  _has_bits_[1] |= 0x00000040u;
}
inline void GroupConfig::clear_has_listen_port() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void GroupConfig::clear_listen_port() {
  listen_port_ = 18000;
  clear_has_listen_port();
}
inline ::google::protobuf::int32 GroupConfig::listen_port() const {
  return listen_port_;
}
inline void GroupConfig::set_listen_port(::google::protobuf::int32 value) {
  set_has_listen_port();
  listen_port_ = value;
}

// optional int32 peer_connection_timeout = 56 [default = 3];
inline bool GroupConfig::has_peer_connection_timeout() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void GroupConfig::set_has_peer_connection_timeout() {
  _has_bits_[1] |= 0x00000080u;
}
inline void GroupConfig::clear_has_peer_connection_timeout() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void GroupConfig::clear_peer_connection_timeout() {
  peer_connection_timeout_ = 3;
  clear_has_peer_connection_timeout();
}
inline ::google::protobuf::int32 GroupConfig::peer_connection_timeout() const {
  return peer_connection_timeout_;
}
inline void GroupConfig::set_peer_connection_timeout(::google::protobuf::int32 value) {
  set_has_peer_connection_timeout();
  peer_connection_timeout_ = value;
}

// optional bool disable_os_cache = 57 [default = false];
inline bool GroupConfig::has_disable_os_cache() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void GroupConfig::set_has_disable_os_cache() {
  _has_bits_[1] |= 0x00000100u;
}
inline void GroupConfig::clear_has_disable_os_cache() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void GroupConfig::clear_disable_os_cache() {
  disable_os_cache_ = false;
  clear_has_disable_os_cache();
}
inline bool GroupConfig::disable_os_cache() const {
  return disable_os_cache_;
}
inline void GroupConfig::set_disable_os_cache(bool value) {
  set_has_disable_os_cache();
  disable_os_cache_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace bbts

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GroupConf_2eproto__INCLUDED
